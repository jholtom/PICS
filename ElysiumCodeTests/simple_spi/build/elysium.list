
build/elysium.elf:     file format elf32-msp430


Disassembly of section __interrupt_vector_1:

0000ff90 <__interrupt_vector_1>:
    ff90:	76 7c       	subc.b	@r12+,	r6	;

Disassembly of section __interrupt_vector_2:

0000ff92 <__interrupt_vector_2>:
    ff92:	78 7c       	subc.b	@r12+,	r8	;

Disassembly of section __interrupt_vector_3:

0000ff94 <__interrupt_vector_3>:
    ff94:	7a 7c       	subc.b	@r12+,	r10	;

Disassembly of section __interrupt_vector_4:

0000ff96 <__interrupt_vector_4>:
    ff96:	7c 7c       	subc.b	@r12+,	r12	;

Disassembly of section __interrupt_vector_5:

0000ff98 <__interrupt_vector_5>:
    ff98:	7e 7c       	subc.b	@r12+,	r14	;

Disassembly of section __interrupt_vector_6:

0000ff9a <__interrupt_vector_6>:
    ff9a:	80 7c 00 00 	Address 0x000000000000ff9c is out of bounds.
subc	r12,	0xffff	; PC rel. 0xff9b

Disassembly of section __interrupt_vector_7:

0000ff9c <__interrupt_vector_7>:
    ff9c:	82 7c 00 00 	Address 0x000000000000ff9e is out of bounds.
subc	r12,	&0xffff	;

Disassembly of section __interrupt_vector_8:

0000ff9e <__interrupt_vector_8>:
    ff9e:	84 7c 00 00 	Address 0x000000000000ffa0 is out of bounds.
subc	r12,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_9:

0000ffa0 <__interrupt_vector_9>:
    ffa0:	86 7c 00 00 	Address 0x000000000000ffa2 is out of bounds.
subc	r12,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_10:

0000ffa2 <__interrupt_vector_10>:
    ffa2:	88 7c 00 00 	Address 0x000000000000ffa4 is out of bounds.
subc	r12,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_11:

0000ffa4 <__interrupt_vector_11>:
    ffa4:	8a 7c 00 00 	Address 0x000000000000ffa6 is out of bounds.
subc	r12,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_12:

0000ffa6 <__interrupt_vector_12>:
    ffa6:	8c 7c 00 00 	Address 0x000000000000ffa8 is out of bounds.
subc	r12,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_13:

0000ffa8 <__interrupt_vector_13>:
    ffa8:	8e 7c 00 00 	Address 0x000000000000ffaa is out of bounds.
subc	r12,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_14:

0000ffaa <__interrupt_vector_14>:
    ffaa:	90 7c 00 00 	Address 0x000000000000ffac is out of bounds.
Address 0x000000000000ffae is out of bounds.
subc	-1(r12),0xffff	; PC rel. 0xffad
    ffae:	00 00 

Disassembly of section __interrupt_vector_15:

0000ffac <__interrupt_vector_15>:
    ffac:	92 7c 00 00 	Address 0x000000000000ffae is out of bounds.
Address 0x000000000000ffb0 is out of bounds.
subc	-1(r12),&0xffff	;
    ffb0:	00 00 

Disassembly of section __interrupt_vector_16:

0000ffae <__interrupt_vector_16>:
    ffae:	94 7c 00 00 	Address 0x000000000000ffb0 is out of bounds.
Address 0x000000000000ffb2 is out of bounds.
subc	-1(r12),-1(r4)	; 0xffff
    ffb2:	00 00 

Disassembly of section __interrupt_vector_17:

0000ffb0 <__interrupt_vector_17>:
    ffb0:	96 7c 00 00 	Address 0x000000000000ffb2 is out of bounds.
Address 0x000000000000ffb4 is out of bounds.
subc	-1(r12),-1(r6)	; 0xffff
    ffb4:	00 00 

Disassembly of section __interrupt_vector_18:

0000ffb2 <__interrupt_vector_18>:
    ffb2:	98 7c 00 00 	Address 0x000000000000ffb4 is out of bounds.
Address 0x000000000000ffb6 is out of bounds.
subc	-1(r12),-1(r8)	; 0xffff
    ffb6:	00 00 

Disassembly of section __interrupt_vector_19:

0000ffb4 <__interrupt_vector_19>:
    ffb4:	9a 7c 00 00 	Address 0x000000000000ffb6 is out of bounds.
Address 0x000000000000ffb8 is out of bounds.
subc	-1(r12),-1(r10)	; 0xffff
    ffb8:	00 00 

Disassembly of section __interrupt_vector_20:

0000ffb6 <__interrupt_vector_20>:
    ffb6:	9c 7c 00 00 	Address 0x000000000000ffb8 is out of bounds.
Address 0x000000000000ffba is out of bounds.
subc	-1(r12),-1(r12)	; 0xffff
    ffba:	00 00 

Disassembly of section __interrupt_vector_21:

0000ffb8 <__interrupt_vector_21>:
    ffb8:	9e 7c 00 00 	Address 0x000000000000ffba is out of bounds.
Address 0x000000000000ffbc is out of bounds.
subc	-1(r12),-1(r14)	; 0xffff
    ffbc:	00 00 

Disassembly of section __interrupt_vector_22:

0000ffba <__interrupt_vector_22>:
    ffba:	a0 7c 00 00 	Address 0x000000000000ffbc is out of bounds.
subc	@r12,	0xffff	; PC rel. 0xffbb

Disassembly of section __interrupt_vector_23:

0000ffbc <__interrupt_vector_23>:
    ffbc:	a2 7c 00 00 	Address 0x000000000000ffbe is out of bounds.
subc	@r12,	&0xffff	;

Disassembly of section __interrupt_vector_24:

0000ffbe <__interrupt_vector_24>:
    ffbe:	a4 7c 00 00 	Address 0x000000000000ffc0 is out of bounds.
subc	@r12,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_25:

0000ffc0 <__interrupt_vector_25>:
    ffc0:	a6 7c 00 00 	Address 0x000000000000ffc2 is out of bounds.
subc	@r12,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_26:

0000ffc2 <__interrupt_vector_26>:
    ffc2:	a8 7c 00 00 	Address 0x000000000000ffc4 is out of bounds.
subc	@r12,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_27:

0000ffc4 <__interrupt_vector_27>:
    ffc4:	aa 7c 00 00 	Address 0x000000000000ffc6 is out of bounds.
subc	@r12,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_28:

0000ffc6 <__interrupt_vector_28>:
    ffc6:	ac 7c 00 00 	Address 0x000000000000ffc8 is out of bounds.
subc	@r12,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_29:

0000ffc8 <__interrupt_vector_29>:
    ffc8:	ae 7c 00 00 	Address 0x000000000000ffca is out of bounds.
subc	@r12,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_30:

0000ffca <__interrupt_vector_30>:
    ffca:	b0 7c 00 00 	Address 0x000000000000ffcc is out of bounds.
subc	@r12+,	0xffff	; PC rel. 0xffcb

Disassembly of section __interrupt_vector_31:

0000ffcc <__interrupt_vector_31>:
    ffcc:	b2 7c 00 00 	Address 0x000000000000ffce is out of bounds.
subc	@r12+,	&0xffff	;

Disassembly of section __interrupt_vector_32:

0000ffce <__interrupt_vector_32>:
    ffce:	b4 7c 00 00 	Address 0x000000000000ffd0 is out of bounds.
subc	@r12+,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_33:

0000ffd0 <__interrupt_vector_33>:
    ffd0:	b6 7c 00 00 	Address 0x000000000000ffd2 is out of bounds.
subc	@r12+,	-1(r6)	; 0xffff

Disassembly of section __interrupt_vector_34:

0000ffd2 <__interrupt_vector_34>:
    ffd2:	b8 7c 00 00 	Address 0x000000000000ffd4 is out of bounds.
subc	@r12+,	-1(r8)	; 0xffff

Disassembly of section __interrupt_vector_35:

0000ffd4 <__interrupt_vector_35>:
    ffd4:	ba 7c 00 00 	Address 0x000000000000ffd6 is out of bounds.
subc	@r12+,	-1(r10)	; 0xffff

Disassembly of section __interrupt_vector_36:

0000ffd6 <__interrupt_vector_36>:
    ffd6:	bc 7c 00 00 	Address 0x000000000000ffd8 is out of bounds.
subc	@r12+,	-1(r12)	; 0xffff

Disassembly of section __interrupt_vector_37:

0000ffd8 <__interrupt_vector_37>:
    ffd8:	be 7c 00 00 	Address 0x000000000000ffda is out of bounds.
subc	@r12+,	-1(r14)	; 0xffff

Disassembly of section __interrupt_vector_38:

0000ffda <__interrupt_vector_38>:
    ffda:	c0 7c 00 00 	Address 0x000000000000ffdc is out of bounds.
subc.b	r12,	0xffff	; PC rel. 0xffdb

Disassembly of section __interrupt_vector_39:

0000ffdc <__interrupt_vector_39>:
    ffdc:	c2 7c 00 00 	Address 0x000000000000ffde is out of bounds.
subc.b	r12,	&0xffff	;

Disassembly of section __interrupt_vector_40:

0000ffde <__interrupt_vector_40>:
    ffde:	c4 7c 00 00 	Address 0x000000000000ffe0 is out of bounds.
subc.b	r12,	-1(r4)	; 0xffff

Disassembly of section __interrupt_vector_41:

0000ffe0 <__interrupt_vector_41>:
    ffe0:	c6 7c       	interrupt service routine at 0x7cc6

Disassembly of section __interrupt_vector_42:

0000ffe2 <__interrupt_vector_42>:
    ffe2:	c8 7c       	interrupt service routine at 0x7cc8

Disassembly of section __interrupt_vector_43:

0000ffe4 <__interrupt_vector_43>:
    ffe4:	60 77       	interrupt service routine at 0x7760

Disassembly of section __interrupt_vector_44:

0000ffe6 <__interrupt_vector_44>:
    ffe6:	ca 7c       	interrupt service routine at 0x7cca

Disassembly of section __interrupt_vector_45:

0000ffe8 <__interrupt_vector_45>:
    ffe8:	cc 7c       	interrupt service routine at 0x7ccc

Disassembly of section __interrupt_vector_46:

0000ffea <__interrupt_vector_46>:
    ffea:	ce 7c       	interrupt service routine at 0x7cce

Disassembly of section __interrupt_vector_47:

0000ffec <__interrupt_vector_47>:
    ffec:	d0 7c       	interrupt service routine at 0x7cd0

Disassembly of section __interrupt_vector_48:

0000ffee <__interrupt_vector_48>:
    ffee:	d2 7c       	interrupt service routine at 0x7cd2

Disassembly of section __interrupt_vector_49:

0000fff0 <__interrupt_vector_49>:
    fff0:	52 70       	interrupt service routine at 0x7052

Disassembly of section __interrupt_vector_50:

0000fff2 <__interrupt_vector_50>:
    fff2:	d4 7c       	interrupt service routine at 0x7cd4

Disassembly of section __interrupt_vector_51:

0000fff4 <__interrupt_vector_51>:
    fff4:	d6 7c       	interrupt service routine at 0x7cd6

Disassembly of section __interrupt_vector_52:

0000fff6 <__interrupt_vector_52>:
    fff6:	c2 6b       	interrupt service routine at 0x6bc2

Disassembly of section __interrupt_vector_53:

0000fff8 <__interrupt_vector_53>:
    fff8:	d8 7c       	interrupt service routine at 0x7cd8

Disassembly of section __interrupt_vector_54:

0000fffa <__interrupt_vector_54>:
    fffa:	da 7c       	interrupt service routine at 0x7cda

Disassembly of section __interrupt_vector_55:

0000fffc <__interrupt_vector_55>:
    fffc:	dc 7c       	interrupt service routine at 0x7cdc

Disassembly of section .text:

00005a96 <__crt0_start>:
    5a96:	31 40 00 50 	mov	#20480,	r1	;#0x5000

00005a9a <__crt0_init_bss>:
    5a9a:	3c 40 7c 51 	mov	#20860,	r12	;#0x517c

00005a9e <.Loc.74.1>:
    5a9e:	0d 43       	clr	r13		;

00005aa0 <.Loc.75.1>:
    5aa0:	3e 40 1a 09 	mov	#2330,	r14	;#0x091a

00005aa4 <.Loc.79.1>:
    5aa4:	b0 12 66 80 	call	#32870		;#0x8066

00005aa8 <__crt0_movedata>:
    5aa8:	3c 40 68 51 	mov	#20840,	r12	;#0x5168

00005aac <.Loc.116.1>:
    5aac:	3d 40 68 51 	mov	#20840,	r13	;#0x5168

00005ab0 <.Loc.119.1>:
    5ab0:	0d 9c       	cmp	r12,	r13	;

00005ab2 <.Loc.120.1>:
    5ab2:	04 24       	jz	$+10     	;abs 0x5abc

00005ab4 <.Loc.122.1>:
    5ab4:	3e 40 14 00 	mov	#20,	r14	;#0x0014

00005ab8 <.Loc.124.1>:
    5ab8:	b0 12 2c 80 	call	#32812		;#0x802c

00005abc <__crt0_call_just_main>:
    5abc:	0c 43       	clr	r12		;

00005abe <.Loc.181.1>:
    5abe:	b0 12 30 7e 	call	#32304		;#0x7e30

00005ac2 <port_init>:
/**
 * @brief   Port-related initialization code.
 */
static inline void port_init(void) {

}
    5ac2:	03 43       	nop			
    5ac4:	30 41       	ret			

00005ac6 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    5ac6:	32 c2       	dint			

00005ac8 <.Loc.347.1>:
  asm volatile("nop");
    5ac8:	03 43       	nop			

00005aca <.Loc.348.1>:
}
    5aca:	03 43       	nop			
    5acc:	30 41       	ret			

00005ace <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    5ace:	03 43       	nop			

00005ad0 <.Loc.355.1>:
  _enable_interrupts();
    5ad0:	32 d2       	eint			
    5ad2:	03 43       	nop			

00005ad4 <.Loc.356.1>:
}
    5ad4:	03 43       	nop			
    5ad6:	30 41       	ret			

00005ad8 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    5ad8:	03 43       	nop			
    5ada:	30 41       	ret			

00005adc <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    5adc:	03 43       	nop			
    5ade:	30 41       	ret			

00005ae0 <port_disable>:
/**
 * @brief   Disables all the interrupt sources.
 */
static inline void port_disable(void) {

  _disable_interrupts();
    5ae0:	32 c2       	dint			

00005ae2 <.Loc.380.1>:
  asm volatile("nop");
    5ae2:	03 43       	nop			

00005ae4 <.Loc.381.1>:
}
    5ae4:	03 43       	nop			
    5ae6:	30 41       	ret			

00005ae8 <port_suspend>:
/**
 * @brief   Disables the interrupt sources below kernel-level priority.
 */
static inline void port_suspend(void) {

  _disable_interrupts();
    5ae8:	32 c2       	dint			

00005aea <.Loc.389.1>:
  asm volatile("nop");
    5aea:	03 43       	nop			

00005aec <.Loc.390.1>:
}
    5aec:	03 43       	nop			
    5aee:	30 41       	ret			

00005af0 <_dbg_check_suspend>:
 *
 * @notapi
 */
void _dbg_check_suspend(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5af0:	1c 42 82 51 	mov	&0x5182,r12	;0x5182
    5af4:	0c 93       	cmp	#0,	r12	;r3 As==00
    5af6:	04 20       	jnz	$+10     	;abs 0x5b00

00005af8 <.Loc.79.2>:
    5af8:	1c 42 84 51 	mov	&0x5184,r12	;0x5184
    5afc:	0c 93       	cmp	#0,	r12	;r3 As==00
    5afe:	04 24       	jz	$+10     	;abs 0x5b08

00005b00 <.L19>:
    chSysHalt("SV#2");
    5b00:	3c 40 05 50 	mov	#20485,	r12	;#0x5005
    5b04:	b0 12 ee 5c 	call	#23790		;#0x5cee

00005b08 <.L21>:
  }
}
    5b08:	03 43       	nop			
    5b0a:	30 41       	ret			

00005b0c <_dbg_check_lock>:
 *
 * @notapi
 */
void _dbg_check_lock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5b0c:	1c 42 82 51 	mov	&0x5182,r12	;0x5182
    5b10:	0c 93       	cmp	#0,	r12	;r3 As==00
    5b12:	04 20       	jnz	$+10     	;abs 0x5b1c

00005b14 <.Loc.103.2>:
    5b14:	1c 42 84 51 	mov	&0x5184,r12	;0x5184
    5b18:	0c 93       	cmp	#0,	r12	;r3 As==00
    5b1a:	04 24       	jz	$+10     	;abs 0x5b24

00005b1c <.L27>:
    chSysHalt("SV#4");
    5b1c:	3c 40 0f 50 	mov	#20495,	r12	;#0x500f
    5b20:	b0 12 ee 5c 	call	#23790		;#0x5cee

00005b24 <.L28>:
  }
  _dbg_enter_lock();
    5b24:	92 43 84 51 	mov	#1,	&0x5184	;r3 As==01

00005b28 <.Loc.107.2>:
}
    5b28:	03 43       	nop			
    5b2a:	30 41       	ret			

00005b2c <_dbg_check_unlock>:
 *
 * @notapi
 */
void _dbg_check_unlock(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5b2c:	1c 42 82 51 	mov	&0x5182,r12	;0x5182
    5b30:	0c 93       	cmp	#0,	r12	;r3 As==00
    5b32:	05 20       	jnz	$+12     	;abs 0x5b3e

00005b34 <.Loc.116.2>:
    5b34:	1d 42 84 51 	mov	&0x5184,r13	;0x5184
    5b38:	4c 43       	clr.b	r12		;
    5b3a:	0c 9d       	cmp	r13,	r12	;
    5b3c:	04 38       	jl	$+10     	;abs 0x5b46

00005b3e <.L30>:
    chSysHalt("SV#5");
    5b3e:	3c 40 14 50 	mov	#20500,	r12	;#0x5014
    5b42:	b0 12 ee 5c 	call	#23790		;#0x5cee

00005b46 <.L31>:
  }
  _dbg_leave_lock();
    5b46:	82 43 84 51 	mov	#0,	&0x5184	;r3 As==00

00005b4a <.Loc.120.2>:
}
    5b4a:	03 43       	nop			
    5b4c:	30 41       	ret			

00005b4e <_dbg_check_lock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_lock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5b4e:	1d 42 82 51 	mov	&0x5182,r13	;0x5182
    5b52:	4c 43       	clr.b	r12		;
    5b54:	0c 9d       	cmp	r13,	r12	;
    5b56:	04 34       	jge	$+10     	;abs 0x5b60

00005b58 <.Loc.129.2>:
    5b58:	1c 42 84 51 	mov	&0x5184,r12	;0x5184
    5b5c:	0c 93       	cmp	#0,	r12	;r3 As==00
    5b5e:	04 24       	jz	$+10     	;abs 0x5b68

00005b60 <.L33>:
    chSysHalt("SV#6");
    5b60:	3c 40 19 50 	mov	#20505,	r12	;#0x5019
    5b64:	b0 12 ee 5c 	call	#23790		;#0x5cee

00005b68 <.L34>:
  }
  _dbg_enter_lock();
    5b68:	92 43 84 51 	mov	#1,	&0x5184	;r3 As==01

00005b6c <.Loc.133.2>:
}
    5b6c:	03 43       	nop			
    5b6e:	30 41       	ret			

00005b70 <_dbg_check_unlock_from_isr>:
 *
 * @notapi
 */
void _dbg_check_unlock_from_isr(void) {

  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5b70:	1d 42 82 51 	mov	&0x5182,r13	;0x5182
    5b74:	4c 43       	clr.b	r12		;
    5b76:	0c 9d       	cmp	r13,	r12	;
    5b78:	05 34       	jge	$+12     	;abs 0x5b84

00005b7a <.Loc.142.2>:
    5b7a:	1d 42 84 51 	mov	&0x5184,r13	;0x5184
    5b7e:	4c 43       	clr.b	r12		;
    5b80:	0c 9d       	cmp	r13,	r12	;
    5b82:	04 38       	jl	$+10     	;abs 0x5b8c

00005b84 <.L36>:
    chSysHalt("SV#7");
    5b84:	3c 40 1e 50 	mov	#20510,	r12	;#0x501e
    5b88:	b0 12 ee 5c 	call	#23790		;#0x5cee

00005b8c <.L37>:
  }
  _dbg_leave_lock();
    5b8c:	82 43 84 51 	mov	#0,	&0x5184	;r3 As==00

00005b90 <.Loc.146.2>:
}
    5b90:	03 43       	nop			
    5b92:	30 41       	ret			

00005b94 <_dbg_check_enter_isr>:
 *
 * @notapi
 */
void _dbg_check_enter_isr(void) {

  port_lock_from_isr();
    5b94:	b0 12 d8 5a 	call	#23256		;#0x5ad8

00005b98 <.Loc.156.2>:
  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5b98:	1c 42 82 51 	mov	&0x5182,r12	;0x5182
    5b9c:	0c 93       	cmp	#0,	r12	;r3 As==00
    5b9e:	04 38       	jl	$+10     	;abs 0x5ba8

00005ba0 <.Loc.156.2>:
    5ba0:	1c 42 84 51 	mov	&0x5184,r12	;0x5184
    5ba4:	0c 93       	cmp	#0,	r12	;r3 As==00
    5ba6:	04 24       	jz	$+10     	;abs 0x5bb0

00005ba8 <.L39>:
    chSysHalt("SV#8");
    5ba8:	3c 40 23 50 	mov	#20515,	r12	;#0x5023
    5bac:	b0 12 ee 5c 	call	#23790		;#0x5cee

00005bb0 <.L40>:
  }
  nil.isr_cnt++;
    5bb0:	1c 42 82 51 	mov	&0x5182,r12	;0x5182
    5bb4:	1c 53       	inc	r12		;
    5bb6:	82 4c 82 51 	mov	r12,	&0x5182	;

00005bba <.Loc.160.2>:
  port_unlock_from_isr();
    5bba:	b0 12 dc 5a 	call	#23260		;#0x5adc

00005bbe <.Loc.161.2>:
}
    5bbe:	03 43       	nop			
    5bc0:	30 41       	ret			

00005bc2 <_dbg_check_leave_isr>:
 *
 * @notapi
 */
void _dbg_check_leave_isr(void) {

  port_lock_from_isr();
    5bc2:	b0 12 d8 5a 	call	#23256		;#0x5ad8

00005bc6 <.Loc.171.2>:
  if ((nil.isr_cnt <= (cnt_t)0) || (nil.lock_cnt != (cnt_t)0)) {
    5bc6:	1d 42 82 51 	mov	&0x5182,r13	;0x5182
    5bca:	4c 43       	clr.b	r12		;
    5bcc:	0c 9d       	cmp	r13,	r12	;
    5bce:	04 34       	jge	$+10     	;abs 0x5bd8

00005bd0 <.Loc.171.2>:
    5bd0:	1c 42 84 51 	mov	&0x5184,r12	;0x5184
    5bd4:	0c 93       	cmp	#0,	r12	;r3 As==00
    5bd6:	04 24       	jz	$+10     	;abs 0x5be0

00005bd8 <.L42>:
    chSysHalt("SV#9");
    5bd8:	3c 40 28 50 	mov	#20520,	r12	;#0x5028
    5bdc:	b0 12 ee 5c 	call	#23790		;#0x5cee

00005be0 <.L43>:
  }
  nil.isr_cnt--;
    5be0:	1c 42 82 51 	mov	&0x5182,r12	;0x5182
    5be4:	3c 53       	add	#-1,	r12	;r3 As==11
    5be6:	82 4c 82 51 	mov	r12,	&0x5182	;

00005bea <.Loc.175.2>:
  port_unlock_from_isr();
    5bea:	b0 12 dc 5a 	call	#23260		;#0x5adc

00005bee <.Loc.176.2>:
}
    5bee:	03 43       	nop			
    5bf0:	30 41       	ret			

00005bf2 <chDbgCheckClassI>:
 *
 * @api
 */
void chDbgCheckClassI(void) {

  if ((nil.isr_cnt < (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5bf2:	1c 42 82 51 	mov	&0x5182,r12	;0x5182
    5bf6:	0c 93       	cmp	#0,	r12	;r3 As==00
    5bf8:	05 38       	jl	$+12     	;abs 0x5c04

00005bfa <.Loc.188.2>:
    5bfa:	1d 42 84 51 	mov	&0x5184,r13	;0x5184
    5bfe:	4c 43       	clr.b	r12		;
    5c00:	0c 9d       	cmp	r13,	r12	;
    5c02:	04 38       	jl	$+10     	;abs 0x5c0c

00005c04 <.L45>:
    chSysHalt("SV#10");
    5c04:	3c 40 2d 50 	mov	#20525,	r12	;#0x502d
    5c08:	b0 12 ee 5c 	call	#23790		;#0x5cee

00005c0c <.L47>:
  }
}
    5c0c:	03 43       	nop			
    5c0e:	30 41       	ret			

00005c10 <chDbgCheckClassS>:
 *
 * @api
 */
void chDbgCheckClassS(void) {

  if ((nil.isr_cnt != (cnt_t)0) || (nil.lock_cnt <= (cnt_t)0)) {
    5c10:	1c 42 82 51 	mov	&0x5182,r12	;0x5182
    5c14:	0c 93       	cmp	#0,	r12	;r3 As==00
    5c16:	05 20       	jnz	$+12     	;abs 0x5c22

00005c18 <.Loc.203.2>:
    5c18:	1d 42 84 51 	mov	&0x5184,r13	;0x5184
    5c1c:	4c 43       	clr.b	r12		;
    5c1e:	0c 9d       	cmp	r13,	r12	;
    5c20:	04 38       	jl	$+10     	;abs 0x5c2a

00005c22 <.L49>:
    chSysHalt("SV#11");
    5c22:	3c 40 33 50 	mov	#20531,	r12	;#0x5033
    5c26:	b0 12 ee 5c 	call	#23790		;#0x5cee

00005c2a <.L51>:
  }
}
    5c2a:	03 43       	nop			
    5c2c:	30 41       	ret			

00005c2e <chSysInit>:
 *          zeroed by the runtime environment. If this is not the case then
 *          make sure to clear it before calling this function.
 *
 * @special
 */
void chSysInit(void) {
    5c2e:	21 82       	sub	#4,	r1	;r2 As==10

00005c30 <.LCFI3>:
  thread_t *tp;
  const thread_config_t *tcp;

#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.isr_cnt  = (cnt_t)0;
    5c30:	82 43 82 51 	mov	#0,	&0x5182	;r3 As==00

00005c34 <.Loc.226.2>:
  nil.lock_cnt = (cnt_t)0;
    5c34:	82 43 84 51 	mov	#0,	&0x5184	;r3 As==00

00005c38 <.Loc.233.2>:

  /* System initialization hook.*/
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
    5c38:	b1 40 88 51 	mov	#20872,	2(r1)	;#0x5188
    5c3c:	02 00 

00005c3e <.Loc.234.2>:
  tcp = nil_thd_configs;
    5c3e:	b1 40 0c 51 	mov	#20748,	0(r1)	;#0x510c
    5c42:	00 00 

00005c44 <.Loc.235.2>:
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    5c44:	2d 3c       	jmp	$+92     	;abs 0x5ca0

00005c46 <.L54>:
#if CH_DBG_ENABLE_STACK_CHECK
    tp->wabase  = (stkalign_t *)tcp->wbase;
    5c46:	2c 41       	mov	@r1,	r12	;
    5c48:	2d 4c       	mov	@r12,	r13	;
    5c4a:	1c 41 02 00 	mov	2(r1),	r12	;
    5c4e:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00005c52 <.Loc.241.2>:
#endif

    /* Port dependent thread initialization.*/
    PORT_SETUP_CONTEXT(tp, tcp->wbase, tcp->wend, tcp->funcp, tcp->arg);
    5c52:	2c 41       	mov	@r1,	r12	;
    5c54:	1c 4c 02 00 	mov	2(r12),	r12	;
    5c58:	0d 4c       	mov	r12,	r13	;
    5c5a:	3d 50 f0 ff 	add	#65520,	r13	;#0xfff0
    5c5e:	1c 41 02 00 	mov	2(r1),	r12	;
    5c62:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5c66:	1c 41 02 00 	mov	2(r1),	r12	;
    5c6a:	2c 4c       	mov	@r12,	r12	;
    5c6c:	2d 41       	mov	@r1,	r13	;
    5c6e:	1d 4d 06 00 	mov	6(r13),	r13	;
    5c72:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5c76:	1c 41 02 00 	mov	2(r1),	r12	;
    5c7a:	2c 4c       	mov	@r12,	r12	;
    5c7c:	2d 41       	mov	@r1,	r13	;
    5c7e:	1d 4d 08 00 	mov	8(r13),	r13	;
    5c82:	8c 4d 02 00 	mov	r13,	2(r12)	;
    5c86:	1c 41 02 00 	mov	2(r1),	r12	;
    5c8a:	2c 4c       	mov	@r12,	r12	;
    5c8c:	3d 40 78 60 	mov	#24696,	r13	;#0x6078
    5c90:	8c 4d 0e 00 	mov	r13,	14(r12)	; 0x000e

00005c94 <.Loc.246.2>:

    /* Initialization hook.*/
    CH_CFG_THREAD_EXT_INIT_HOOK(tp);

    tp++;
    5c94:	b1 50 0c 00 	add	#12,	2(r1)	;#0x000c
    5c98:	02 00 

00005c9a <.Loc.247.2>:
    tcp++;
    5c9a:	b1 50 0a 00 	add	#10,	0(r1)	;#0x000a
    5c9e:	00 00 

00005ca0 <.L53>:
  CH_CFG_SYSTEM_INIT_HOOK();

  /* Iterates through the list of defined threads.*/
  tp = &nil.threads[0];
  tcp = nil_thd_configs;
  while (tp < &nil.threads[CH_CFG_NUM_THREADS]) {
    5ca0:	b1 90 94 51 	cmp	#20884,	2(r1)	;#0x5194
    5ca4:	02 00 
    5ca6:	cf 2b       	jnc	$-96     	;abs 0x5c46

00005ca8 <.Loc.253.2>:
  }

#if CH_DBG_ENABLE_STACK_CHECK
  /* The idle thread is a special case because its stack is set up by the
     runtime environment.*/
  tp->wabase  = THD_IDLE_BASE;
    5ca8:	1c 41 02 00 	mov	2(r1),	r12	;
    5cac:	bc 40 00 44 	mov	#17408,	10(r12)	;#0x4400, 0x000a
    5cb0:	0a 00 

00005cb2 <.Loc.258.2>:
#endif

  /* Interrupts partially enabled. It is equivalent to entering the
     kernel critical zone.*/
  chSysSuspend();
    5cb2:	b0 12 e8 5a 	call	#23272		;#0x5ae8
    5cb6:	b0 12 f0 5a 	call	#23280		;#0x5af0

00005cba <.Loc.260.2>:
#if CH_DBG_SYSTEM_STATE_CHECK == TRUE
  nil.lock_cnt = (cnt_t)1;
    5cba:	92 43 84 51 	mov	#1,	&0x5184	;r3 As==01

00005cbe <.Loc.265.2>:
#endif

  /* Heap initialization, if enabled.*/
#if CH_CFG_USE_HEAP == TRUE
  _heap_init();
    5cbe:	b0 12 4a 60 	call	#24650		;#0x604a

00005cc2 <.Loc.270.2>:
#endif

  /* Port layer initialization last because it depend on some of the
     initializations performed before.*/
  port_init();
    5cc2:	b0 12 c2 5a 	call	#23234		;#0x5ac2

00005cc6 <.Loc.274.2>:

  /* Runs the highest priority thread, the current one becomes the idle
     thread.*/
  nil.current = nil.next = nil.threads;
    5cc6:	b2 40 88 51 	mov	#20872,	&0x517e	;#0x5188
    5cca:	7e 51 
    5ccc:	1c 42 7e 51 	mov	&0x517e,r12	;0x517e
    5cd0:	82 4c 7c 51 	mov	r12,	&0x517c	;

00005cd4 <.Loc.275.2>:
  port_switch(nil.current, tp);
    5cd4:	1c 42 7c 51 	mov	&0x517c,r12	;0x517c
    5cd8:	1d 41 02 00 	mov	2(r1),	r13	;
    5cdc:	b0 12 6a 60 	call	#24682		;#0x606a

00005ce0 <.Loc.276.2>:
  chSysUnlock();
    5ce0:	b0 12 2c 5b 	call	#23340		;#0x5b2c
    5ce4:	b0 12 ce 5a 	call	#23246		;#0x5ace

00005ce8 <.Loc.277.2>:
}
    5ce8:	03 43       	nop			
    5cea:	21 52       	add	#4,	r1	;r2 As==10
    5cec:	30 41       	ret			

00005cee <chSysHalt>:
 *
 * @param[in] reason        pointer to an error string
 *
 * @special
 */
void chSysHalt(const char *reason) {
    5cee:	21 83       	decd	r1		;

00005cf0 <L0>:
    5cf0:	81 4c 00 00 	mov	r12,	0(r1)	;

00005cf4 <.Loc.293.2>:

  port_disable();
    5cf4:	b0 12 e0 5a 	call	#23264		;#0x5ae0

00005cf8 <.Loc.296.2>:

#if NIL_DBG_ENABLED
  nil.dbg_panic_msg = reason;
    5cf8:	a2 41 86 51 	mov	@r1,	&0x5186	;

00005cfc <.L56>:
#endif

  CH_CFG_SYSTEM_HALT_HOOK(reason);

  /* Harmless infinite loop.*/
  while (true) {
    5cfc:	ff 3f       	jmp	$+0      	;abs 0x5cfc

00005cfe <chSysTimerHandlerI>:
    5cfe:	21 83       	decd	r1		;

00005d00 <L0>:
 *
 * @iclass
 */
void chSysTimerHandlerI(void) {

  chDbgCheckClassI();
    5d00:	b0 12 f2 5b 	call	#23538		;#0x5bf2

00005d04 <.Loc.320.2>:

#if CH_CFG_ST_TIMEDELTA == 0
  thread_t *tp = &nil.threads[0];
    5d04:	b1 40 88 51 	mov	#20872,	0(r1)	;#0x5188
    5d08:	00 00 

00005d0a <.Loc.321.2>:
  nil.systime++;
    5d0a:	1c 42 80 51 	mov	&0x5180,r12	;0x5180
    5d0e:	1c 53       	inc	r12		;
    5d10:	82 4c 80 51 	mov	r12,	&0x5180	;

00005d14 <.L61>:
  do {
    /* Is the thread in a wait state with timeout?.*/
    if (tp->timeout > (systime_t)0) {
    5d14:	2c 41       	mov	@r1,	r12	;
    5d16:	1c 4c 06 00 	mov	6(r12),	r12	;
    5d1a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d1c:	25 24       	jz	$+76     	;abs 0x5d68

00005d1e <.Loc.329.2>:

      chDbgAssert(!NIL_THD_IS_READY(tp), "is ready");

     /* Did the timer reach zero?*/
      if (--tp->timeout == (systime_t)0) {
    5d1e:	2c 41       	mov	@r1,	r12	;
    5d20:	1c 4c 06 00 	mov	6(r12),	r12	;
    5d24:	3c 53       	add	#-1,	r12	;r3 As==11
    5d26:	2d 41       	mov	@r1,	r13	;
    5d28:	8d 4c 06 00 	mov	r12,	6(r13)	;
    5d2c:	0c 93       	cmp	#0,	r12	;r3 As==00
    5d2e:	1c 20       	jnz	$+58     	;abs 0x5d68

00005d30 <.Loc.333.2>:
        /* Timeout on semaphores requires a special handling because the
           semaphore counter must be incremented.*/
        /*lint -save -e9013 [15.7] There is no else because it is not needed.*/
        if (NIL_THD_IS_WTSEM(tp)) {
    5d30:	2c 41       	mov	@r1,	r12	;
    5d32:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    5d36:	7c 90 03 00 	cmp.b	#3,	r12	;
    5d3a:	08 20       	jnz	$+18     	;abs 0x5d4c

00005d3c <.Loc.334.2>:
          tp->u1.semp->cnt++;
    5d3c:	2c 41       	mov	@r1,	r12	;
    5d3e:	1c 4c 04 00 	mov	4(r12),	r12	;
    5d42:	2d 4c       	mov	@r12,	r13	;
    5d44:	1d 53       	inc	r13		;
    5d46:	8c 4d 00 00 	mov	r13,	0(r12)	;
    5d4a:	0a 3c       	jmp	$+22     	;abs 0x5d60

00005d4c <.L59>:
        }
        else if (NIL_THD_IS_SUSP(tp)) {
    5d4c:	2c 41       	mov	@r1,	r12	;
    5d4e:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    5d52:	6c 93       	cmp.b	#2,	r12	;r3 As==10
    5d54:	05 20       	jnz	$+12     	;abs 0x5d60

00005d56 <.Loc.337.2>:
          *tp->u1.trp = NULL;
    5d56:	2c 41       	mov	@r1,	r12	;
    5d58:	1c 4c 04 00 	mov	4(r12),	r12	;
    5d5c:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00005d60 <.L60>:
        }
        /*lint -restore*/
        (void) chSchReadyI(tp, MSG_TIMEOUT);
    5d60:	3d 43       	mov	#-1,	r13	;r3 As==11
    5d62:	2c 41       	mov	@r1,	r12	;
    5d64:	b0 12 8c 5d 	call	#23948		;#0x5d8c

00005d68 <.L58>:
      }
    }
    /* Lock released in order to give a preemption chance on those
       architectures supporting IRQ preemption.*/
    chSysUnlockFromISR();
    5d68:	b0 12 70 5b 	call	#23408		;#0x5b70
    5d6c:	b0 12 dc 5a 	call	#23260		;#0x5adc

00005d70 <.Loc.346.2>:
    tp++;
    5d70:	b1 50 0c 00 	add	#12,	0(r1)	;#0x000c
    5d74:	00 00 

00005d76 <.Loc.347.2>:
    chSysLockFromISR();
    5d76:	b0 12 d8 5a 	call	#23256		;#0x5ad8
    5d7a:	b0 12 4e 5b 	call	#23374		;#0x5b4e

00005d7e <.Loc.348.2>:
  } while (tp < &nil.threads[CH_CFG_NUM_THREADS]);
    5d7e:	b1 90 94 51 	cmp	#20884,	0(r1)	;#0x5194
    5d82:	00 00 
    5d84:	c7 2b       	jnc	$-112    	;abs 0x5d14

00005d86 <.Loc.402.2>:
  else {
    /* No tick event needed.*/
    port_timer_stop_alarm();
  }
#endif
}
    5d86:	03 43       	nop			
    5d88:	21 53       	incd	r1		;
    5d8a:	30 41       	ret			

00005d8c <chSchReadyI>:
 * @param[in] tp        pointer to the @p thread_t object
 * @param[in] msg       the wakeup message
 *
 * @return              The same reference passed as parameter.
 */
thread_t *chSchReadyI(thread_t *tp, msg_t msg) {
    5d8c:	21 82       	sub	#4,	r1	;r2 As==10

00005d8e <L0>:
    5d8e:	81 4c 02 00 	mov	r12,	2(r1)	;
    5d92:	81 4d 00 00 	mov	r13,	0(r1)	;

00005d96 <.Loc.535.2>:

  chDbgCheckClassI();
    5d96:	b0 12 f2 5b 	call	#23538		;#0x5bf2

00005d9a <.Loc.540.2>:
  chDbgCheck((tp >= nil.threads) && (tp < &nil.threads[CH_CFG_NUM_THREADS]));
  chDbgAssert(!NIL_THD_IS_READY(tp), "already ready");
  chDbgAssert(nil.next <= nil.current, "priority ordering");

  tp->u1.msg = msg;
    5d9a:	1c 41 02 00 	mov	2(r1),	r12	;
    5d9e:	ac 41 04 00 	mov	@r1,	4(r12)	;

00005da2 <.Loc.541.2>:
  tp->state = NIL_STATE_READY;
    5da2:	1c 41 02 00 	mov	2(r1),	r12	;
    5da6:	cc 43 02 00 	mov.b	#0,	2(r12)	;r3 As==00

00005daa <.Loc.542.2>:
  tp->timeout = (systime_t)0;
    5daa:	1c 41 02 00 	mov	2(r1),	r12	;
    5dae:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00005db2 <.Loc.543.2>:
  if (tp < nil.next) {
    5db2:	1c 42 7e 51 	mov	&0x517e,r12	;0x517e
    5db6:	81 9c 02 00 	cmp	r12,	2(r1)	;
    5dba:	03 2c       	jc	$+8      	;abs 0x5dc2

00005dbc <.Loc.544.2>:
    nil.next = tp;
    5dbc:	92 41 02 00 	mov	2(r1),	&0x517e	;
    5dc0:	7e 51 

00005dc2 <.L77>:
  }
  return tp;
    5dc2:	1c 41 02 00 	mov	2(r1),	r12	;

00005dc6 <.Loc.547.2>:
}
    5dc6:	21 52       	add	#4,	r1	;r2 As==10
    5dc8:	30 41       	ret			

00005dca <chSchIsPreemptionRequired>:
 *
 * @special
 */
bool chSchIsPreemptionRequired(void) {

  return chSchIsRescRequiredI();
    5dca:	1d 42 7c 51 	mov	&0x517c,r13	;0x517c
    5dce:	1c 42 7e 51 	mov	&0x517e,r12	;0x517e
    5dd2:	0c ed       	xor	r13,	r12	;
    5dd4:	0d 43       	clr	r13		;
    5dd6:	0d 8c       	sub	r12,	r13	;
    5dd8:	0c dd       	bis	r13,	r12	;
    5dda:	5c 03       	rrum	#1,	r12	;
    5ddc:	4d 18 0c 11 	rpt #14 { rrax.w	r12		;
    5de0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00005de4 <.Loc.565.2>:
}
    5de4:	30 41       	ret			

00005de6 <chSchDoReschedule>:
 * @note    Not a user function, it is meant to be invoked by the scheduler
 *          itself or from within the port layer.
 *
 * @special
 */
void chSchDoReschedule(void) {
    5de6:	21 83       	decd	r1		;

00005de8 <.LCFI9>:
  thread_t *otp = nil.current;
    5de8:	91 42 7c 51 	mov	&0x517c,0(r1)	;0x517c
    5dec:	00 00 

00005dee <.Loc.577.2>:

  nil.current = nil.next;
    5dee:	1c 42 7e 51 	mov	&0x517e,r12	;0x517e
    5df2:	82 4c 7c 51 	mov	r12,	&0x517c	;

00005df6 <.Loc.581.2>:
  if (otp == &nil.threads[CH_CFG_NUM_THREADS]) {
    CH_CFG_IDLE_LEAVE_HOOK();
  }
  port_switch(nil.next, otp);
    5df6:	1c 42 7e 51 	mov	&0x517e,r12	;0x517e
    5dfa:	2d 41       	mov	@r1,	r13	;
    5dfc:	b0 12 6a 60 	call	#24682		;#0x606a

00005e00 <.Loc.582.2>:
}
    5e00:	03 43       	nop			
    5e02:	21 53       	incd	r1		;
    5e04:	30 41       	ret			

00005e06 <chSchGoSleepTimeoutS>:
 * @return              The wakeup message.
 * @retval NIL_MSG_TMO  if a timeout occurred.
 *
 * @sclass
 */
msg_t chSchGoSleepTimeoutS(tstate_t newstate, systime_t timeout) {
    5e06:	31 82       	sub	#8,	r1	;r2 As==11

00005e08 <.LCFI10>:
    5e08:	c1 4c 03 00 	mov.b	r12,	3(r1)	;
    5e0c:	81 4d 00 00 	mov	r13,	0(r1)	;

00005e10 <.Loc.616.2>:
  thread_t *ntp, *otp = nil.current;
    5e10:	91 42 7c 51 	mov	&0x517c,4(r1)	;0x517c
    5e14:	04 00 

00005e16 <.Loc.618.2>:

  chDbgCheckClassS();
    5e16:	b0 12 10 5c 	call	#23568		;#0x5c10

00005e1a <.Loc.624.2>:

  chDbgAssert(otp != &nil.threads[CH_CFG_NUM_THREADS],
               "idle cannot sleep");

  /* Storing the wait object for the current thread.*/
  otp->state = newstate;
    5e1a:	1c 41 04 00 	mov	4(r1),	r12	;
    5e1e:	dc 41 03 00 	mov.b	3(r1),	2(r12)	;
    5e22:	02 00 

00005e24 <.Loc.659.2>:
    otp->timeout = abstime - nil.lasttime;
  }
#else

  /* Timeout settings.*/
  otp->timeout = timeout;
    5e24:	1c 41 04 00 	mov	4(r1),	r12	;
    5e28:	ac 41 06 00 	mov	@r1,	6(r12)	;

00005e2c <.Loc.663.2>:
#endif

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
    5e2c:	b1 40 88 51 	mov	#20872,	6(r1)	;#0x5188
    5e30:	06 00 

00005e32 <.L88>:
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    5e32:	1c 41 06 00 	mov	6(r1),	r12	;
    5e36:	5c 4c 02 00 	mov.b	2(r12),	r12	;
    5e3a:	0c 93       	cmp	#0,	r12	;r3 As==00
    5e3c:	12 20       	jnz	$+38     	;abs 0x5e62

00005e3e <.Loc.667.2>:
      nil.current = nil.next = ntp;
    5e3e:	92 41 06 00 	mov	6(r1),	&0x517e	;
    5e42:	7e 51 
    5e44:	1c 42 7e 51 	mov	&0x517e,r12	;0x517e
    5e48:	82 4c 7c 51 	mov	r12,	&0x517c	;

00005e4c <.Loc.671.2>:
      if (ntp == &nil.threads[CH_CFG_NUM_THREADS]) {
        CH_CFG_IDLE_ENTER_HOOK();
      }
      port_switch(ntp, otp);
    5e4c:	1d 41 04 00 	mov	4(r1),	r13	;
    5e50:	1c 41 06 00 	mov	6(r1),	r12	;
    5e54:	b0 12 6a 60 	call	#24682		;#0x606a

00005e58 <.Loc.672.2>:
      return nil.current->u1.msg;
    5e58:	1c 42 7c 51 	mov	&0x517c,r12	;0x517c
    5e5c:	1c 4c 04 00 	mov	4(r12),	r12	;
    5e60:	04 3c       	jmp	$+10     	;abs 0x5e6a

00005e62 <.L86>:
    }

    /* Points to the next thread in lowering priority order.*/
    ntp++;
    5e62:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    5e66:	06 00 

00005e68 <.Loc.666.2>:

  /* Scanning the whole threads array.*/
  ntp = nil.threads;
  while (true) {
    /* Is this thread ready to execute?*/
    if (NIL_THD_IS_READY(ntp)) {
    5e68:	e4 3f       	jmp	$-54     	;abs 0x5e32

00005e6a <.L89>:
    /* Points to the next thread in lowering priority order.*/
    ntp++;
    chDbgAssert(ntp <= &nil.threads[CH_CFG_NUM_THREADS],
                "pointer out of range");
  }
}
    5e6a:	31 52       	add	#8,	r1	;r2 As==11
    5e6c:	30 41       	ret			

00005e6e <chThdSuspendTimeoutS>:
 *                      .
 * @return              The wake up message.
 *
 * @sclass
 */
msg_t chThdSuspendTimeoutS(thread_reference_t *trp, systime_t timeout) {
    5e6e:	21 82       	sub	#4,	r1	;r2 As==10

00005e70 <.LCFI11>:
    5e70:	81 4c 02 00 	Address 0x0000000000005e72 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00005e72 <L0>:
    5e72:	02 00       	mova	@r0,	r2	;
    5e74:	81 4d 00 00 	mov	r13,	0(r1)	;

00005e78 <.Loc.700.2>:

  chDbgAssert(*trp == NULL, "not NULL");

  *trp = nil.current;
    5e78:	1d 42 7c 51 	mov	&0x517c,r13	;0x517c
    5e7c:	1c 41 02 00 	mov	2(r1),	r12	;
    5e80:	8c 4d 00 00 	mov	r13,	0(r12)	;

00005e84 <.Loc.701.2>:
  nil.current->u1.trp = trp;
    5e84:	1c 42 7c 51 	mov	&0x517c,r12	;0x517c
    5e88:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    5e8c:	04 00 

00005e8e <.Loc.702.2>:
  return chSchGoSleepTimeoutS(NIL_STATE_SUSP, timeout);
    5e8e:	2d 41       	mov	@r1,	r13	;
    5e90:	6c 43       	mov.b	#2,	r12	;r3 As==10
    5e92:	b0 12 06 5e 	call	#24070		;#0x5e06

00005e96 <.Loc.703.2>:
}
    5e96:	21 52       	add	#4,	r1	;r2 As==10
    5e98:	30 41       	ret			

00005e9a <chThdResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void chThdResumeI(thread_reference_t *trp, msg_t msg) {
    5e9a:	31 80 06 00 	sub	#6,	r1	;

00005e9e <.LCFI12>:
    5e9e:	81 4c 02 00 	mov	r12,	2(r1)	;
    5ea2:	81 4d 00 00 	mov	r13,	0(r1)	;

00005ea6 <.Loc.717.2>:

  if (*trp != NULL) {
    5ea6:	1c 41 02 00 	mov	2(r1),	r12	;
    5eaa:	2c 4c       	mov	@r12,	r12	;
    5eac:	0c 93       	cmp	#0,	r12	;r3 As==00
    5eae:	0d 24       	jz	$+28     	;abs 0x5eca

00005eb0 <.LBB4>:
    thread_reference_t tr = *trp;
    5eb0:	1c 41 02 00 	mov	2(r1),	r12	;
    5eb4:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00005eb8 <.Loc.722.2>:

    chDbgAssert(NIL_THD_IS_SUSP(tr), "not suspended");

    *trp = NULL;
    5eb8:	1c 41 02 00 	mov	2(r1),	r12	;
    5ebc:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00005ec0 <.Loc.723.2>:
    (void) chSchReadyI(tr, msg);
    5ec0:	2d 41       	mov	@r1,	r13	;
    5ec2:	1c 41 04 00 	mov	4(r1),	r12	;
    5ec6:	b0 12 8c 5d 	call	#23948		;#0x5d8c

00005eca <.L94>:
  }
}
    5eca:	03 43       	nop			
    5ecc:	31 50 06 00 	add	#6,	r1	;
    5ed0:	30 41       	ret			

00005ed2 <chThdSleep>:
 *
 * @param[in] timeout   the delay in system ticks
 *
 * @api
 */
void chThdSleep(systime_t timeout) {
    5ed2:	21 83       	decd	r1		;

00005ed4 <.LCFI13>:
    5ed4:	81 4c 00 00 	mov	r12,	0(r1)	;

00005ed8 <.Loc.736.2>:

  chSysLock();
    5ed8:	b0 12 c6 5a 	call	#23238		;#0x5ac6
    5edc:	b0 12 0c 5b 	call	#23308		;#0x5b0c

00005ee0 <.Loc.737.2>:
  chThdSleepS(timeout);
    5ee0:	2d 41       	mov	@r1,	r13	;
    5ee2:	5c 43       	mov.b	#1,	r12	;r3 As==01
    5ee4:	b0 12 06 5e 	call	#24070		;#0x5e06

00005ee8 <.Loc.738.2>:
  chSysUnlock();
    5ee8:	b0 12 2c 5b 	call	#23340		;#0x5b2c
    5eec:	b0 12 ce 5a 	call	#23246		;#0x5ace

00005ef0 <.Loc.739.2>:
}
    5ef0:	03 43       	nop			
    5ef2:	21 53       	incd	r1		;
    5ef4:	30 41       	ret			

00005ef6 <chSemWaitTimeoutS>:
 * @retval NIL_MSG_TMO  if the semaphore has not been signaled or reset within
 *                      the specified timeout.
 *
 * @sclass
 */
msg_t chSemWaitTimeoutS(semaphore_t *sp, systime_t timeout) {
    5ef6:	31 80 06 00 	sub	#6,	r1	;

00005efa <.LCFI16>:
    5efa:	81 4c 02 00 	mov	r12,	2(r1)	;
    5efe:	81 4d 00 00 	mov	r13,	0(r1)	;

00005f02 <.Loc.807.2>:

  chDbgCheckClassS();
    5f02:	b0 12 10 5c 	call	#23568		;#0x5c10

00005f06 <.Loc.812.2>:
  chDbgCheck(sp != NULL);

  /* Note, the semaphore counter is a volatile variable so accesses are
     manually optimized.*/
  cnt_t cnt = sp->cnt;
    5f06:	1c 41 02 00 	mov	2(r1),	r12	;
    5f0a:	a1 4c 04 00 	mov	@r12,	4(r1)	;

00005f0e <.Loc.813.2>:
  if (cnt <= (cnt_t)0) {
    5f0e:	4c 43       	clr.b	r12		;
    5f10:	1c 91 04 00 	cmp	4(r1),	r12	;
    5f14:	17 38       	jl	$+48     	;abs 0x5f44

00005f16 <.Loc.814.2>:
    if (TIME_IMMEDIATE == timeout) {
    5f16:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    5f1a:	02 20       	jnz	$+6      	;abs 0x5f20

00005f1c <.Loc.815.2>:
      return MSG_TIMEOUT;
    5f1c:	3c 43       	mov	#-1,	r12	;r3 As==11
    5f1e:	1a 3c       	jmp	$+54     	;abs 0x5f54

00005f20 <.L101>:
    }
    sp->cnt = cnt - (cnt_t)1;
    5f20:	1d 41 04 00 	mov	4(r1),	r13	;
    5f24:	3d 53       	add	#-1,	r13	;r3 As==11
    5f26:	1c 41 02 00 	mov	2(r1),	r12	;
    5f2a:	8c 4d 00 00 	mov	r13,	0(r12)	;

00005f2e <.Loc.818.2>:
    nil.current->u1.semp = sp;
    5f2e:	1c 42 7c 51 	mov	&0x517c,r12	;0x517c
    5f32:	9c 41 02 00 	mov	2(r1),	4(r12)	;
    5f36:	04 00 

00005f38 <.Loc.819.2>:
    return chSchGoSleepTimeoutS(NIL_STATE_WTSEM, timeout);
    5f38:	2d 41       	mov	@r1,	r13	;
    5f3a:	7c 40 03 00 	mov.b	#3,	r12	;
    5f3e:	b0 12 06 5e 	call	#24070		;#0x5e06
    5f42:	08 3c       	jmp	$+18     	;abs 0x5f54

00005f44 <.L100>:
  }
  sp->cnt = cnt - (cnt_t)1;
    5f44:	1d 41 04 00 	mov	4(r1),	r13	;
    5f48:	3d 53       	add	#-1,	r13	;r3 As==11
    5f4a:	1c 41 02 00 	mov	2(r1),	r12	;
    5f4e:	8c 4d 00 00 	mov	r13,	0(r12)	;

00005f52 <.Loc.822.2>:
  return MSG_OK;
    5f52:	4c 43       	clr.b	r12		;

00005f54 <.L102>:
}
    5f54:	31 50 06 00 	add	#6,	r1	;
    5f58:	30 41       	ret			

00005f5a <chSemSignalI>:
 *
 * @param[in] sp    pointer to a @p semaphore_t structure
 *
 * @iclass
 */
void chSemSignalI(semaphore_t *sp) {
    5f5a:	21 82       	sub	#4,	r1	;r2 As==10

00005f5c <.LCFI18>:
    5f5c:	81 4c 00 00 	Address 0x0000000000005f5e is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00005f5e <L0>:
	...

00005f60 <.Loc.857.2>:

  chDbgCheckClassI();
    5f60:	b0 12 f2 5b 	call	#23538		;#0x5bf2

00005f64 <.Loc.860.2>:
  chDbgCheck(sp != NULL);

  if (++sp->cnt <= (cnt_t)0) {
    5f64:	2c 41       	mov	@r1,	r12	;
    5f66:	2c 4c       	mov	@r12,	r12	;
    5f68:	1c 53       	inc	r12		;
    5f6a:	2d 41       	mov	@r1,	r13	;
    5f6c:	8d 4c 00 00 	mov	r12,	0(r13)	;
    5f70:	4d 43       	clr.b	r13		;
    5f72:	0d 9c       	cmp	r12,	r13	;
    5f74:	13 38       	jl	$+40     	;abs 0x5f9c

00005f76 <.LBB5>:
    thread_reference_t tr = nil.threads;
    5f76:	b1 40 88 51 	mov	#20872,	2(r1)	;#0x5188
    5f7a:	02 00 

00005f7c <.L107>:
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    5f7c:	1c 41 02 00 	mov	2(r1),	r12	;
    5f80:	1c 4c 04 00 	mov	4(r12),	r12	;
    5f84:	2c 91       	cmp	@r1,	r12	;
    5f86:	06 20       	jnz	$+14     	;abs 0x5f94

00005f88 <.Loc.868.2>:

        chDbgAssert(NIL_THD_IS_WTSEM(tr), "not waiting");

        (void) chSchReadyI(tr, MSG_OK);
    5f88:	4d 43       	clr.b	r13		;
    5f8a:	1c 41 02 00 	mov	2(r1),	r12	;
    5f8e:	b0 12 8c 5d 	call	#23948		;#0x5d8c

00005f92 <.Loc.869.2>:
        return;
    5f92:	04 3c       	jmp	$+10     	;abs 0x5f9c

00005f94 <.L106>:
      }
      tr++;
    5f94:	b1 50 0c 00 	add	#12,	2(r1)	;#0x000c
    5f98:	02 00 

00005f9a <.Loc.864.2>:

  if (++sp->cnt <= (cnt_t)0) {
    thread_reference_t tr = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tr->u1.semp == sp) {
    5f9a:	f0 3f       	jmp	$-30     	;abs 0x5f7c

00005f9c <.L104>:

      chDbgAssert(tr < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    5f9c:	21 52       	add	#4,	r1	;r2 As==10
    5f9e:	30 41       	ret			

00005fa0 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    5fa0:	32 c2       	dint			

00005fa2 <.Loc.347.1>:
  asm volatile("nop");
    5fa2:	03 43       	nop			

00005fa4 <L0>:
}
    5fa4:	03 43       	nop			
    5fa6:	30 41       	ret			

00005fa8 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    5fa8:	03 43       	nop			

00005faa <.Loc.355.1>:
  _enable_interrupts();
    5faa:	32 d2       	eint			
    5fac:	03 43       	nop			

00005fae <.Loc.356.1>:
}
    5fae:	03 43       	nop			
    5fb0:	30 41       	ret			

00005fb2 <chCoreAllocAlignedI>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @iclass
 */
void *chCoreAllocAlignedI(size_t size, unsigned align) {
    5fb2:	31 80 06 00 	sub	#6,	r1	;

00005fb6 <.LCFI0>:
    5fb6:	81 4c 02 00 	mov	r12,	2(r1)	;
    5fba:	81 4d 00 00 	mov	r13,	0(r1)	;

00005fbe <.Loc.111.2>:
  uint8_t *p;

  chDbgCheckClassI();
    5fbe:	b0 12 f2 5b 	call	#23538		;#0x5bf2

00005fc2 <.Loc.114.2>:
  chDbgCheck(MEM_IS_VALID_ALIGNMENT(align));

  size = MEM_ALIGN_NEXT(size, align);
    5fc2:	2c 41       	mov	@r1,	r12	;
    5fc4:	1c 51 02 00 	add	2(r1),	r12	;
    5fc8:	0d 4c       	mov	r12,	r13	;
    5fca:	3d 53       	add	#-1,	r13	;r3 As==11
    5fcc:	4c 43       	clr.b	r12		;
    5fce:	2c 81       	sub	@r1,	r12	;
    5fd0:	0e 4d       	mov	r13,	r14	;
    5fd2:	0e fc       	and	r12,	r14	;
    5fd4:	81 4e 02 00 	mov	r14,	2(r1)	;

00005fd8 <.Loc.115.2>:
  p = (uint8_t *)MEM_ALIGN_NEXT(nextmem, align);
    5fd8:	1c 42 a0 51 	mov	&0x51a0,r12	;0x51a0
    5fdc:	2c 51       	add	@r1,	r12	;
    5fde:	0d 4c       	mov	r12,	r13	;
    5fe0:	3d 53       	add	#-1,	r13	;r3 As==11
    5fe2:	4c 43       	clr.b	r12		;
    5fe4:	2c 81       	sub	@r1,	r12	;
    5fe6:	0c fd       	and	r13,	r12	;
    5fe8:	81 4c 04 00 	mov	r12,	4(r1)	;

00005fec <.Loc.117.2>:

  if (((size_t)endmem - (size_t)p) < size) {
    5fec:	1c 42 a2 51 	mov	&0x51a2,r12	;0x51a2
    5ff0:	1d 41 04 00 	mov	4(r1),	r13	;
    5ff4:	0c 8d       	sub	r13,	r12	;
    5ff6:	1c 91 02 00 	cmp	2(r1),	r12	;
    5ffa:	02 2c       	jc	$+6      	;abs 0x6000

00005ffc <.Loc.118.2>:
    return NULL;
    5ffc:	4c 43       	clr.b	r12		;
    5ffe:	08 3c       	jmp	$+18     	;abs 0x6010

00006000 <.L5>:
  }
  nextmem = p + size;
    6000:	1c 41 04 00 	mov	4(r1),	r12	;
    6004:	1c 51 02 00 	add	2(r1),	r12	;
    6008:	82 4c a0 51 	mov	r12,	&0x51a0	;

0000600c <.Loc.122.2>:

  return p;
    600c:	1c 41 04 00 	mov	4(r1),	r12	;

00006010 <.L6>:
}
    6010:	31 50 06 00 	add	#6,	r1	;
    6014:	30 41       	ret			

00006016 <chCoreAllocAligned>:
 * @return              A pointer to the allocated memory block.
 * @retval NULL         allocation failed, core memory exhausted.
 *
 * @api
 */
void *chCoreAllocAligned(size_t size, unsigned align) {
    6016:	31 80 06 00 	Address 0x0000000000006018 is out of bounds.
sub	#65535,	r1	;#0xffff

00006018 <L0>:
    6018:	06 00       	mova	@r0,	r6	;

0000601a <.LCFI1>:
    601a:	81 4c 02 00 	mov	r12,	2(r1)	;
    601e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006022 <.Loc.140.2>:
  void *p;

  chSysLock();
    6022:	b0 12 a0 5f 	call	#24480		;#0x5fa0
    6026:	b0 12 0c 5b 	call	#23308		;#0x5b0c

0000602a <.Loc.141.2>:
  p = chCoreAllocAlignedI(size, align);
    602a:	2d 41       	mov	@r1,	r13	;
    602c:	1c 41 02 00 	mov	2(r1),	r12	;
    6030:	b0 12 b2 5f 	call	#24498		;#0x5fb2
    6034:	81 4c 04 00 	mov	r12,	4(r1)	;

00006038 <.Loc.142.2>:
  chSysUnlock();
    6038:	b0 12 2c 5b 	call	#23340		;#0x5b2c
    603c:	b0 12 a8 5f 	call	#24488		;#0x5fa8

00006040 <.Loc.144.2>:

  return p;
    6040:	1c 41 04 00 	mov	4(r1),	r12	;

00006044 <.Loc.145.2>:
}
    6044:	31 50 06 00 	add	#6,	r1	;
    6048:	30 41       	ret			

0000604a <_heap_init>:
 *
 * @notapi
 */
void _heap_init(void) {

  default_heap.provider = chCoreAllocAligned;
    604a:	b2 40 16 60 	mov	#24598,	&0x51a4	;#0x6016
    604e:	a4 51 

00006050 <.Loc.110.1>:
  H_NEXT(&default_heap.header) = NULL;
    6050:	82 43 a6 51 	mov	#0,	&0x51a6	;r3 As==00

00006054 <.Loc.111.1>:
  H_PAGES(&default_heap.header) = 0;
    6054:	82 43 a8 51 	mov	#0,	&0x51a8	;r3 As==00

00006058 <.Loc.115.1>:
#if (CH_CFG_USE_MUTEXES == TRUE) || defined(__DOXYGEN__)
  chMtxObjectInit(&default_heap.mtx);
#else
  chSemObjectInit(&default_heap.sem, (cnt_t)1);
    6058:	92 43 aa 51 	mov	#1,	&0x51aa	;r3 As==01

0000605c <.Loc.117.1>:
#endif
}
    605c:	03 43       	nop			
    605e:	30 41       	ret			

00006060 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6060:	03 43       	nop			

00006062 <.Loc.355.1>:
  _enable_interrupts();
    6062:	32 d2       	eint			
    6064:	03 43       	nop			

00006066 <.Loc.356.1>:
}
    6066:	03 43       	nop			
    6068:	30 41       	ret			

0000606a <_port_switch>:
  asm volatile ("mova r1, @R13");
  asm volatile ("mova @R12, r1");
  asm volatile ("popm.a #7, R10");
  asm volatile ("reta");
#else
  asm volatile ("pushm.w #7, R10");
    606a:	6a 15       	pushm	#7,	r10	;16-bit words

0000606c <.Loc.78.2>:
  asm volatile ("mov r1, @R13");
    606c:	8d 41 00 00 	mov	r1,	0(r13)	;

00006070 <.Loc.79.2>:
  asm volatile ("mov @R12, r1");
    6070:	21 4c       	mov	@r12,	r1	;

00006072 <.Loc.80.2>:
  asm volatile ("popm.w #7, R10");
    6072:	64 17       	popm	#7,	r10	;16-bit words

00006074 <.Loc.81.2>:
  asm volatile ("ret");
    6074:	30 41       	ret			

00006076 <.Loc.83.2>:
#endif
}
    6076:	03 43       	nop			

00006078 <_port_thread_start>:
 *          invoked.
 */
void _port_thread_start(void) {
  
  /* See PORT_SETUP_CONTEXT in nilcore.h */
  chSysUnlock();
    6078:	b0 12 2c 5b 	call	#23340		;#0x5b2c
    607c:	b0 12 60 60 	call	#24672		;#0x6060

00006080 <.Loc.98.2>:
#if defined(__MSP430X_LARGE__)
  asm volatile ("mova R5, R12");
  asm volatile ("calla R4");
#else
  asm volatile ("mov R5, R12");
    6080:	0c 45       	mov	r5,	r12	;

00006082 <.Loc.99.2>:
  asm volatile ("call R4");
    6082:	84 12       	call	r4		;

00006084 <.Loc.101.2>:
#endif
  chSysHalt(0);
    6084:	4c 43       	clr.b	r12		;
    6086:	b0 12 ee 5c 	call	#23790		;#0x5cee

0000608a <.Loc.102.2>:
}
    608a:	03 43       	nop			
    608c:	30 41       	ret			

0000608e <osalThreadDequeueNextI>:
 * @param[in] tqp       pointer to the threads queue object
 * @param[in] msg       the message code
 *
 * @iclass
 */
void osalThreadDequeueNextI(threads_queue_t *tqp, msg_t msg) {
    608e:	31 82       	sub	#8,	r1	;r2 As==11

00006090 <.LCFI0>:
    6090:	81 4c 02 00 	mov	r12,	2(r1)	;
    6094:	81 4d 00 00 	mov	r13,	0(r1)	;

00006098 <.Loc.60.1>:
  semaphore_t *sp = &tqp->sem;
    6098:	91 41 02 00 	mov	2(r1),	4(r1)	;
    609c:	04 00 

0000609e <.Loc.62.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    609e:	1c 41 02 00 	mov	2(r1),	r12	;
    60a2:	2c 4c       	mov	@r12,	r12	;
    60a4:	0c 93       	cmp	#0,	r12	;r3 As==00
    60a6:	1d 34       	jge	$+60     	;abs 0x60e2

000060a8 <.LBB2>:
    thread_t *tp = nil.threads;
    60a8:	b1 40 88 51 	mov	#20872,	6(r1)	;#0x5188
    60ac:	06 00 

000060ae <.L4>:
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    60ae:	1c 41 06 00 	mov	6(r1),	r12	;
    60b2:	1c 4c 04 00 	mov	4(r12),	r12	;
    60b6:	1c 91 04 00 	cmp	4(r1),	r12	;
    60ba:	0f 20       	jnz	$+32     	;abs 0x60da

000060bc <.Loc.67.1>:
        sp->cnt++;
    60bc:	1c 41 04 00 	mov	4(r1),	r12	;
    60c0:	2c 4c       	mov	@r12,	r12	;
    60c2:	1c 53       	inc	r12		;
    60c4:	0d 4c       	mov	r12,	r13	;
    60c6:	1c 41 04 00 	mov	4(r1),	r12	;
    60ca:	8c 4d 00 00 	mov	r13,	0(r12)	;

000060ce <.Loc.71.1>:

        chDbgAssert(NIL_THD_IS_WTSEM(tp), "not waiting");

        (void) chSchReadyI(tp, msg);
    60ce:	2d 41       	mov	@r1,	r13	;
    60d0:	1c 41 06 00 	mov	6(r1),	r12	;
    60d4:	b0 12 8c 5d 	call	#23948		;#0x5d8c

000060d8 <.Loc.72.1>:
        return;
    60d8:	04 3c       	jmp	$+10     	;abs 0x60e2

000060da <.L3>:
      }
      tp++;
    60da:	b1 50 0c 00 	add	#12,	6(r1)	;#0x000c
    60de:	06 00 

000060e0 <.Loc.66.1>:

  if (chSemGetCounterI(&tqp->sem) < (cnt_t)0) {
    thread_t *tp = nil.threads;
    while (true) {
      /* Is this thread waiting on this semaphore?*/
      if (tp->u1.semp == sp) {
    60e0:	e6 3f       	jmp	$-50     	;abs 0x60ae

000060e2 <.L1>:

      chDbgAssert(tp < &nil.threads[CH_CFG_NUM_THREADS],
                  "pointer out of range");
    }
  }
}
    60e2:	31 52       	add	#8,	r1	;r2 As==11
    60e4:	30 41       	ret			

000060e6 <osalInit>:
 *
 * @api
 */
static inline void osalInit(void) {

}
    60e6:	03 43       	nop			
    60e8:	30 41       	ret			

000060ea <halInit>:
 * @init
 */
void halInit(void) {

  /* Initializes the OS Abstraction Layer.*/
  osalInit();
    60ea:	b0 12 e6 60 	call	#24806		;#0x60e6

000060ee <.Loc.62.2>:

  /* Platform low level initializations.*/
  hal_lld_init();
    60ee:	b0 12 6a 6b 	call	#27498		;#0x6b6a

000060f2 <.Loc.65.2>:

#if (HAL_USE_PAL == TRUE) || defined(__DOXYGEN__)
  palInit(&pal_default_config);
    60f2:	3c 40 50 50 	mov	#20560,	r12	;#0x5050
    60f6:	b0 12 9a 71 	call	#29082		;#0x719a

000060fa <.Loc.98.2>:
#endif
#if (HAL_USE_PWM == TRUE) || defined(__DOXYGEN__)
  pwmInit();
#endif
#if (HAL_USE_SERIAL == TRUE) || defined(__DOXYGEN__)
  sdInit();
    60fa:	b0 12 f6 68 	call	#26870		;#0x68f6

000060fe <.Loc.104.2>:
#endif
#if (HAL_USE_SDC == TRUE) || defined(__DOXYGEN__)
  sdcInit();
#endif
#if (HAL_USE_SPI == TRUE) || defined(__DOXYGEN__)
  spiInit();
    60fe:	b0 12 5c 6a 	call	#27228		;#0x6a5c

00006102 <.Loc.133.2>:
  halCommunityInit();
#endif
#endif

  /* Board specific initialization.*/
  boardInit();
    6102:	b0 12 70 7c 	call	#31856		;#0x7c70

00006106 <.Loc.140.2>:
/*
 *  The ST driver is a special case, it is only initialized if the OSAL is
 *  configured to require it.
 */
#if OSAL_ST_MODE != OSAL_ST_MODE_NONE
  stInit();
    6106:	b0 12 0e 61 	call	#24846		;#0x610e

0000610a <.Loc.142.2>:
#endif
}
    610a:	03 43       	nop			
    610c:	30 41       	ret			

0000610e <stInit>:
 *
 * @init
 */
void stInit(void) {

  st_lld_init();
    610e:	b0 12 f6 6b 	call	#27638		;#0x6bf6

00006112 <.Loc.63.2>:
}
    6112:	03 43       	nop			
    6114:	30 41       	ret			

00006116 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6116:	32 c2       	dint			

00006118 <.Loc.347.1>:
  asm volatile("nop");
    6118:	03 43       	nop			

0000611a <.Loc.348.1>:
}
    611a:	03 43       	nop			
    611c:	30 41       	ret			

0000611e <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    611e:	03 43       	nop			

00006120 <.Loc.355.1>:
  _enable_interrupts();
    6120:	32 d2       	eint			
    6122:	03 43       	nop			

00006124 <.Loc.356.1>:
}
    6124:	03 43       	nop			
    6126:	30 41       	ret			

00006128 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6128:	b0 12 16 61 	call	#24854		;#0x6116
    612c:	b0 12 0c 5b 	call	#23308		;#0x5b0c

00006130 <.Loc.505.2>:
}
    6130:	03 43       	nop			
    6132:	30 41       	ret			

00006134 <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    6134:	b0 12 2c 5b 	call	#23340		;#0x5b2c
    6138:	b0 12 1e 61 	call	#24862		;#0x611e

0000613c <.Loc.516.2>:
}
    613c:	03 43       	nop			
    613e:	30 41       	ret			

00006140 <osalOsGetSystemTimeX>:
 *
 * @xclass
 */
static inline systime_t osalOsGetSystemTimeX(void) {

  return chVTGetSystemTimeX();
    6140:	1c 42 80 51 	mov	&0x5180,r12	;0x5180

00006144 <.Loc.630.2>:
}
    6144:	30 41       	ret			

00006146 <osalThreadQueueObjectInit>:
 *
 * @param[out] tqp      pointer to the threads queue object
 *
 * @init
 */
static inline void osalThreadQueueObjectInit(threads_queue_t *tqp) {
    6146:	21 83       	decd	r1		;

00006148 <.LCFI0>:
    6148:	81 4c 00 00 	mov	r12,	0(r1)	;

0000614c <.Loc.767.2>:

  chSemObjectInit(&tqp->sem, (cnt_t)0);
    614c:	2c 41       	mov	@r1,	r12	;
    614e:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00006152 <.Loc.768.2>:
}
    6152:	03 43       	nop			
    6154:	21 53       	incd	r1		;
    6156:	30 41       	ret			

00006158 <osalThreadEnqueueTimeoutS>:
 *                      specification.
 *
 * @sclass
 */
static inline msg_t osalThreadEnqueueTimeoutS(threads_queue_t *tqp,
                                              systime_t time) {
    6158:	21 82       	sub	#4,	r1	;r2 As==10

0000615a <.LCFI1>:
    615a:	81 4c 02 00 	mov	r12,	2(r1)	;
    615e:	81 4d 00 00 	mov	r13,	0(r1)	;

00006162 <.Loc.796.2>:

  return chSemWaitTimeoutS(&tqp->sem, time);
    6162:	1c 41 02 00 	mov	2(r1),	r12	;
    6166:	2d 41       	mov	@r1,	r13	;
    6168:	b0 12 f6 5e 	call	#24310		;#0x5ef6

0000616c <.Loc.797.2>:
}
    616c:	21 52       	add	#4,	r1	;r2 As==10
    616e:	30 41       	ret			

00006170 <iqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void iqObjectInit(input_queue_t *iqp, uint8_t *bp, size_t size,
                  qnotify_t infy, void *link) {
    6170:	31 82       	sub	#8,	r1	;r2 As==11

00006172 <.LCFI2>:
    6172:	81 4c 06 00 	mov	r12,	6(r1)	;
    6176:	81 4d 04 00 	mov	r13,	4(r1)	;
    617a:	81 4e 02 00 	mov	r14,	2(r1)	;
    617e:	81 4f 00 00 	mov	r15,	0(r1)	;

00006182 <.Loc.58.3>:

  osalThreadQueueObjectInit(&iqp->q_waiting);
    6182:	1c 41 06 00 	mov	6(r1),	r12	;
    6186:	b0 12 46 61 	call	#24902		;#0x6146

0000618a <.Loc.59.3>:
  iqp->q_counter = 0;
    618a:	1c 41 06 00 	mov	6(r1),	r12	;
    618e:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006192 <.Loc.60.3>:
  iqp->q_buffer  = bp;
    6192:	1c 41 06 00 	mov	6(r1),	r12	;
    6196:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    619a:	04 00 

0000619c <.Loc.61.3>:
  iqp->q_rdptr   = bp;
    619c:	1c 41 06 00 	mov	6(r1),	r12	;
    61a0:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    61a4:	0a 00 

000061a6 <.Loc.62.3>:
  iqp->q_wrptr   = bp;
    61a6:	1c 41 06 00 	mov	6(r1),	r12	;
    61aa:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    61ae:	08 00 

000061b0 <.Loc.63.3>:
  iqp->q_top     = bp + size;
    61b0:	1d 41 04 00 	mov	4(r1),	r13	;
    61b4:	1d 51 02 00 	add	2(r1),	r13	;
    61b8:	1c 41 06 00 	mov	6(r1),	r12	;
    61bc:	8c 4d 06 00 	mov	r13,	6(r12)	;

000061c0 <.Loc.64.3>:
  iqp->q_notify  = infy;
    61c0:	1c 41 06 00 	mov	6(r1),	r12	;
    61c4:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

000061c8 <.Loc.65.3>:
  iqp->q_link    = link;
    61c8:	1c 41 06 00 	mov	6(r1),	r12	;
    61cc:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    61d0:	0e 00 

000061d2 <.Loc.66.3>:
}
    61d2:	03 43       	nop			
    61d4:	31 52       	add	#8,	r1	;r2 As==11
    61d6:	30 41       	ret			

000061d8 <iqPutI>:
 * @retval MSG_TIMEOUT  if the queue is full and the operation cannot be
 *                      completed.
 *
 * @iclass
 */
msg_t iqPutI(input_queue_t *iqp, uint8_t b) {
    61d8:	21 82       	sub	#4,	r1	;r2 As==10

000061da <.LCFI4>:
    61da:	81 4c 02 00 	mov	r12,	2(r1)	;
    61de:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000061e2 <.Loc.104.3>:

  osalDbgCheckClassI();
    61e2:	b0 12 f2 5b 	call	#23538		;#0x5bf2

000061e6 <.Loc.106.3>:

  if (iqIsFullI(iqp)) {
    61e6:	1c 41 02 00 	mov	2(r1),	r12	;
    61ea:	1d 4c 08 00 	mov	8(r12),	r13	;
    61ee:	1c 41 02 00 	mov	2(r1),	r12	;
    61f2:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    61f6:	0d 9c       	cmp	r12,	r13	;
    61f8:	08 20       	jnz	$+18     	;abs 0x620a

000061fa <.Loc.106.3>:
    61fa:	1c 41 02 00 	mov	2(r1),	r12	;
    61fe:	1c 4c 02 00 	mov	2(r12),	r12	;
    6202:	0c 93       	cmp	#0,	r12	;r3 As==00
    6204:	02 24       	jz	$+6      	;abs 0x620a

00006206 <.Loc.106.3>:
    6206:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6208:	01 3c       	jmp	$+4      	;abs 0x620c

0000620a <.L13>:
    620a:	4c 43       	clr.b	r12		;

0000620c <.L14>:
    620c:	5c f3       	and.b	#1,	r12	;r3 As==01
    620e:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6212:	0c 93       	cmp	#0,	r12	;r3 As==00
    6214:	02 24       	jz	$+6      	;abs 0x621a

00006216 <.Loc.107.3>:
    return MSG_TIMEOUT;
    6216:	3c 43       	mov	#-1,	r12	;r3 As==11
    6218:	2f 3c       	jmp	$+96     	;abs 0x6278

0000621a <.L15>:
  }

  iqp->q_counter++;
    621a:	1c 41 02 00 	mov	2(r1),	r12	;
    621e:	1c 4c 02 00 	mov	2(r12),	r12	;
    6222:	0d 4c       	mov	r12,	r13	;
    6224:	1d 53       	inc	r13		;
    6226:	1c 41 02 00 	mov	2(r1),	r12	;
    622a:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000622e <.Loc.111.3>:
  *iqp->q_wrptr++ = b;
    622e:	1c 41 02 00 	mov	2(r1),	r12	;
    6232:	1c 4c 08 00 	mov	8(r12),	r12	;
    6236:	0e 4c       	mov	r12,	r14	;
    6238:	1e 53       	inc	r14		;
    623a:	1d 41 02 00 	mov	2(r1),	r13	;
    623e:	8d 4e 08 00 	mov	r14,	8(r13)	;
    6242:	dc 41 01 00 	mov.b	1(r1),	0(r12)	;
    6246:	00 00 

00006248 <.Loc.112.3>:
  if (iqp->q_wrptr >= iqp->q_top) {
    6248:	1c 41 02 00 	mov	2(r1),	r12	;
    624c:	1d 4c 08 00 	mov	8(r12),	r13	;
    6250:	1c 41 02 00 	mov	2(r1),	r12	;
    6254:	1c 4c 06 00 	mov	6(r12),	r12	;
    6258:	0d 9c       	cmp	r12,	r13	;
    625a:	08 28       	jnc	$+18     	;abs 0x626c

0000625c <.Loc.113.3>:
    iqp->q_wrptr = iqp->q_buffer;
    625c:	1c 41 02 00 	mov	2(r1),	r12	;
    6260:	1d 4c 04 00 	mov	4(r12),	r13	;
    6264:	1c 41 02 00 	mov	2(r1),	r12	;
    6268:	8c 4d 08 00 	mov	r13,	8(r12)	;

0000626c <.L17>:
  }

  osalThreadDequeueNextI(&iqp->q_waiting, MSG_OK);
    626c:	1c 41 02 00 	mov	2(r1),	r12	;
    6270:	4d 43       	clr.b	r13		;
    6272:	b0 12 8e 60 	call	#24718		;#0x608e

00006276 <.Loc.118.3>:

  return MSG_OK;
    6276:	4c 43       	clr.b	r12		;

00006278 <.L16>:
}
    6278:	21 52       	add	#4,	r1	;r2 As==10
    627a:	30 41       	ret			

0000627c <iqGetTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t iqGetTimeout(input_queue_t *iqp, systime_t timeout) {
    627c:	31 82       	sub	#8,	r1	;r2 As==11

0000627e <.LCFI5>:
    627e:	81 4c 02 00 	Address 0x0000000000006280 is out of bounds.
mov	r12,	-1(r1)	; 0xffff

00006280 <L0>:
    6280:	02 00       	mova	@r0,	r2	;
    6282:	81 4d 00 00 	mov	r13,	0(r1)	;

00006286 <.Loc.144.3>:
  uint8_t b;

  osalSysLock();
    6286:	b0 12 28 61 	call	#24872		;#0x6128

0000628a <.Loc.147.3>:

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    628a:	0f 3c       	jmp	$+32     	;abs 0x62aa

0000628c <.L21>:
    msg_t msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    628c:	1c 41 02 00 	mov	2(r1),	r12	;
    6290:	2d 41       	mov	@r1,	r13	;
    6292:	b0 12 58 61 	call	#24920		;#0x6158
    6296:	81 4c 06 00 	mov	r12,	6(r1)	;

0000629a <.Loc.149.3>:
    if (msg < MSG_OK) {
    629a:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    629e:	05 34       	jge	$+12     	;abs 0x62aa

000062a0 <.Loc.150.3>:
      osalSysUnlock();
    62a0:	b0 12 34 61 	call	#24884		;#0x6134

000062a4 <.Loc.151.3>:
      return msg;
    62a4:	1c 41 06 00 	mov	6(r1),	r12	;
    62a8:	3f 3c       	jmp	$+128    	;abs 0x6328

000062aa <.L19>:
  uint8_t b;

  osalSysLock();

  /* Waiting until there is a character available or a timeout occurs.*/
  while (iqIsEmptyI(iqp)) {
    62aa:	1c 41 02 00 	mov	2(r1),	r12	;
    62ae:	1c 4c 02 00 	mov	2(r12),	r12	;
    62b2:	0c 93       	cmp	#0,	r12	;r3 As==00
    62b4:	eb 27       	jz	$-40     	;abs 0x628c

000062b6 <.Loc.156.3>:
      return msg;
    }
  }

  /* Getting the character from the queue.*/
  iqp->q_counter--;
    62b6:	1c 41 02 00 	mov	2(r1),	r12	;
    62ba:	1c 4c 02 00 	mov	2(r12),	r12	;
    62be:	0d 4c       	mov	r12,	r13	;
    62c0:	3d 53       	add	#-1,	r13	;r3 As==11
    62c2:	1c 41 02 00 	mov	2(r1),	r12	;
    62c6:	8c 4d 02 00 	mov	r13,	2(r12)	;

000062ca <.Loc.157.3>:
  b = *iqp->q_rdptr++;
    62ca:	1c 41 02 00 	mov	2(r1),	r12	;
    62ce:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    62d2:	0e 4c       	mov	r12,	r14	;
    62d4:	1e 53       	inc	r14		;
    62d6:	1d 41 02 00 	mov	2(r1),	r13	;
    62da:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    62de:	e1 4c 05 00 	mov.b	@r12,	5(r1)	;

000062e2 <.Loc.158.3>:
  if (iqp->q_rdptr >= iqp->q_top) {
    62e2:	1c 41 02 00 	mov	2(r1),	r12	;
    62e6:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    62ea:	1c 41 02 00 	mov	2(r1),	r12	;
    62ee:	1c 4c 06 00 	mov	6(r12),	r12	;
    62f2:	0d 9c       	cmp	r12,	r13	;
    62f4:	08 28       	jnc	$+18     	;abs 0x6306

000062f6 <.Loc.159.3>:
    iqp->q_rdptr = iqp->q_buffer;
    62f6:	1c 41 02 00 	mov	2(r1),	r12	;
    62fa:	1d 4c 04 00 	mov	4(r12),	r13	;
    62fe:	1c 41 02 00 	mov	2(r1),	r12	;
    6302:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006306 <.L22>:
  }

  /* Inform the low side that the queue has at least one slot available.*/
  if (iqp->q_notify != NULL) {
    6306:	1c 41 02 00 	mov	2(r1),	r12	;
    630a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    630e:	0c 93       	cmp	#0,	r12	;r3 As==00
    6310:	07 24       	jz	$+16     	;abs 0x6320

00006312 <.Loc.164.3>:
    iqp->q_notify(iqp);
    6312:	1c 41 02 00 	mov	2(r1),	r12	;
    6316:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    631a:	1c 41 02 00 	mov	2(r1),	r12	;
    631e:	8d 12       	call	r13		;

00006320 <.L23>:
  }

  osalSysUnlock();
    6320:	b0 12 34 61 	call	#24884		;#0x6134

00006324 <.Loc.169.3>:

  return (msg_t)b;
    6324:	5c 41 05 00 	mov.b	5(r1),	r12	;

00006328 <.L20>:
}
    6328:	31 52       	add	#8,	r1	;r2 As==11
    632a:	30 41       	ret			

0000632c <iqReadTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t iqReadTimeout(input_queue_t *iqp, uint8_t *bp,
                     size_t n, systime_t timeout) {
    632c:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006330 <L0>:
    6330:	81 4c 06 00 	mov	r12,	6(r1)	;
    6334:	81 4d 04 00 	mov	r13,	4(r1)	;
    6338:	81 4e 02 00 	mov	r14,	2(r1)	;
    633c:	81 4f 00 00 	mov	r15,	0(r1)	;

00006340 <.Loc.199.3>:
  systime_t deadline;
  qnotify_t nfy = iqp->q_notify;
    6340:	1c 41 06 00 	mov	6(r1),	r12	;
    6344:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    6348:	0c 00 

0000634a <.Loc.200.3>:
  size_t r = 0;
    634a:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

0000634e <.Loc.204.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    634e:	b0 12 28 61 	call	#24872		;#0x6128

00006352 <.Loc.209.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6352:	b0 12 40 61 	call	#24896		;#0x6140
    6356:	0d 4c       	mov	r12,	r13	;
    6358:	2d 51       	add	@r1,	r13	;
    635a:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

0000635e <.Loc.213.3>:

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    635e:	2e 3c       	jmp	$+94     	;abs 0x63bc

00006360 <.L31>:
      msg_t msg;

      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6360:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6364:	03 24       	jz	$+8      	;abs 0x636c

00006366 <.Loc.218.3>:
    6366:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    636a:	08 20       	jnz	$+18     	;abs 0x637c

0000636c <.L26>:
        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, timeout);
    636c:	1c 41 06 00 	mov	6(r1),	r12	;
    6370:	2d 41       	mov	@r1,	r13	;
    6372:	b0 12 58 61 	call	#24920		;#0x6158
    6376:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    637a:	18 3c       	jmp	$+50     	;abs 0x63ac

0000637c <.L27>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    637c:	b0 12 40 61 	call	#24896		;#0x6140
    6380:	1d 41 0a 00 	mov	10(r1),	r13	;0x0000a
    6384:	0d 8c       	sub	r12,	r13	;
    6386:	81 4d 08 00 	mov	r13,	8(r1)	;

0000638a <.Loc.227.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    638a:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    638e:	00 00 
    6390:	05 2c       	jc	$+12     	;abs 0x639c

00006392 <.Loc.228.3>:
          osalSysUnlock();
    6392:	b0 12 34 61 	call	#24884		;#0x6134

00006396 <.Loc.229.3>:
          return r;
    6396:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    639a:	5c 3c       	jmp	$+186    	;abs 0x6454

0000639c <.L29>:
        }

        msg = osalThreadEnqueueTimeoutS(&iqp->q_waiting, next_timeout);
    639c:	1c 41 06 00 	mov	6(r1),	r12	;
    63a0:	1d 41 08 00 	mov	8(r1),	r13	;
    63a4:	b0 12 58 61 	call	#24920		;#0x6158
    63a8:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

000063ac <.L28>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    63ac:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    63b0:	05 24       	jz	$+12     	;abs 0x63bc

000063b2 <.Loc.237.3>:
        osalSysUnlock();
    63b2:	b0 12 34 61 	call	#24884		;#0x6134

000063b6 <.Loc.238.3>:
        return r;
    63b6:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    63ba:	4c 3c       	jmp	$+154    	;abs 0x6454

000063bc <.L25>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    63bc:	1c 41 06 00 	mov	6(r1),	r12	;
    63c0:	1c 4c 02 00 	mov	2(r12),	r12	;
    63c4:	0c 93       	cmp	#0,	r12	;r3 As==00
    63c6:	cc 27       	jz	$-102    	;abs 0x6360

000063c8 <.Loc.243.3>:
        return r;
      }
    }

    /* Getting the character from the queue.*/
    iqp->q_counter--;
    63c8:	1c 41 06 00 	mov	6(r1),	r12	;
    63cc:	1c 4c 02 00 	mov	2(r12),	r12	;
    63d0:	0d 4c       	mov	r12,	r13	;
    63d2:	3d 53       	add	#-1,	r13	;r3 As==11
    63d4:	1c 41 06 00 	mov	6(r1),	r12	;
    63d8:	8c 4d 02 00 	mov	r13,	2(r12)	;

000063dc <.Loc.244.3>:
    *bp++ = *iqp->q_rdptr++;
    63dc:	1c 41 04 00 	mov	4(r1),	r12	;
    63e0:	0d 4c       	mov	r12,	r13	;
    63e2:	1d 53       	inc	r13		;
    63e4:	81 4d 04 00 	mov	r13,	4(r1)	;
    63e8:	1d 41 06 00 	mov	6(r1),	r13	;
    63ec:	1d 4d 0a 00 	mov	10(r13),r13	;0x0000a
    63f0:	0f 4d       	mov	r13,	r15	;
    63f2:	1f 53       	inc	r15		;
    63f4:	1e 41 06 00 	mov	6(r1),	r14	;
    63f8:	8e 4f 0a 00 	mov	r15,	10(r14)	; 0x000a
    63fc:	6d 4d       	mov.b	@r13,	r13	;
    63fe:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

00006402 <.Loc.245.3>:
    if (iqp->q_rdptr >= iqp->q_top) {
    6402:	1c 41 06 00 	mov	6(r1),	r12	;
    6406:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    640a:	1c 41 06 00 	mov	6(r1),	r12	;
    640e:	1c 4c 06 00 	mov	6(r12),	r12	;
    6412:	0d 9c       	cmp	r12,	r13	;
    6414:	08 28       	jnc	$+18     	;abs 0x6426

00006416 <.Loc.246.3>:
      iqp->q_rdptr = iqp->q_buffer;
    6416:	1c 41 06 00 	mov	6(r1),	r12	;
    641a:	1d 4c 04 00 	mov	4(r12),	r13	;
    641e:	1c 41 06 00 	mov	6(r1),	r12	;
    6422:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00006426 <.L32>:
    }

    /* Inform the low side that the queue has at least one slot available.*/
    if (nfy != NULL) {
    6426:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    642a:	05 24       	jz	$+12     	;abs 0x6436

0000642c <.Loc.251.3>:
      nfy(iqp);
    642c:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6430:	1c 41 06 00 	mov	6(r1),	r12	;
    6434:	8d 12       	call	r13		;

00006436 <.L33>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    6436:	b0 12 34 61 	call	#24884		;#0x6134

0000643a <.Loc.257.3>:

    r++;
    643a:	91 53 10 00 	inc	16(r1)		;

0000643e <.Loc.258.3>:
    if (--n == 0U) {
    643e:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6442:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6446:	03 20       	jnz	$+8      	;abs 0x644e

00006448 <.Loc.259.3>:
      return r;
    6448:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    644c:	03 3c       	jmp	$+8      	;abs 0x6454

0000644e <.L34>:
    }

    osalSysLock();
    644e:	b0 12 28 61 	call	#24872		;#0x6128

00006452 <.Loc.213.3>:
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    /* Waiting until there is a character available or a timeout occurs.*/
    while (iqIsEmptyI(iqp)) {
    6452:	b4 3f       	jmp	$-150    	;abs 0x63bc

00006454 <.L30>:
      return r;
    }

    osalSysLock();
  }
}
    6454:	31 50 12 00 	add	#18,	r1	;#0x0012
    6458:	30 41       	ret			

0000645a <oqObjectInit>:
 * @param[in] link      application defined pointer
 *
 * @init
 */
void oqObjectInit(output_queue_t *oqp, uint8_t *bp, size_t size,
                  qnotify_t onfy, void *link) {
    645a:	31 82       	sub	#8,	r1	;r2 As==11

0000645c <.LCFI7>:
    645c:	81 4c 06 00 	mov	r12,	6(r1)	;
    6460:	81 4d 04 00 	mov	r13,	4(r1)	;
    6464:	81 4e 02 00 	Address 0x0000000000006466 is out of bounds.
mov	r14,	-1(r1)	; 0xffff

00006466 <L0>:
    6466:	02 00       	mova	@r0,	r2	;
    6468:	81 4f 00 00 	mov	r15,	0(r1)	;

0000646c <.Loc.284.3>:

  osalThreadQueueObjectInit(&oqp->q_waiting);
    646c:	1c 41 06 00 	mov	6(r1),	r12	;
    6470:	b0 12 46 61 	call	#24902		;#0x6146

00006474 <.Loc.285.3>:
  oqp->q_counter = size;
    6474:	1c 41 06 00 	mov	6(r1),	r12	;
    6478:	9c 41 02 00 	mov	2(r1),	2(r12)	;
    647c:	02 00 

0000647e <.Loc.286.3>:
  oqp->q_buffer  = bp;
    647e:	1c 41 06 00 	mov	6(r1),	r12	;
    6482:	9c 41 04 00 	mov	4(r1),	4(r12)	;
    6486:	04 00 

00006488 <.Loc.287.3>:
  oqp->q_rdptr   = bp;
    6488:	1c 41 06 00 	mov	6(r1),	r12	;
    648c:	9c 41 04 00 	mov	4(r1),	10(r12)	; 0x000a
    6490:	0a 00 

00006492 <.Loc.288.3>:
  oqp->q_wrptr   = bp;
    6492:	1c 41 06 00 	mov	6(r1),	r12	;
    6496:	9c 41 04 00 	mov	4(r1),	8(r12)	;
    649a:	08 00 

0000649c <.Loc.289.3>:
  oqp->q_top     = bp + size;
    649c:	1d 41 04 00 	mov	4(r1),	r13	;
    64a0:	1d 51 02 00 	add	2(r1),	r13	;
    64a4:	1c 41 06 00 	mov	6(r1),	r12	;
    64a8:	8c 4d 06 00 	mov	r13,	6(r12)	;

000064ac <.Loc.290.3>:
  oqp->q_notify  = onfy;
    64ac:	1c 41 06 00 	mov	6(r1),	r12	;
    64b0:	ac 41 0c 00 	mov	@r1,	12(r12)	; 0x000c

000064b4 <.Loc.291.3>:
  oqp->q_link    = link;
    64b4:	1c 41 06 00 	mov	6(r1),	r12	;
    64b8:	9c 41 0a 00 	mov	10(r1),	14(r12)	;0x0000a, 0x000e
    64bc:	0e 00 

000064be <.Loc.292.3>:
}
    64be:	03 43       	nop			
    64c0:	31 52       	add	#8,	r1	;r2 As==11
    64c2:	30 41       	ret			

000064c4 <oqPutTimeout>:
 * @retval MSG_TIMEOUT  if the specified time expired.
 * @retval MSG_RESET    if the queue has been reset.
 *
 * @api
 */
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {
    64c4:	31 82       	sub	#8,	r1	;r2 As==11

000064c6 <.LCFI9>:
    64c6:	81 4c 04 00 	mov	r12,	4(r1)	;
    64ca:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    64ce:	81 4e 00 00 	mov	r14,	0(r1)	;

000064d2 <.Loc.339.3>:

  osalSysLock();
    64d2:	b0 12 28 61 	call	#24872		;#0x6128

000064d6 <.Loc.342.3>:

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    64d6:	0f 3c       	jmp	$+32     	;abs 0x64f6

000064d8 <.L41>:
    msg_t msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    64d8:	1c 41 04 00 	mov	4(r1),	r12	;
    64dc:	2d 41       	mov	@r1,	r13	;
    64de:	b0 12 58 61 	call	#24920		;#0x6158
    64e2:	81 4c 06 00 	mov	r12,	6(r1)	;

000064e6 <.Loc.344.3>:
    if (msg < MSG_OK) {
    64e6:	81 93 06 00 	cmp	#0,	6(r1)	;r3 As==00
    64ea:	05 34       	jge	$+12     	;abs 0x64f6

000064ec <.Loc.345.3>:
      osalSysUnlock();
    64ec:	b0 12 34 61 	call	#24884		;#0x6134

000064f0 <.Loc.346.3>:
      return msg;
    64f0:	1c 41 06 00 	mov	6(r1),	r12	;
    64f4:	3f 3c       	jmp	$+128    	;abs 0x6574

000064f6 <.L39>:
msg_t oqPutTimeout(output_queue_t *oqp, uint8_t b, systime_t timeout) {

  osalSysLock();

  /* Waiting until there is a slot available or a timeout occurs.*/
  while (oqIsFullI(oqp)) {
    64f6:	1c 41 04 00 	mov	4(r1),	r12	;
    64fa:	1c 4c 02 00 	mov	2(r12),	r12	;
    64fe:	0c 93       	cmp	#0,	r12	;r3 As==00
    6500:	eb 27       	jz	$-40     	;abs 0x64d8

00006502 <.Loc.351.3>:
      return msg;
    }
  }

  /* Putting the character into the queue.*/
  oqp->q_counter--;
    6502:	1c 41 04 00 	mov	4(r1),	r12	;
    6506:	1c 4c 02 00 	mov	2(r12),	r12	;
    650a:	0d 4c       	mov	r12,	r13	;
    650c:	3d 53       	add	#-1,	r13	;r3 As==11
    650e:	1c 41 04 00 	mov	4(r1),	r12	;
    6512:	8c 4d 02 00 	mov	r13,	2(r12)	;

00006516 <.Loc.352.3>:
  *oqp->q_wrptr++ = b;
    6516:	1c 41 04 00 	mov	4(r1),	r12	;
    651a:	1c 4c 08 00 	mov	8(r12),	r12	;
    651e:	0e 4c       	mov	r12,	r14	;
    6520:	1e 53       	inc	r14		;
    6522:	1d 41 04 00 	mov	4(r1),	r13	;
    6526:	8d 4e 08 00 	mov	r14,	8(r13)	;
    652a:	dc 41 03 00 	mov.b	3(r1),	0(r12)	;
    652e:	00 00 

00006530 <.Loc.353.3>:
  if (oqp->q_wrptr >= oqp->q_top) {
    6530:	1c 41 04 00 	mov	4(r1),	r12	;
    6534:	1d 4c 08 00 	mov	8(r12),	r13	;
    6538:	1c 41 04 00 	mov	4(r1),	r12	;
    653c:	1c 4c 06 00 	mov	6(r12),	r12	;
    6540:	0d 9c       	cmp	r12,	r13	;
    6542:	08 28       	jnc	$+18     	;abs 0x6554

00006544 <.Loc.354.3>:
    oqp->q_wrptr = oqp->q_buffer;
    6544:	1c 41 04 00 	mov	4(r1),	r12	;
    6548:	1d 4c 04 00 	mov	4(r12),	r13	;
    654c:	1c 41 04 00 	mov	4(r1),	r12	;
    6550:	8c 4d 08 00 	mov	r13,	8(r12)	;

00006554 <.L42>:
  }

  /* Inform the low side that the queue has at least one character available.*/
  if (oqp->q_notify != NULL) {
    6554:	1c 41 04 00 	mov	4(r1),	r12	;
    6558:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    655c:	0c 93       	cmp	#0,	r12	;r3 As==00
    655e:	07 24       	jz	$+16     	;abs 0x656e

00006560 <.Loc.359.3>:
    oqp->q_notify(oqp);
    6560:	1c 41 04 00 	mov	4(r1),	r12	;
    6564:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    6568:	1c 41 04 00 	mov	4(r1),	r12	;
    656c:	8d 12       	call	r13		;

0000656e <.L43>:
  }

  osalSysUnlock();
    656e:	b0 12 34 61 	call	#24884		;#0x6134

00006572 <.Loc.364.3>:

  return MSG_OK;
    6572:	4c 43       	clr.b	r12		;

00006574 <.L40>:
}
    6574:	31 52       	add	#8,	r1	;r2 As==11
    6576:	30 41       	ret			

00006578 <oqGetI>:
 * @return              The byte value from the queue.
 * @retval MSG_TIMEOUT  if the queue is empty.
 *
 * @iclass
 */
msg_t oqGetI(output_queue_t *oqp) {
    6578:	21 82       	sub	#4,	r1	;r2 As==10

0000657a <.LCFI10>:
    657a:	81 4c 00 00 	Address 0x000000000000657c is out of bounds.
mov	r12,	-1(r1)	; 0xffff

0000657c <L0>:
	...

0000657e <.Loc.380.3>:
  uint8_t b;

  osalDbgCheckClassI();
    657e:	b0 12 f2 5b 	call	#23538		;#0x5bf2

00006582 <.Loc.382.3>:

  if (oqIsEmptyI(oqp)) {
    6582:	2c 41       	mov	@r1,	r12	;
    6584:	1d 4c 08 00 	mov	8(r12),	r13	;
    6588:	2c 41       	mov	@r1,	r12	;
    658a:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    658e:	0d 9c       	cmp	r12,	r13	;
    6590:	07 20       	jnz	$+16     	;abs 0x65a0

00006592 <.Loc.382.3>:
    6592:	2c 41       	mov	@r1,	r12	;
    6594:	1c 4c 02 00 	mov	2(r12),	r12	;
    6598:	0c 93       	cmp	#0,	r12	;r3 As==00
    659a:	02 24       	jz	$+6      	;abs 0x65a0

0000659c <.Loc.382.3>:
    659c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    659e:	01 3c       	jmp	$+4      	;abs 0x65a2

000065a0 <.L45>:
    65a0:	4c 43       	clr.b	r12		;

000065a2 <.L46>:
    65a2:	5c f3       	and.b	#1,	r12	;r3 As==01
    65a4:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    65a8:	0c 93       	cmp	#0,	r12	;r3 As==00
    65aa:	02 24       	jz	$+6      	;abs 0x65b0

000065ac <.Loc.383.3>:
    return MSG_TIMEOUT;
    65ac:	3c 43       	mov	#-1,	r12	;r3 As==11
    65ae:	26 3c       	jmp	$+78     	;abs 0x65fc

000065b0 <.L47>:
  }

  oqp->q_counter++;
    65b0:	2c 41       	mov	@r1,	r12	;
    65b2:	1c 4c 02 00 	mov	2(r12),	r12	;
    65b6:	0d 4c       	mov	r12,	r13	;
    65b8:	1d 53       	inc	r13		;
    65ba:	2c 41       	mov	@r1,	r12	;
    65bc:	8c 4d 02 00 	mov	r13,	2(r12)	;

000065c0 <.Loc.387.3>:
  b = *oqp->q_rdptr++;
    65c0:	2c 41       	mov	@r1,	r12	;
    65c2:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    65c6:	0e 4c       	mov	r12,	r14	;
    65c8:	1e 53       	inc	r14		;
    65ca:	2d 41       	mov	@r1,	r13	;
    65cc:	8d 4e 0a 00 	mov	r14,	10(r13)	; 0x000a
    65d0:	e1 4c 03 00 	mov.b	@r12,	3(r1)	;

000065d4 <.Loc.388.3>:
  if (oqp->q_rdptr >= oqp->q_top) {
    65d4:	2c 41       	mov	@r1,	r12	;
    65d6:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    65da:	2c 41       	mov	@r1,	r12	;
    65dc:	1c 4c 06 00 	mov	6(r12),	r12	;
    65e0:	0d 9c       	cmp	r12,	r13	;
    65e2:	06 28       	jnc	$+14     	;abs 0x65f0

000065e4 <.Loc.389.3>:
    oqp->q_rdptr = oqp->q_buffer;
    65e4:	2c 41       	mov	@r1,	r12	;
    65e6:	1d 4c 04 00 	mov	4(r12),	r13	;
    65ea:	2c 41       	mov	@r1,	r12	;
    65ec:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000065f0 <.L49>:
  }

  osalThreadDequeueNextI(&oqp->q_waiting, MSG_OK);
    65f0:	2c 41       	mov	@r1,	r12	;
    65f2:	4d 43       	clr.b	r13		;
    65f4:	b0 12 8e 60 	call	#24718		;#0x608e

000065f8 <.Loc.394.3>:

  return (msg_t)b;
    65f8:	5c 41 03 00 	mov.b	3(r1),	r12	;

000065fc <.L48>:
}
    65fc:	21 52       	add	#4,	r1	;r2 As==10
    65fe:	30 41       	ret			

00006600 <oqWriteTimeout>:
 * @return              The number of bytes effectively transferred.
 *
 * @api
 */
size_t oqWriteTimeout(output_queue_t *oqp, const uint8_t *bp,
                      size_t n, systime_t timeout) {
    6600:	31 80 12 00 	sub	#18,	r1	;#0x0012

00006604 <L0>:
    6604:	81 4c 06 00 	mov	r12,	6(r1)	;
    6608:	81 4d 04 00 	mov	r13,	4(r1)	;
    660c:	81 4e 02 00 	mov	r14,	2(r1)	;
    6610:	81 4f 00 00 	mov	r15,	0(r1)	;

00006614 <.Loc.424.3>:
  systime_t deadline;
  qnotify_t nfy = oqp->q_notify;
    6614:	1c 41 06 00 	mov	6(r1),	r12	;
    6618:	91 4c 0c 00 	mov	12(r12),12(r1)	;0x0000c, 0x000c
    661c:	0c 00 

0000661e <.Loc.425.3>:
  size_t w = 0;
    661e:	81 43 10 00 	mov	#0,	16(r1)	;r3 As==00, 0x0010

00006622 <.Loc.429.3>:

  osalDbgCheck(n > 0U);

  osalSysLock();
    6622:	b0 12 28 61 	call	#24872		;#0x6128

00006626 <.Loc.434.3>:

  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;
    6626:	b0 12 40 61 	call	#24896		;#0x6140
    662a:	0d 4c       	mov	r12,	r13	;
    662c:	2d 51       	add	@r1,	r13	;
    662e:	81 4d 0a 00 	mov	r13,	10(r1)	; 0x000a

00006632 <.L61>:

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    6632:	2e 3c       	jmp	$+94     	;abs 0x6690

00006634 <.L57>:
      /* TIME_INFINITE and TIME_IMMEDIATE are handled differently, no
         deadline.*/
      if ((timeout == TIME_INFINITE) || (timeout == TIME_IMMEDIATE)) {
    6634:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    6638:	03 24       	jz	$+8      	;abs 0x6640

0000663a <.Loc.442.3>:
    663a:	b1 93 00 00 	cmp	#-1,	0(r1)	;r3 As==11
    663e:	08 20       	jnz	$+18     	;abs 0x6650

00006640 <.L52>:
        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, timeout);
    6640:	1c 41 06 00 	mov	6(r1),	r12	;
    6644:	2d 41       	mov	@r1,	r13	;
    6646:	b0 12 58 61 	call	#24920		;#0x6158
    664a:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e
    664e:	18 3c       	jmp	$+50     	;abs 0x6680

00006650 <.L53>:
      }
      else {
        systime_t next_timeout = deadline - osalOsGetSystemTimeX();
    6650:	b0 12 40 61 	call	#24896		;#0x6140
    6654:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    6658:	0e 8c       	sub	r12,	r14	;
    665a:	81 4e 08 00 	mov	r14,	8(r1)	;

0000665e <.Loc.451.3>:

        /* Handling the case where the system time went past the deadline,
           in this case next becomes a very high number because the system
           time is an unsigned type.*/
        if (next_timeout > timeout) {
    665e:	91 91 08 00 	cmp	8(r1),	0(r1)	;
    6662:	00 00 
    6664:	05 2c       	jc	$+12     	;abs 0x6670

00006666 <.Loc.452.3>:
          osalSysUnlock();
    6666:	b0 12 34 61 	call	#24884		;#0x6134

0000666a <.Loc.453.3>:
          return w;
    666a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    666e:	5c 3c       	jmp	$+186    	;abs 0x6728

00006670 <.L55>:
        }

        msg = osalThreadEnqueueTimeoutS(&oqp->q_waiting, next_timeout);
    6670:	1c 41 06 00 	mov	6(r1),	r12	;
    6674:	1d 41 08 00 	mov	8(r1),	r13	;
    6678:	b0 12 58 61 	call	#24920		;#0x6158
    667c:	81 4c 0e 00 	mov	r12,	14(r1)	; 0x000e

00006680 <.L54>:
      }

      /* Anything except MSG_OK causes the operation to stop.*/
      if (msg != MSG_OK) {
    6680:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    6684:	05 24       	jz	$+12     	;abs 0x6690

00006686 <.Loc.461.3>:
        osalSysUnlock();
    6686:	b0 12 34 61 	call	#24884		;#0x6134

0000668a <.Loc.462.3>:
        return w;
    668a:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    668e:	4c 3c       	jmp	$+154    	;abs 0x6728

00006690 <.L51>:
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    msg_t msg;

    while (oqIsFullI(oqp)) {
    6690:	1c 41 06 00 	mov	6(r1),	r12	;
    6694:	1c 4c 02 00 	mov	2(r12),	r12	;
    6698:	0c 93       	cmp	#0,	r12	;r3 As==00
    669a:	cc 27       	jz	$-102    	;abs 0x6634

0000669c <.Loc.467.3>:
        return w;
      }
    }

    /* Putting the character into the queue.*/
    oqp->q_counter--;
    669c:	1c 41 06 00 	mov	6(r1),	r12	;
    66a0:	1c 4c 02 00 	mov	2(r12),	r12	;
    66a4:	0d 4c       	mov	r12,	r13	;
    66a6:	3d 53       	add	#-1,	r13	;r3 As==11
    66a8:	1c 41 06 00 	mov	6(r1),	r12	;
    66ac:	8c 4d 02 00 	mov	r13,	2(r12)	;

000066b0 <.Loc.468.3>:
    *oqp->q_wrptr++ = *bp++;
    66b0:	1c 41 06 00 	mov	6(r1),	r12	;
    66b4:	1c 4c 08 00 	mov	8(r12),	r12	;
    66b8:	0e 4c       	mov	r12,	r14	;
    66ba:	1e 53       	inc	r14		;
    66bc:	1d 41 06 00 	mov	6(r1),	r13	;
    66c0:	8d 4e 08 00 	mov	r14,	8(r13)	;
    66c4:	1d 41 04 00 	mov	4(r1),	r13	;
    66c8:	0e 4d       	mov	r13,	r14	;
    66ca:	1e 53       	inc	r14		;
    66cc:	81 4e 04 00 	mov	r14,	4(r1)	;
    66d0:	6d 4d       	mov.b	@r13,	r13	;
    66d2:	cc 4d 00 00 	mov.b	r13,	0(r12)	;

000066d6 <.Loc.469.3>:
    if (oqp->q_wrptr >= oqp->q_top) {
    66d6:	1c 41 06 00 	mov	6(r1),	r12	;
    66da:	1d 4c 08 00 	mov	8(r12),	r13	;
    66de:	1c 41 06 00 	mov	6(r1),	r12	;
    66e2:	1c 4c 06 00 	mov	6(r12),	r12	;
    66e6:	0d 9c       	cmp	r12,	r13	;
    66e8:	08 28       	jnc	$+18     	;abs 0x66fa

000066ea <.Loc.470.3>:
      oqp->q_wrptr = oqp->q_buffer;
    66ea:	1c 41 06 00 	mov	6(r1),	r12	;
    66ee:	1d 4c 04 00 	mov	4(r12),	r13	;
    66f2:	1c 41 06 00 	mov	6(r1),	r12	;
    66f6:	8c 4d 08 00 	mov	r13,	8(r12)	;

000066fa <.L58>:
    }

    /* Inform the low side that the queue has at least one character available.*/
    if (nfy != NULL) {
    66fa:	81 93 0c 00 	cmp	#0,	12(r1)	;r3 As==00, 0x000c
    66fe:	05 24       	jz	$+12     	;abs 0x670a

00006700 <.Loc.475.3>:
      nfy(oqp);
    6700:	1d 41 0c 00 	mov	12(r1),	r13	;0x0000c
    6704:	1c 41 06 00 	mov	6(r1),	r12	;
    6708:	8d 12       	call	r13		;

0000670a <.L59>:
    }

    /* Giving a preemption chance in a controlled point.*/
    osalSysUnlock();
    670a:	b0 12 34 61 	call	#24884		;#0x6134

0000670e <.Loc.481.3>:

    w++;
    670e:	91 53 10 00 	inc	16(r1)		;

00006712 <.Loc.482.3>:
    if (--n == 0U) {
    6712:	b1 53 02 00 	add	#-1,	2(r1)	;r3 As==11
    6716:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    671a:	03 20       	jnz	$+8      	;abs 0x6722

0000671c <.Loc.483.3>:
      return w;
    671c:	1c 41 10 00 	mov	16(r1),	r12	;0x00010
    6720:	03 3c       	jmp	$+8      	;abs 0x6728

00006722 <.L60>:
    }

    osalSysLock();
    6722:	b0 12 28 61 	call	#24872		;#0x6128

00006726 <.LBE6>:
  /* Time deadline for the whole operation, note the result is invalid
     when timeout is TIME_INFINITE or TIME_IMMEDIATE but in that case
     the deadline is not used.*/
  deadline = osalOsGetSystemTimeX() + timeout;

  while (true) {
    6726:	85 3f       	jmp	$-244    	;abs 0x6632

00006728 <.L56>:
      return w;
    }

    osalSysLock();
  }
}
    6728:	31 50 12 00 	add	#18,	r1	;#0x0012
    672c:	30 41       	ret			

0000672e <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    672e:	32 c2       	dint			

00006730 <.Loc.347.1>:
  asm volatile("nop");
    6730:	03 43       	nop			

00006732 <.Loc.348.1>:
}
    6732:	03 43       	nop			
    6734:	30 41       	ret			

00006736 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6736:	03 43       	nop			

00006738 <.Loc.355.1>:
  _enable_interrupts();
    6738:	32 d2       	eint			

0000673a <L0>:
    673a:	03 43       	nop			

0000673c <.Loc.356.1>:
}
    673c:	03 43       	nop			
    673e:	30 41       	ret			

00006740 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6740:	b0 12 2e 67 	call	#26414		;#0x672e
    6744:	b0 12 0c 5b 	call	#23308		;#0x5b0c

00006748 <.Loc.505.2>:
}
    6748:	03 43       	nop			
    674a:	30 41       	ret			

0000674c <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    674c:	b0 12 2c 5b 	call	#23340		;#0x5b2c
    6750:	b0 12 36 67 	call	#26422		;#0x6736

00006754 <.Loc.516.2>:
}
    6754:	03 43       	nop			
    6756:	30 41       	ret			

00006758 <osalEventObjectInit>:
 *
 * @param[out] esp      pointer to the event flags object
 *
 * @init
 */
static inline void osalEventObjectInit(event_source_t *esp) {
    6758:	21 83       	decd	r1		;

0000675a <.LCFI0>:
    675a:	81 4c 00 00 	mov	r12,	0(r1)	;

0000675e <.Loc.810.2>:

  osalDbgCheck(esp != NULL);

  esp->flags = 0;
    675e:	2c 41       	mov	@r1,	r12	;
    6760:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00
    6764:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006768 <.Loc.811.2>:
  esp->cb    = NULL;
    6768:	2c 41       	mov	@r1,	r12	;
    676a:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

0000676e <.Loc.812.2>:
  esp->param = NULL;
    676e:	2c 41       	mov	@r1,	r12	;
    6770:	8c 43 06 00 	mov	#0,	6(r12)	;r3 As==00

00006774 <.Loc.813.2>:
}
    6774:	03 43       	nop			
    6776:	21 53       	incd	r1		;
    6778:	30 41       	ret			

0000677a <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    677a:	0a 15       	pushm	#1,	r10	;16-bit words

0000677c <.LCFI1>:
    677c:	31 80 06 00 	sub	#6,	r1	;

00006780 <.LCFI2>:
    6780:	81 4c 04 00 	mov	r12,	4(r1)	;
    6784:	81 4d 00 00 	mov	r13,	0(r1)	;
    6788:	81 4e 02 00 	mov	r14,	2(r1)	;

0000678c <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    678c:	1c 41 04 00 	mov	4(r1),	r12	;
    6790:	1d 4c 02 00 	mov	2(r12),	r13	;
    6794:	2c 4c       	mov	@r12,	r12	;
    6796:	2a 41       	mov	@r1,	r10	;
    6798:	0a dc       	bis	r12,	r10	;
    679a:	1b 41 02 00 	mov	2(r1),	r11	;
    679e:	0b dd       	bis	r13,	r11	;
    67a0:	1c 41 04 00 	mov	4(r1),	r12	;
    67a4:	8c 4a 00 00 	mov	r10,	0(r12)	;
    67a8:	8c 4b 02 00 	mov	r11,	2(r12)	;

000067ac <.Loc.829.2>:
  if (esp->cb != NULL) {
    67ac:	1c 41 04 00 	mov	4(r1),	r12	;
    67b0:	1c 4c 04 00 	mov	4(r12),	r12	;
    67b4:	0c 93       	cmp	#0,	r12	;r3 As==00
    67b6:	07 24       	jz	$+16     	;abs 0x67c6

000067b8 <.Loc.830.2>:
    esp->cb(esp);
    67b8:	1c 41 04 00 	mov	4(r1),	r12	;
    67bc:	1d 4c 04 00 	mov	4(r12),	r13	;
    67c0:	1c 41 04 00 	mov	4(r1),	r12	;
    67c4:	8d 12       	call	r13		;

000067c6 <.L9>:
  }
}
    67c6:	03 43       	nop			
    67c8:	31 50 06 00 	add	#6,	r1	;
    67cc:	0a 17       	popm	#1,	r10	;16-bit words
    67ce:	30 41       	ret			

000067d0 <write>:
/*
 * Interface implementation, the following functions just invoke the equivalent
 * queue-level function or macro.
 */

static size_t write(void *ip, const uint8_t *bp, size_t n) {
    67d0:	31 80 06 00 	sub	#6,	r1	;

000067d4 <.LCFI3>:
    67d4:	81 4c 04 00 	mov	r12,	4(r1)	;
    67d8:	81 4d 02 00 	mov	r13,	2(r1)	;
    67dc:	81 4e 00 00 	mov	r14,	0(r1)	;

000067e0 <.Loc.52.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp,
    67e0:	1c 41 04 00 	mov	4(r1),	r12	;
    67e4:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    67e8:	4f 43       	clr.b	r15		;
    67ea:	2e 41       	mov	@r1,	r14	;
    67ec:	1d 41 02 00 	mov	2(r1),	r13	;
    67f0:	b0 12 00 66 	call	#26112		;#0x6600

000067f4 <.Loc.54.3>:
                        n, TIME_INFINITE);
}
    67f4:	31 50 06 00 	add	#6,	r1	;
    67f8:	30 41       	ret			

000067fa <read>:

static size_t read(void *ip, uint8_t *bp, size_t n) {
    67fa:	31 80 06 00 	sub	#6,	r1	;

000067fe <.LCFI4>:
    67fe:	81 4c 04 00 	mov	r12,	4(r1)	;
    6802:	81 4d 02 00 	mov	r13,	2(r1)	;
    6806:	81 4e 00 00 	mov	r14,	0(r1)	;

0000680a <.Loc.58.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp,
    680a:	1c 41 04 00 	mov	4(r1),	r12	;
    680e:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6812:	4f 43       	clr.b	r15		;
    6814:	2e 41       	mov	@r1,	r14	;
    6816:	1d 41 02 00 	mov	2(r1),	r13	;
    681a:	b0 12 2c 63 	call	#25388		;#0x632c

0000681e <.Loc.60.3>:
                       n, TIME_INFINITE);
}
    681e:	31 50 06 00 	add	#6,	r1	;
    6822:	30 41       	ret			

00006824 <put>:

static msg_t put(void *ip, uint8_t b) {
    6824:	21 82       	sub	#4,	r1	;r2 As==10

00006826 <.LCFI5>:
    6826:	81 4c 02 00 	mov	r12,	2(r1)	;
    682a:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

0000682e <.Loc.64.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, TIME_INFINITE);
    682e:	1c 41 02 00 	mov	2(r1),	r12	;
    6832:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6836:	4e 43       	clr.b	r14		;
    6838:	5d 41 01 00 	mov.b	1(r1),	r13	;
    683c:	b0 12 c4 64 	call	#25796		;#0x64c4

00006840 <.Loc.65.3>:
}
    6840:	21 52       	add	#4,	r1	;r2 As==10
    6842:	30 41       	ret			

00006844 <get>:

static msg_t get(void *ip) {
    6844:	21 83       	decd	r1		;

00006846 <.LCFI6>:
    6846:	81 4c 00 00 	mov	r12,	0(r1)	;

0000684a <.Loc.69.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, TIME_INFINITE);
    684a:	2c 41       	mov	@r1,	r12	;
    684c:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6850:	4d 43       	clr.b	r13		;
    6852:	b0 12 7c 62 	call	#25212		;#0x627c

00006856 <.Loc.70.3>:
}
    6856:	21 53       	incd	r1		;
    6858:	30 41       	ret			

0000685a <putt>:

static msg_t putt(void *ip, uint8_t b, systime_t timeout) {
    685a:	31 80 06 00 	sub	#6,	r1	;

0000685e <.LCFI7>:
    685e:	81 4c 04 00 	mov	r12,	4(r1)	;
    6862:	c1 4d 03 00 	mov.b	r13,	3(r1)	;
    6866:	81 4e 00 00 	mov	r14,	0(r1)	;

0000686a <.Loc.74.3>:

  return oqPutTimeout(&((SerialDriver *)ip)->oqueue, b, timeout);
    686a:	1c 41 04 00 	mov	4(r1),	r12	;
    686e:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6872:	2e 41       	mov	@r1,	r14	;
    6874:	5d 41 03 00 	mov.b	3(r1),	r13	;
    6878:	b0 12 c4 64 	call	#25796		;#0x64c4

0000687c <.Loc.75.3>:
}
    687c:	31 50 06 00 	add	#6,	r1	;
    6880:	30 41       	ret			

00006882 <gett>:

static msg_t gett(void *ip, systime_t timeout) {
    6882:	21 82       	sub	#4,	r1	;r2 As==10

00006884 <.LCFI8>:
    6884:	81 4c 02 00 	mov	r12,	2(r1)	;
    6888:	81 4d 00 00 	mov	r13,	0(r1)	;

0000688c <.Loc.79.3>:

  return iqGetTimeout(&((SerialDriver *)ip)->iqueue, timeout);
    688c:	1c 41 02 00 	mov	2(r1),	r12	;
    6890:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6894:	2d 41       	mov	@r1,	r13	;
    6896:	b0 12 7c 62 	call	#25212		;#0x627c

0000689a <.Loc.80.3>:
}
    689a:	21 52       	add	#4,	r1	;r2 As==10
    689c:	30 41       	ret			

0000689e <writet>:

static size_t writet(void *ip, const uint8_t *bp, size_t n, systime_t timeout) {
    689e:	31 82       	sub	#8,	r1	;r2 As==11

000068a0 <.LCFI9>:
    68a0:	81 4c 06 00 	mov	r12,	6(r1)	;
    68a4:	81 4d 04 00 	mov	r13,	4(r1)	;
    68a8:	81 4e 02 00 	mov	r14,	2(r1)	;
    68ac:	81 4f 00 00 	mov	r15,	0(r1)	;

000068b0 <.Loc.84.3>:

  return oqWriteTimeout(&((SerialDriver *)ip)->oqueue, bp, n, timeout);
    68b0:	1c 41 06 00 	mov	6(r1),	r12	;
    68b4:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    68b8:	2f 41       	mov	@r1,	r15	;
    68ba:	1e 41 02 00 	mov	2(r1),	r14	;
    68be:	1d 41 04 00 	mov	4(r1),	r13	;
    68c2:	b0 12 00 66 	call	#26112		;#0x6600

000068c6 <.Loc.85.3>:
}
    68c6:	31 52       	add	#8,	r1	;r2 As==11
    68c8:	30 41       	ret			

000068ca <readt>:

static size_t readt(void *ip, uint8_t *bp, size_t n, systime_t timeout) {
    68ca:	31 82       	sub	#8,	r1	;r2 As==11

000068cc <.LCFI10>:
    68cc:	81 4c 06 00 	mov	r12,	6(r1)	;
    68d0:	81 4d 04 00 	mov	r13,	4(r1)	;
    68d4:	81 4e 02 00 	mov	r14,	2(r1)	;
    68d8:	81 4f 00 00 	mov	r15,	0(r1)	;

000068dc <.Loc.89.3>:

  return iqReadTimeout(&((SerialDriver *)ip)->iqueue, bp, n, timeout);
    68dc:	1c 41 06 00 	mov	6(r1),	r12	;
    68e0:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    68e4:	2f 41       	mov	@r1,	r15	;
    68e6:	1e 41 02 00 	mov	2(r1),	r14	;
    68ea:	1d 41 04 00 	mov	4(r1),	r13	;
    68ee:	b0 12 2c 63 	call	#25388		;#0x632c

000068f2 <.Loc.90.3>:
}
    68f2:	31 52       	add	#8,	r1	;r2 As==11
    68f4:	30 41       	ret			

000068f6 <sdInit>:
 *
 * @init
 */
void sdInit(void) {

  sd_lld_init();
    68f6:	b0 12 52 71 	call	#29010		;#0x7152

000068fa <.Loc.111.3>:
}
    68fa:	03 43       	nop			
    68fc:	30 41       	ret			

000068fe <sdObjectInit>:
 *                      some data is written in the Queue. The value can be
 *                      @p NULL.
 *
 * @init
 */
void sdObjectInit(SerialDriver *sdp, qnotify_t inotify, qnotify_t onotify) {
    68fe:	31 82       	sub	#8,	r1	;r2 As==11

00006900 <.LCFI11>:
    6900:	81 4c 06 00 	mov	r12,	6(r1)	;
    6904:	81 4d 04 00 	mov	r13,	4(r1)	;
    6908:	81 4e 02 00 	mov	r14,	2(r1)	;

0000690c <.Loc.130.3>:

  sdp->vmt = &vmt;
    690c:	1c 41 06 00 	mov	6(r1),	r12	;
    6910:	bc 40 3a 50 	mov	#20538,	0(r12)	;#0x503a
    6914:	00 00 

00006916 <.Loc.131.3>:
  osalEventObjectInit(&sdp->event);
    6916:	1c 41 06 00 	mov	6(r1),	r12	;
    691a:	2c 53       	incd	r12		;
    691c:	b0 12 58 67 	call	#26456		;#0x6758

00006920 <.Loc.132.3>:
  sdp->state = SD_STOP;
    6920:	1c 41 06 00 	mov	6(r1),	r12	;
    6924:	dc 43 0a 00 	mov.b	#1,	10(r12)	;r3 As==01, 0x000a

00006928 <.Loc.133.3>:
  iqObjectInit(&sdp->iqueue, sdp->ib, SERIAL_BUFFERS_SIZE, inotify, sdp);
    6928:	1c 41 06 00 	mov	6(r1),	r12	;
    692c:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    6930:	1d 41 06 00 	mov	6(r1),	r13	;
    6934:	3d 50 2c 00 	add	#44,	r13	;#0x002c
    6938:	91 41 06 00 	mov	6(r1),	0(r1)	;
    693c:	00 00 
    693e:	1f 41 04 00 	mov	4(r1),	r15	;
    6942:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6946:	b0 12 70 61 	call	#24944		;#0x6170

0000694a <.Loc.134.3>:
  oqObjectInit(&sdp->oqueue, sdp->ob, SERIAL_BUFFERS_SIZE, onotify, sdp);
    694a:	1c 41 06 00 	mov	6(r1),	r12	;
    694e:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    6952:	1d 41 06 00 	mov	6(r1),	r13	;
    6956:	3d 50 3c 00 	add	#60,	r13	;#0x003c
    695a:	91 41 06 00 	mov	6(r1),	0(r1)	;
    695e:	00 00 
    6960:	1f 41 02 00 	mov	2(r1),	r15	;
    6964:	7e 40 10 00 	mov.b	#16,	r14	;#0x0010
    6968:	b0 12 5a 64 	call	#25690		;#0x645a

0000696c <.Loc.135.3>:
}
    696c:	03 43       	nop			
    696e:	31 52       	add	#8,	r1	;r2 As==11
    6970:	30 41       	ret			

00006972 <sdStart>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @api
 */
void sdStart(SerialDriver *sdp, const SerialConfig *config) {
    6972:	21 82       	sub	#4,	r1	;r2 As==10

00006974 <.LCFI12>:
    6974:	81 4c 02 00 	mov	r12,	2(r1)	;
    6978:	81 4d 00 00 	mov	r13,	0(r1)	;

0000697c <.Loc.151.3>:

  osalDbgCheck(sdp != NULL);

  osalSysLock();
    697c:	b0 12 40 67 	call	#26432		;#0x6740

00006980 <.Loc.154.3>:
  osalDbgAssert((sdp->state == SD_STOP) || (sdp->state == SD_READY),
                "invalid state");
  sd_lld_start(sdp, config);
    6980:	2d 41       	mov	@r1,	r13	;
    6982:	1c 41 02 00 	mov	2(r1),	r12	;
    6986:	b0 12 64 71 	call	#29028		;#0x7164

0000698a <.Loc.155.3>:
  sdp->state = SD_READY;
    698a:	1c 41 02 00 	mov	2(r1),	r12	;
    698e:	ec 43 0a 00 	mov.b	#2,	10(r12)	;r3 As==10, 0x000a

00006992 <.Loc.156.3>:
  osalSysUnlock();
    6992:	b0 12 4c 67 	call	#26444		;#0x674c

00006996 <.Loc.157.3>:
}
    6996:	03 43       	nop			
    6998:	21 52       	add	#4,	r1	;r2 As==10
    699a:	30 41       	ret			

0000699c <sdIncomingDataI>:
 * @param[in] sdp       pointer to a @p SerialDriver structure
 * @param[in] b         the byte to be written in the driver's Input Queue
 *
 * @iclass
 */
void sdIncomingDataI(SerialDriver *sdp, uint8_t b) {
    699c:	21 82       	sub	#4,	r1	;r2 As==10

0000699e <.LCFI14>:
    699e:	81 4c 02 00 	mov	r12,	2(r1)	;
    69a2:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000069a6 <.Loc.201.3>:

  osalDbgCheckClassI();
    69a6:	b0 12 f2 5b 	call	#23538		;#0x5bf2

000069aa <.Loc.204.3>:
  osalDbgCheck(sdp != NULL);

  if (iqIsEmptyI(&sdp->iqueue))
    69aa:	1c 41 02 00 	mov	2(r1),	r12	;
    69ae:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    69b2:	0c 93       	cmp	#0,	r12	;r3 As==00
    69b4:	07 20       	jnz	$+16     	;abs 0x69c4

000069b6 <.Loc.205.3>:
    chnAddFlagsI(sdp, CHN_INPUT_AVAILABLE);
    69b6:	1c 41 02 00 	mov	2(r1),	r12	;
    69ba:	2c 53       	incd	r12		;
    69bc:	6d 42       	mov.b	#4,	r13	;r2 As==10
    69be:	4e 43       	clr.b	r14		;
    69c0:	b0 12 7a 67 	call	#26490		;#0x677a

000069c4 <.L31>:
  if (iqPutI(&sdp->iqueue, b) < MSG_OK)
    69c4:	1c 41 02 00 	mov	2(r1),	r12	;
    69c8:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    69cc:	5d 41 01 00 	mov.b	1(r1),	r13	;
    69d0:	b0 12 d8 61 	call	#25048		;#0x61d8
    69d4:	0c 93       	cmp	#0,	r12	;r3 As==00
    69d6:	08 34       	jge	$+18     	;abs 0x69e8

000069d8 <.Loc.207.3>:
    chnAddFlagsI(sdp, SD_OVERRUN_ERROR);
    69d8:	1c 41 02 00 	mov	2(r1),	r12	;
    69dc:	2c 53       	incd	r12		;
    69de:	7d 40 80 00 	mov.b	#128,	r13	;#0x0080
    69e2:	4e 43       	clr.b	r14		;
    69e4:	b0 12 7a 67 	call	#26490		;#0x677a

000069e8 <.L33>:
}
    69e8:	03 43       	nop			
    69ea:	21 52       	add	#4,	r1	;r2 As==10
    69ec:	30 41       	ret			

000069ee <sdRequestDataI>:
 * @retval MSG_TIMEOUT  if the queue is empty (the lower driver usually
 *                      disables the interrupt source when this happens).
 *
 * @iclass
 */
msg_t sdRequestDataI(SerialDriver *sdp) {
    69ee:	21 82       	sub	#4,	r1	;r2 As==10

000069f0 <.LCFI15>:
    69f0:	81 4c 00 00 	mov	r12,	0(r1)	;

000069f4 <.Loc.228.3>:
  msg_t  b;

  osalDbgCheckClassI();
    69f4:	b0 12 f2 5b 	call	#23538		;#0x5bf2

000069f8 <.Loc.231.3>:
  osalDbgCheck(sdp != NULL);

  b = oqGetI(&sdp->oqueue);
    69f8:	2c 41       	mov	@r1,	r12	;
    69fa:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    69fe:	b0 12 78 65 	call	#25976		;#0x6578
    6a02:	81 4c 02 00 	mov	r12,	2(r1)	;

00006a06 <.Loc.232.3>:
  if (b < MSG_OK)
    6a06:	81 93 02 00 	cmp	#0,	2(r1)	;r3 As==00
    6a0a:	06 34       	jge	$+14     	;abs 0x6a18

00006a0c <.Loc.233.3>:
    chnAddFlagsI(sdp, CHN_OUTPUT_EMPTY);
    6a0c:	2c 41       	mov	@r1,	r12	;
    6a0e:	2c 53       	incd	r12		;
    6a10:	7d 42       	mov.b	#8,	r13	;r2 As==11
    6a12:	4e 43       	clr.b	r14		;
    6a14:	b0 12 7a 67 	call	#26490		;#0x677a

00006a18 <.L35>:
  return b;
    6a18:	1c 41 02 00 	mov	2(r1),	r12	;

00006a1c <.Loc.235.3>:
}
    6a1c:	21 52       	add	#4,	r1	;r2 As==10
    6a1e:	30 41       	ret			

00006a20 <port_lock>:
/**
 * @brief   Kernel-lock action.
 */
static inline void port_lock(void) {

  _disable_interrupts();
    6a20:	32 c2       	dint			

00006a22 <.Loc.347.1>:
  asm volatile("nop");
    6a22:	03 43       	nop			

00006a24 <.Loc.348.1>:
}
    6a24:	03 43       	nop			
    6a26:	30 41       	ret			

00006a28 <port_unlock>:

/**
 * @brief   Kernel-unlock action.
 */
static inline void port_unlock(void) {
  asm volatile("nop");
    6a28:	03 43       	nop			

00006a2a <.Loc.355.1>:
  _enable_interrupts();
    6a2a:	32 d2       	eint			
    6a2c:	03 43       	nop			

00006a2e <.Loc.356.1>:
}
    6a2e:	03 43       	nop			
    6a30:	30 41       	ret			

00006a32 <osalSysLock>:
 *
 * @special
 */
static inline void osalSysLock(void) {

  chSysLock();
    6a32:	b0 12 20 6a 	call	#27168		;#0x6a20
    6a36:	b0 12 0c 5b 	call	#23308		;#0x5b0c

00006a3a <.Loc.505.2>:
}
    6a3a:	03 43       	nop			
    6a3c:	30 41       	ret			

00006a3e <osalSysUnlock>:
 *
 * @special
 */
static inline void osalSysUnlock(void) {

  chSysUnlock();
    6a3e:	b0 12 2c 5b 	call	#23340		;#0x5b2c
    6a42:	b0 12 28 6a 	call	#27176		;#0x6a28

00006a46 <.Loc.516.2>:
}
    6a46:	03 43       	nop			
    6a48:	30 41       	ret			

00006a4a <osalThreadSuspendS>:
 * @param[in] trp       a pointer to a thread reference object
 * @return              The wake up message.
 *
 * @sclass
 */
static inline msg_t osalThreadSuspendS(thread_reference_t *trp) {
    6a4a:	21 83       	decd	r1		;

00006a4c <.LCFI0>:
    6a4c:	81 4c 00 00 	mov	r12,	0(r1)	;

00006a50 <.Loc.699.2>:

  return chThdSuspendTimeoutS(trp, TIME_INFINITE);
    6a50:	4d 43       	clr.b	r13		;
    6a52:	2c 41       	mov	@r1,	r12	;
    6a54:	b0 12 6e 5e 	call	#24174		;#0x5e6e

00006a58 <.Loc.700.2>:
}
    6a58:	21 53       	incd	r1		;
    6a5a:	30 41       	ret			

00006a5c <spiInit>:
 *
 * @init
 */
void spiInit(void) {

  spi_lld_init();
    6a5c:	b0 12 34 79 	call	#31028		;#0x7934

00006a60 <.Loc.59.3>:
}
    6a60:	03 43       	nop			
    6a62:	30 41       	ret			

00006a64 <spiObjectInit>:
 *
 * @param[out] spip     pointer to the @p SPIDriver object
 *
 * @init
 */
void spiObjectInit(SPIDriver *spip) {
    6a64:	21 83       	decd	r1		;

00006a66 <.LCFI1>:
    6a66:	81 4c 00 00 	mov	r12,	0(r1)	;

00006a6a <.Loc.70.3>:

  spip->state = SPI_STOP;
    6a6a:	2c 41       	mov	@r1,	r12	;
    6a6c:	dc 43 00 00 	mov.b	#1,	0(r12)	;r3 As==01

00006a70 <.Loc.71.3>:
  spip->config = NULL;
    6a70:	2c 41       	mov	@r1,	r12	;
    6a72:	8c 43 02 00 	mov	#0,	2(r12)	;r3 As==00

00006a76 <.Loc.73.3>:
#if SPI_USE_WAIT == TRUE
  spip->thread = NULL;
    6a76:	2c 41       	mov	@r1,	r12	;
    6a78:	8c 43 04 00 	mov	#0,	4(r12)	;r3 As==00

00006a7c <.Loc.81.3>:
  osalMutexObjectInit(&spip->mutex);
#endif
#if defined(SPI_DRIVER_EXT_INIT_HOOK)
  SPI_DRIVER_EXT_INIT_HOOK(spip);
#endif
}
    6a7c:	03 43       	nop			
    6a7e:	21 53       	incd	r1		;
    6a80:	30 41       	ret			

00006a82 <spiStart>:
 * @param[in] spip      pointer to the @p SPIDriver object
 * @param[in] config    pointer to the @p SPIConfig object
 *
 * @api
 */
void spiStart(SPIDriver *spip, const SPIConfig *config) {
    6a82:	21 82       	sub	#4,	r1	;r2 As==10

00006a84 <.LCFI2>:
    6a84:	81 4c 02 00 	mov	r12,	2(r1)	;
    6a88:	81 4d 00 00 	mov	r13,	0(r1)	;

00006a8c <.Loc.95.3>:

  osalDbgCheck((spip != NULL) && (config != NULL));

  osalSysLock();
    6a8c:	b0 12 32 6a 	call	#27186		;#0x6a32

00006a90 <.Loc.98.3>:
  osalDbgAssert((spip->state == SPI_STOP) || (spip->state == SPI_READY),
                "invalid state");
  spip->config = config;
    6a90:	1c 41 02 00 	mov	2(r1),	r12	;
    6a94:	ac 41 02 00 	mov	@r1,	2(r12)	;

00006a98 <.Loc.99.3>:
  spi_lld_start(spip);
    6a98:	1c 41 02 00 	mov	2(r1),	r12	;
    6a9c:	b0 12 f8 79 	call	#31224		;#0x79f8

00006aa0 <.Loc.100.3>:
  spip->state = SPI_READY;
    6aa0:	1c 41 02 00 	mov	2(r1),	r12	;
    6aa4:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

00006aa8 <.Loc.101.3>:
  osalSysUnlock();
    6aa8:	b0 12 3e 6a 	call	#27198		;#0x6a3e

00006aac <.Loc.102.3>:
}
    6aac:	03 43       	nop			
    6aae:	21 52       	add	#4,	r1	;r2 As==10
    6ab0:	30 41       	ret			

00006ab2 <spiSelect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiSelect(SPIDriver *spip) {
    6ab2:	21 83       	decd	r1		;

00006ab4 <.LCFI4>:
    6ab4:	81 4c 00 00 	mov	r12,	0(r1)	;

00006ab8 <.Loc.136.3>:

  osalDbgCheck(spip != NULL);

  osalSysLock();
    6ab8:	b0 12 32 6a 	call	#27186		;#0x6a32

00006abc <.Loc.138.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiSelectI(spip);
    6abc:	2c 41       	mov	@r1,	r12	;
    6abe:	b0 12 02 7b 	call	#31490		;#0x7b02

00006ac2 <.Loc.139.3>:
  osalSysUnlock();
    6ac2:	b0 12 3e 6a 	call	#27198		;#0x6a3e

00006ac6 <.Loc.140.3>:
}
    6ac6:	03 43       	nop			
    6ac8:	21 53       	incd	r1		;
    6aca:	30 41       	ret			

00006acc <spiUnselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @api
 */
void spiUnselect(SPIDriver *spip) {
    6acc:	21 83       	decd	r1		;

00006ace <.LCFI5>:
    6ace:	81 4c 00 00 	mov	r12,	0(r1)	;

00006ad2 <.Loc.154.3>:

  osalDbgCheck(spip != NULL);

  osalSysLock();
    6ad2:	b0 12 32 6a 	call	#27186		;#0x6a32

00006ad6 <.Loc.156.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  spiUnselectI(spip);
    6ad6:	2c 41       	mov	@r1,	r12	;
    6ad8:	b0 12 62 7b 	call	#31586		;#0x7b62

00006adc <.Loc.157.3>:
  osalSysUnlock();
    6adc:	b0 12 3e 6a 	call	#27198		;#0x6a3e

00006ae0 <.Loc.158.3>:
}
    6ae0:	03 43       	nop			
    6ae2:	21 53       	incd	r1		;
    6ae4:	30 41       	ret			

00006ae6 <spiSend>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @api
 */
void spiSend(SPIDriver *spip, size_t n, const void *txbuf) {
    6ae6:	31 80 06 00 	sub	#6,	r1	;

00006aea <.LCFI12>:
    6aea:	81 4c 04 00 	mov	r12,	4(r1)	;
    6aee:	81 4d 02 00 	mov	r13,	2(r1)	;
    6af2:	81 4e 00 00 	mov	r14,	0(r1)	;

00006af6 <.Loc.341.3>:

  osalDbgCheck((spip != NULL) && (n > 0U) && (txbuf != NULL));

  osalSysLock();
    6af6:	b0 12 32 6a 	call	#27186		;#0x6a32

00006afa <.Loc.344.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartSendI(spip, n, txbuf);
    6afa:	1c 41 04 00 	mov	4(r1),	r12	;
    6afe:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    6b02:	00 00 
    6b04:	2e 41       	mov	@r1,	r14	;
    6b06:	1d 41 02 00 	mov	2(r1),	r13	;
    6b0a:	1c 41 04 00 	mov	4(r1),	r12	;
    6b0e:	b0 12 c0 7b 	call	#31680		;#0x7bc0

00006b12 <.Loc.345.3>:
  (void) osalThreadSuspendS(&spip->thread);
    6b12:	1c 41 04 00 	mov	4(r1),	r12	;
    6b16:	2c 52       	add	#4,	r12	;r2 As==10
    6b18:	b0 12 4a 6a 	call	#27210		;#0x6a4a

00006b1c <.Loc.346.3>:
  osalSysUnlock();
    6b1c:	b0 12 3e 6a 	call	#27198		;#0x6a3e

00006b20 <.Loc.347.3>:
}
    6b20:	03 43       	nop			
    6b22:	31 50 06 00 	add	#6,	r1	;
    6b26:	30 41       	ret			

00006b28 <spiReceive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @api
 */
void spiReceive(SPIDriver *spip, size_t n, void *rxbuf) {
    6b28:	31 80 06 00 	sub	#6,	r1	;

00006b2c <.LCFI13>:
    6b2c:	81 4c 04 00 	mov	r12,	4(r1)	;
    6b30:	81 4d 02 00 	mov	r13,	2(r1)	;
    6b34:	81 4e 00 00 	mov	r14,	0(r1)	;

00006b38 <.Loc.369.3>:

  osalDbgCheck((spip != NULL) && (n > 0U) && (rxbuf != NULL));

  osalSysLock();
    6b38:	b0 12 32 6a 	call	#27186		;#0x6a32

00006b3c <.Loc.372.3>:
  osalDbgAssert(spip->state == SPI_READY, "not ready");
  osalDbgAssert(spip->config->end_cb == NULL, "has callback");
  spiStartReceiveI(spip, n, rxbuf);
    6b3c:	1c 41 04 00 	mov	4(r1),	r12	;
    6b40:	fc 40 03 00 	mov.b	#3,	0(r12)	;
    6b44:	00 00 
    6b46:	2e 41       	mov	@r1,	r14	;
    6b48:	1d 41 02 00 	mov	2(r1),	r13	;
    6b4c:	1c 41 04 00 	mov	4(r1),	r12	;
    6b50:	b0 12 18 7c 	call	#31768		;#0x7c18

00006b54 <.Loc.373.3>:
  (void) osalThreadSuspendS(&spip->thread);
    6b54:	1c 41 04 00 	mov	4(r1),	r12	;
    6b58:	2c 52       	add	#4,	r12	;r2 As==10
    6b5a:	b0 12 4a 6a 	call	#27210		;#0x6a4a

00006b5e <.Loc.374.3>:
  osalSysUnlock();
    6b5e:	b0 12 3e 6a 	call	#27198		;#0x6a3e

00006b62 <.Loc.375.3>:
}
    6b62:	03 43       	nop			
    6b64:	31 50 06 00 	add	#6,	r1	;
    6b68:	30 41       	ret			

00006b6a <hal_lld_init>:
 * @notapi
 */
void hal_lld_init(void) {
  /* Disable watchdog */
  /* TODO Real watchdog support */
  WDTCTL = WDTPW | WDTHOLD;
    6b6a:	b2 40 80 5a 	mov	#23168,	&0x015c	;#0x5a80
    6b6e:	5c 01 

00006b70 <.Loc.61.1>:
  /* Init clock system */
  CSCTL0 = CSKEY; /* unlock clock system */
    6b70:	b2 40 00 a5 	mov	#42240,	&0x0160	;#0xa500
    6b74:	60 01 

00006b76 <.Loc.62.1>:
  CSCTL1 = MSP430X_DCOSEL;
    6b76:	b2 40 0c 00 	mov	#12,	&0x0162	;#0x000c
    6b7a:	62 01 

00006b7c <.Loc.63.1>:
  CSCTL2 = (MSP430X_ACLK_SRC << 8) | (MSP430X_SMCLK_SRC << 4) | (MSP430X_MCLK_SRC);
    6b7c:	b2 40 33 01 	mov	#307,	&0x0164	;#0x0133
    6b80:	64 01 

00006b82 <.Loc.64.1>:
  CSCTL3 = (DIVIDER(MSP430X_ACLK_DIV) << 8) | (DIVIDER(MSP430X_SMCLK_DIV) << 4) | (DIVIDER(MSP430X_MCLK_DIV));
    6b82:	82 43 66 01 	mov	#0,	&0x0166	;r3 As==00

00006b86 <.Loc.65.1>:
  CSCTL4 = (MSP430X_HFXTCLK_DRIVE << 14) | (MSP430X_HFXTCLK_BYPASS << 12) | (MSP430X_HFFREQ << 10) | HFXTOFF | \
    6b86:	b2 40 c9 c1 	mov	#49609,	&0x0168	;#0xc1c9
    6b8a:	68 01 

00006b8c <.Loc.67.1>:
           (MSP430X_LFXTCLK_DRIVE << 6) | (MSP430X_LFXTCLK_BYPASS << 4) | VLOOFF | LFXTOFF;
  CSCTL6 = (MODCLKREQEN) | (SMCLKREQEN) | (MCLKREQEN) | (ACLKREQEN);
    6b8c:	b2 40 0f 00 	mov	#15,	&0x016c	;#0x000f
    6b90:	6c 01 

00006b92 <.Loc.84.1>:
  do {
    CSCTL5 &= ~(LFXTOFFG);
    SFRIFG1 &= ~OFIFG;
  } while (SFRIFG1 & OFIFG);
  #endif
  CSCTL0_H = 0xFF; /* Lock clock system */
    6b92:	f2 43 61 01 	mov.b	#-1,	&0x0161	;r3 As==11

00006b96 <.Loc.85.1>:
}
    6b96:	03 43       	nop			
    6b98:	30 41       	ret			

00006b9a <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    6b9a:	03 43       	nop			
    6b9c:	30 41       	ret			

00006b9e <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    6b9e:	03 43       	nop			
    6ba0:	30 41       	ret			

00006ba2 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    6ba2:	b0 12 9a 6b 	call	#27546		;#0x6b9a
    6ba6:	b0 12 4e 5b 	call	#23374		;#0x5b4e

00006baa <.Loc.527.2>:
}
    6baa:	03 43       	nop			
    6bac:	30 41       	ret			

00006bae <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    6bae:	b0 12 70 5b 	call	#23408		;#0x5b70
    6bb2:	b0 12 9e 6b 	call	#27550		;#0x6b9e

00006bb6 <.Loc.538.2>:
}
    6bb6:	03 43       	nop			
    6bb8:	30 41       	ret			

00006bba <osalOsTimerHandlerI>:
 *          service from the HAL.
 */
#if (OSAL_ST_MODE != OSAL_ST_MODE_NONE) || defined(__DOXYGEN__)
static inline void osalOsTimerHandlerI(void) {

  chSysTimerHandlerI();
    6bba:	b0 12 fe 5c 	call	#23806		;#0x5cfe

00006bbe <.Loc.597.2>:
}
    6bbe:	03 43       	nop			
    6bc0:	30 41       	ret			

00006bc2 <ISR_MSP430X_ST_ISR>:

/**
 * @brief Timer handler for both modes
 */

PORT_IRQ_HANDLER( MSP430X_ST_ISR ) {
    6bc2:	bf 15       	pushm	#12,	r15	;16-bit words

00006bc4 <.LCFI0>:
  
  OSAL_IRQ_PROLOGUE();
    6bc4:	b0 12 94 5b 	call	#23444		;#0x5b94

00006bc8 <.Loc.170.3>:
  
  osalSysLockFromISR();
    6bc8:	b0 12 a2 6b 	call	#27554		;#0x6ba2

00006bcc <.Loc.171.3>:
  osalOsTimerHandlerI();
    6bcc:	b0 12 ba 6b 	call	#27578		;#0x6bba

00006bd0 <.Loc.172.3>:
  osalSysUnlockFromISR();
    6bd0:	b0 12 ae 6b 	call	#27566		;#0x6bae

00006bd4 <.Loc.174.3>:
  
  OSAL_IRQ_EPILOGUE();
    6bd4:	b0 12 c2 5b 	call	#23490		;#0x5bc2
    6bd8:	b0 12 0c 5b 	call	#23308		;#0x5b0c
    6bdc:	b0 12 ca 5d 	call	#24010		;#0x5dca
    6be0:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6be4:	0c 93       	cmp	#0,	r12	;r3 As==00
    6be6:	02 24       	jz	$+6      	;abs 0x6bec

00006be8 <.Loc.174.3>:
    6be8:	b0 12 e6 5d 	call	#24038		;#0x5de6

00006bec <.L7>:
    6bec:	b0 12 2c 5b 	call	#23340		;#0x5b2c

00006bf0 <.Loc.175.3>:
}
    6bf0:	03 43       	nop			
    6bf2:	b4 17       	popm	#12,	r15	;16-bit words
    6bf4:	00 13       	reti			

00006bf6 <st_lld_init>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_2 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_FREERUNNING */
  
  #if (OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC) || defined (__DOXYGEN__)
  /* Start enabled */
  MSP430X_ST_CCR(MSP430X_ST_TIMER) = MSP_TIMER_COUNTER - 1;
    6bf6:	b2 40 3f 1f 	mov	#7999,	&0x03d2	;#0x1f3f
    6bfa:	d2 03 

00006bfc <.Loc.198.3>:
  MSP430X_ST_CCTL(MSP430X_ST_TIMER) = CCIE;
    6bfc:	b2 40 10 00 	mov	#16,	&0x03c2	;#0x0010
    6c00:	c2 03 

00006c02 <.Loc.199.3>:
  MSP430X_ST_EX(MSP430X_ST_TIMER) = MSP430X_ST_DIV_EX_BITS;
    6c02:	82 43 e0 03 	mov	#0,	&0x03e0	;r3 As==00

00006c06 <.Loc.200.3>:
  MSP430X_ST_CTL(MSP430X_ST_TIMER) = (TACLR | MC_1 | MSP430X_ST_DIV_BITS | MSP430X_ST_TASSEL);
    6c06:	b2 40 14 02 	mov	#532,	&0x03c0	;#0x0214
    6c0a:	c0 03 

00006c0c <.Loc.202.3>:
  #endif /* OSAL_ST_MODE == OSAL_ST_MODE_PERIODIC */
}
    6c0c:	03 43       	nop			
    6c0e:	30 41       	ret			

00006c10 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    6c10:	03 43       	nop			
    6c12:	30 41       	ret			

00006c14 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    6c14:	03 43       	nop			
    6c16:	30 41       	ret			

00006c18 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    6c18:	b0 12 10 6c 	call	#27664		;#0x6c10
    6c1c:	b0 12 4e 5b 	call	#23374		;#0x5b4e

00006c20 <.Loc.527.2>:
}
    6c20:	03 43       	nop			
    6c22:	30 41       	ret			

00006c24 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    6c24:	b0 12 70 5b 	call	#23408		;#0x5b70
    6c28:	b0 12 14 6c 	call	#27668		;#0x6c14

00006c2c <.Loc.538.2>:
}
    6c2c:	03 43       	nop			
    6c2e:	30 41       	ret			

00006c30 <osalEventBroadcastFlagsI>:
 * @param[in] flags     flags to be ORed to the flags mask
 *
 * @iclass
 */
static inline void osalEventBroadcastFlagsI(event_source_t *esp,
                                            eventflags_t flags) {
    6c30:	0a 15       	pushm	#1,	r10	;16-bit words

00006c32 <.LCFI0>:
    6c32:	31 80 06 00 	sub	#6,	r1	;

00006c36 <.LCFI1>:
    6c36:	81 4c 04 00 	mov	r12,	4(r1)	;
    6c3a:	81 4d 00 00 	mov	r13,	0(r1)	;
    6c3e:	81 4e 02 00 	mov	r14,	2(r1)	;

00006c42 <.Loc.828.2>:

  osalDbgCheck(esp != NULL);

  esp->flags |= flags;
    6c42:	1c 41 04 00 	mov	4(r1),	r12	;
    6c46:	1d 4c 02 00 	mov	2(r12),	r13	;
    6c4a:	2c 4c       	mov	@r12,	r12	;
    6c4c:	2a 41       	mov	@r1,	r10	;
    6c4e:	0a dc       	bis	r12,	r10	;
    6c50:	1b 41 02 00 	mov	2(r1),	r11	;
    6c54:	0b dd       	bis	r13,	r11	;
    6c56:	1c 41 04 00 	mov	4(r1),	r12	;
    6c5a:	8c 4a 00 00 	mov	r10,	0(r12)	;
    6c5e:	8c 4b 02 00 	mov	r11,	2(r12)	;

00006c62 <.Loc.829.2>:
  if (esp->cb != NULL) {
    6c62:	1c 41 04 00 	mov	4(r1),	r12	;
    6c66:	1c 4c 04 00 	mov	4(r12),	r12	;
    6c6a:	0c 93       	cmp	#0,	r12	;r3 As==00
    6c6c:	07 24       	jz	$+16     	;abs 0x6c7c

00006c6e <.Loc.830.2>:
    esp->cb(esp);
    6c6e:	1c 41 04 00 	mov	4(r1),	r12	;
    6c72:	1d 4c 04 00 	mov	4(r12),	r13	;
    6c76:	1c 41 04 00 	mov	4(r1),	r12	;
    6c7a:	8d 12       	call	r13		;

00006c7c <.L7>:
  }
}
    6c7c:	03 43       	nop			
    6c7e:	31 50 06 00 	add	#6,	r1	;
    6c82:	0a 17       	popm	#1,	r10	;16-bit words
    6c84:	30 41       	ret			

00006c86 <UCBRS>:
 * @details   This function calculates the UCBRS value for oversampled baud
 *            rates.
 *
 * @param[in] frac    Fractional part of baud rate division, times 10000.
 */
static uint8_t UCBRS(uint16_t frac) {
    6c86:	21 83       	decd	r1		;

00006c88 <.LCFI2>:
    6c88:	81 4c 00 00 	mov	r12,	0(r1)	;

00006c8c <.Loc.107.3>:
  /* TODO there must be a better way */
  if (frac < 529)
    6c8c:	3c 40 10 02 	mov	#528,	r12	;#0x0210
    6c90:	2c 91       	cmp	@r1,	r12	;
    6c92:	02 28       	jnc	$+6      	;abs 0x6c98

00006c94 <.Loc.108.3>:
    return 0x00;
    6c94:	4c 43       	clr.b	r12		;
    6c96:	ec 3c       	jmp	$+474    	;abs 0x6e70

00006c98 <.L9>:
  else if (frac < 715)
    6c98:	3c 40 ca 02 	mov	#714,	r12	;#0x02ca
    6c9c:	2c 91       	cmp	@r1,	r12	;
    6c9e:	02 28       	jnc	$+6      	;abs 0x6ca4

00006ca0 <.Loc.110.3>:
    return 0x01;
    6ca0:	5c 43       	mov.b	#1,	r12	;r3 As==01
    6ca2:	e6 3c       	jmp	$+462    	;abs 0x6e70

00006ca4 <.L11>:
  else if (frac < 835)
    6ca4:	3c 40 42 03 	mov	#834,	r12	;#0x0342
    6ca8:	2c 91       	cmp	@r1,	r12	;
    6caa:	02 28       	jnc	$+6      	;abs 0x6cb0

00006cac <.Loc.112.3>:
    return 0x02;
    6cac:	6c 43       	mov.b	#2,	r12	;r3 As==10
    6cae:	e0 3c       	jmp	$+450    	;abs 0x6e70

00006cb0 <.L12>:
  else if (frac < 1001)
    6cb0:	3c 40 e8 03 	mov	#1000,	r12	;#0x03e8
    6cb4:	2c 91       	cmp	@r1,	r12	;
    6cb6:	02 28       	jnc	$+6      	;abs 0x6cbc

00006cb8 <.Loc.114.3>:
    return 0x04;
    6cb8:	6c 42       	mov.b	#4,	r12	;r2 As==10
    6cba:	da 3c       	jmp	$+438    	;abs 0x6e70

00006cbc <.L13>:
  else if (frac < 1252)
    6cbc:	3c 40 e3 04 	mov	#1251,	r12	;#0x04e3
    6cc0:	2c 91       	cmp	@r1,	r12	;
    6cc2:	02 28       	jnc	$+6      	;abs 0x6cc8

00006cc4 <.Loc.116.3>:
    return 0x08;
    6cc4:	7c 42       	mov.b	#8,	r12	;r2 As==11
    6cc6:	d4 3c       	jmp	$+426    	;abs 0x6e70

00006cc8 <.L14>:
  else if (frac < 1430)
    6cc8:	3c 40 95 05 	mov	#1429,	r12	;#0x0595
    6ccc:	2c 91       	cmp	@r1,	r12	;
    6cce:	03 28       	jnc	$+8      	;abs 0x6cd6

00006cd0 <.Loc.118.3>:
    return 0x10;
    6cd0:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    6cd4:	cd 3c       	jmp	$+412    	;abs 0x6e70

00006cd6 <.L15>:
  else if (frac < 1670)
    6cd6:	3c 40 85 06 	mov	#1669,	r12	;#0x0685
    6cda:	2c 91       	cmp	@r1,	r12	;
    6cdc:	03 28       	jnc	$+8      	;abs 0x6ce4

00006cde <.Loc.120.3>:
    return 0x20;
    6cde:	7c 40 20 00 	mov.b	#32,	r12	;#0x0020
    6ce2:	c6 3c       	jmp	$+398    	;abs 0x6e70

00006ce4 <.L16>:
  else if (frac < 2147)
    6ce4:	3c 40 62 08 	mov	#2146,	r12	;#0x0862
    6ce8:	2c 91       	cmp	@r1,	r12	;
    6cea:	03 28       	jnc	$+8      	;abs 0x6cf2

00006cec <.Loc.122.3>:
    return 0x11;
    6cec:	7c 40 11 00 	mov.b	#17,	r12	;#0x0011
    6cf0:	bf 3c       	jmp	$+384    	;abs 0x6e70

00006cf2 <.L17>:
  else if (frac < 2224)
    6cf2:	3c 40 af 08 	mov	#2223,	r12	;#0x08af
    6cf6:	2c 91       	cmp	@r1,	r12	;
    6cf8:	03 28       	jnc	$+8      	;abs 0x6d00

00006cfa <.Loc.124.3>:
    return 0x21;
    6cfa:	7c 40 21 00 	mov.b	#33,	r12	;#0x0021
    6cfe:	b8 3c       	jmp	$+370    	;abs 0x6e70

00006d00 <.L18>:
  else if (frac < 2503)
    6d00:	3c 40 c6 09 	mov	#2502,	r12	;#0x09c6
    6d04:	2c 91       	cmp	@r1,	r12	;
    6d06:	03 28       	jnc	$+8      	;abs 0x6d0e

00006d08 <.Loc.126.3>:
    return 0x22;
    6d08:	7c 40 22 00 	mov.b	#34,	r12	;#0x0022
    6d0c:	b1 3c       	jmp	$+356    	;abs 0x6e70

00006d0e <.L19>:
  else if (frac < 3000)
    6d0e:	3c 40 b7 0b 	mov	#2999,	r12	;#0x0bb7
    6d12:	2c 91       	cmp	@r1,	r12	;
    6d14:	03 28       	jnc	$+8      	;abs 0x6d1c

00006d16 <.Loc.128.3>:
    return 0x44;
    6d16:	7c 40 44 00 	mov.b	#68,	r12	;#0x0044
    6d1a:	aa 3c       	jmp	$+342    	;abs 0x6e70

00006d1c <.L20>:
  else if (frac < 3335)
    6d1c:	3c 40 06 0d 	mov	#3334,	r12	;#0x0d06
    6d20:	2c 91       	cmp	@r1,	r12	;
    6d22:	03 28       	jnc	$+8      	;abs 0x6d2a

00006d24 <.Loc.130.3>:
    return 0x25;
    6d24:	7c 40 25 00 	mov.b	#37,	r12	;#0x0025
    6d28:	a3 3c       	jmp	$+328    	;abs 0x6e70

00006d2a <.L21>:
  else if (frac < 3575)
    6d2a:	3c 40 f6 0d 	mov	#3574,	r12	;#0x0df6
    6d2e:	2c 91       	cmp	@r1,	r12	;
    6d30:	03 28       	jnc	$+8      	;abs 0x6d38

00006d32 <.Loc.132.3>:
    return 0x49;
    6d32:	7c 40 49 00 	mov.b	#73,	r12	;#0x0049
    6d36:	9c 3c       	jmp	$+314    	;abs 0x6e70

00006d38 <.L22>:
  else if (frac < 3753)
    6d38:	3c 40 a8 0e 	mov	#3752,	r12	;#0x0ea8
    6d3c:	2c 91       	cmp	@r1,	r12	;
    6d3e:	03 28       	jnc	$+8      	;abs 0x6d46

00006d40 <.Loc.134.3>:
    return 0x4A;
    6d40:	7c 40 4a 00 	mov.b	#74,	r12	;#0x004a
    6d44:	95 3c       	jmp	$+300    	;abs 0x6e70

00006d46 <.L23>:
  else if (frac < 4003)
    6d46:	3c 40 a2 0f 	mov	#4002,	r12	;#0x0fa2
    6d4a:	2c 91       	cmp	@r1,	r12	;
    6d4c:	03 28       	jnc	$+8      	;abs 0x6d54

00006d4e <.Loc.136.3>:
    return 0x52;
    6d4e:	7c 40 52 00 	mov.b	#82,	r12	;#0x0052
    6d52:	8e 3c       	jmp	$+286    	;abs 0x6e70

00006d54 <.L24>:
  else if (frac < 4286)
    6d54:	3c 40 bd 10 	mov	#4285,	r12	;#0x10bd
    6d58:	2c 91       	cmp	@r1,	r12	;
    6d5a:	03 28       	jnc	$+8      	;abs 0x6d62

00006d5c <.Loc.138.3>:
    return 0x92;
    6d5c:	7c 40 92 00 	mov.b	#146,	r12	;#0x0092
    6d60:	87 3c       	jmp	$+272    	;abs 0x6e70

00006d62 <.L25>:
  else if (frac < 4378)
    6d62:	3c 40 19 11 	mov	#4377,	r12	;#0x1119
    6d66:	2c 91       	cmp	@r1,	r12	;
    6d68:	03 28       	jnc	$+8      	;abs 0x6d70

00006d6a <.Loc.140.3>:
    return 0x53;
    6d6a:	7c 40 53 00 	mov.b	#83,	r12	;#0x0053
    6d6e:	80 3c       	jmp	$+258    	;abs 0x6e70

00006d70 <.L26>:
  else if (frac < 5002)
    6d70:	3c 40 89 13 	mov	#5001,	r12	;#0x1389
    6d74:	2c 91       	cmp	@r1,	r12	;
    6d76:	03 28       	jnc	$+8      	;abs 0x6d7e

00006d78 <.Loc.142.3>:
    return 0x55;
    6d78:	7c 40 55 00 	mov.b	#85,	r12	;#0x0055
    6d7c:	79 3c       	jmp	$+244    	;abs 0x6e70

00006d7e <.L27>:
  else if (frac < 5715)
    6d7e:	3c 40 52 16 	mov	#5714,	r12	;#0x1652
    6d82:	2c 91       	cmp	@r1,	r12	;
    6d84:	03 28       	jnc	$+8      	;abs 0x6d8c

00006d86 <.Loc.144.3>:
    return 0xAA;
    6d86:	7c 40 aa 00 	mov.b	#170,	r12	;#0x00aa
    6d8a:	72 3c       	jmp	$+230    	;abs 0x6e70

00006d8c <.L28>:
  else if (frac < 6003)
    6d8c:	3c 40 72 17 	mov	#6002,	r12	;#0x1772
    6d90:	2c 91       	cmp	@r1,	r12	;
    6d92:	03 28       	jnc	$+8      	;abs 0x6d9a

00006d94 <.Loc.146.3>:
    return 0x6B;
    6d94:	7c 40 6b 00 	mov.b	#107,	r12	;#0x006b
    6d98:	6b 3c       	jmp	$+216    	;abs 0x6e70

00006d9a <.L29>:
  else if (frac < 6254)
    6d9a:	3c 40 6d 18 	mov	#6253,	r12	;#0x186d
    6d9e:	2c 91       	cmp	@r1,	r12	;
    6da0:	03 28       	jnc	$+8      	;abs 0x6da8

00006da2 <.Loc.148.3>:
    return 0xAD;
    6da2:	7c 40 ad 00 	mov.b	#173,	r12	;#0x00ad
    6da6:	64 3c       	jmp	$+202    	;abs 0x6e70

00006da8 <.L30>:
  else if (frac < 6432)
    6da8:	3c 40 1f 19 	mov	#6431,	r12	;#0x191f
    6dac:	2c 91       	cmp	@r1,	r12	;
    6dae:	03 28       	jnc	$+8      	;abs 0x6db6

00006db0 <.Loc.150.3>:
    return 0xB5;
    6db0:	7c 40 b5 00 	mov.b	#181,	r12	;#0x00b5
    6db4:	5d 3c       	jmp	$+188    	;abs 0x6e70

00006db6 <.L31>:
  else if (frac < 6667)
    6db6:	3c 40 0a 1a 	mov	#6666,	r12	;#0x1a0a
    6dba:	2c 91       	cmp	@r1,	r12	;
    6dbc:	03 28       	jnc	$+8      	;abs 0x6dc4

00006dbe <.Loc.152.3>:
    return 0xB6;
    6dbe:	7c 40 b6 00 	mov.b	#182,	r12	;#0x00b6
    6dc2:	56 3c       	jmp	$+174    	;abs 0x6e70

00006dc4 <.L32>:
  else if (frac < 7001)
    6dc4:	3c 40 58 1b 	mov	#7000,	r12	;#0x1b58
    6dc8:	2c 91       	cmp	@r1,	r12	;
    6dca:	03 28       	jnc	$+8      	;abs 0x6dd2

00006dcc <.Loc.154.3>:
    return 0xD6;
    6dcc:	7c 40 d6 00 	mov.b	#214,	r12	;#0x00d6
    6dd0:	4f 3c       	jmp	$+160    	;abs 0x6e70

00006dd2 <.L33>:
  else if (frac < 7147)
    6dd2:	3c 40 ea 1b 	mov	#7146,	r12	;#0x1bea
    6dd6:	2c 91       	cmp	@r1,	r12	;
    6dd8:	03 28       	jnc	$+8      	;abs 0x6de0

00006dda <.Loc.156.3>:
    return 0xB7;
    6dda:	7c 40 b7 00 	mov.b	#183,	r12	;#0x00b7
    6dde:	48 3c       	jmp	$+146    	;abs 0x6e70

00006de0 <.L34>:
  else if (frac < 7503)
    6de0:	3c 40 4e 1d 	mov	#7502,	r12	;#0x1d4e
    6de4:	2c 91       	cmp	@r1,	r12	;
    6de6:	03 28       	jnc	$+8      	;abs 0x6dee

00006de8 <.Loc.158.3>:
    return 0xBB;
    6de8:	7c 40 bb 00 	mov.b	#187,	r12	;#0x00bb
    6dec:	41 3c       	jmp	$+132    	;abs 0x6e70

00006dee <.L35>:
  else if (frac < 7861)
    6dee:	3c 40 b4 1e 	mov	#7860,	r12	;#0x1eb4
    6df2:	2c 91       	cmp	@r1,	r12	;
    6df4:	03 28       	jnc	$+8      	;abs 0x6dfc

00006df6 <.Loc.160.3>:
    return 0xDD;
    6df6:	7c 40 dd 00 	mov.b	#221,	r12	;#0x00dd
    6dfa:	3a 3c       	jmp	$+118    	;abs 0x6e70

00006dfc <.L36>:
  else if (frac < 8004)
    6dfc:	3c 40 43 1f 	mov	#8003,	r12	;#0x1f43
    6e00:	2c 91       	cmp	@r1,	r12	;
    6e02:	03 28       	jnc	$+8      	;abs 0x6e0a

00006e04 <.Loc.162.3>:
    return 0xED;
    6e04:	7c 40 ed 00 	mov.b	#237,	r12	;#0x00ed
    6e08:	33 3c       	jmp	$+104    	;abs 0x6e70

00006e0a <.L37>:
  else if (frac < 8333)
    6e0a:	3c 40 8c 20 	mov	#8332,	r12	;#0x208c
    6e0e:	2c 91       	cmp	@r1,	r12	;
    6e10:	03 28       	jnc	$+8      	;abs 0x6e18

00006e12 <.Loc.164.3>:
    return 0xEE;
    6e12:	7c 40 ee 00 	mov.b	#238,	r12	;#0x00ee
    6e16:	2c 3c       	jmp	$+90     	;abs 0x6e70

00006e18 <.L38>:
  else if (frac < 8464)
    6e18:	3c 40 0f 21 	mov	#8463,	r12	;#0x210f
    6e1c:	2c 91       	cmp	@r1,	r12	;
    6e1e:	03 28       	jnc	$+8      	;abs 0x6e26

00006e20 <.Loc.166.3>:
    return 0xBF;
    6e20:	7c 40 bf 00 	mov.b	#191,	r12	;#0x00bf
    6e24:	25 3c       	jmp	$+76     	;abs 0x6e70

00006e26 <.L39>:
  else if (frac < 8572)
    6e26:	3c 40 7b 21 	mov	#8571,	r12	;#0x217b
    6e2a:	2c 91       	cmp	@r1,	r12	;
    6e2c:	03 28       	jnc	$+8      	;abs 0x6e34

00006e2e <.Loc.168.3>:
    return 0xDF;
    6e2e:	7c 40 df 00 	mov.b	#223,	r12	;#0x00df
    6e32:	1e 3c       	jmp	$+62     	;abs 0x6e70

00006e34 <.L40>:
  else if (frac < 8751)
    6e34:	3c 40 2e 22 	mov	#8750,	r12	;#0x222e
    6e38:	2c 91       	cmp	@r1,	r12	;
    6e3a:	03 28       	jnc	$+8      	;abs 0x6e42

00006e3c <.Loc.170.3>:
    return 0xEF;
    6e3c:	7c 40 ef 00 	mov.b	#239,	r12	;#0x00ef
    6e40:	17 3c       	jmp	$+48     	;abs 0x6e70

00006e42 <.L41>:
  else if (frac < 9004)
    6e42:	3c 40 2b 23 	mov	#9003,	r12	;#0x232b
    6e46:	2c 91       	cmp	@r1,	r12	;
    6e48:	03 28       	jnc	$+8      	;abs 0x6e50

00006e4a <.Loc.172.3>:
    return 0xF7;
    6e4a:	7c 40 f7 00 	mov.b	#247,	r12	;#0x00f7
    6e4e:	10 3c       	jmp	$+34     	;abs 0x6e70

00006e50 <.L42>:
  else if (frac < 9170)
    6e50:	3c 40 d1 23 	mov	#9169,	r12	;#0x23d1
    6e54:	2c 91       	cmp	@r1,	r12	;
    6e56:	03 28       	jnc	$+8      	;abs 0x6e5e

00006e58 <.Loc.174.3>:
    return 0xFB;
    6e58:	7c 40 fb 00 	mov.b	#251,	r12	;#0x00fb
    6e5c:	09 3c       	jmp	$+20     	;abs 0x6e70

00006e5e <.L43>:
  else if (frac < 9288)
    6e5e:	3c 40 47 24 	mov	#9287,	r12	;#0x2447
    6e62:	2c 91       	cmp	@r1,	r12	;
    6e64:	03 28       	jnc	$+8      	;abs 0x6e6c

00006e66 <.Loc.176.3>:
    return 0xFD;
    6e66:	7c 40 fd 00 	mov.b	#253,	r12	;#0x00fd
    6e6a:	02 3c       	jmp	$+6      	;abs 0x6e70

00006e6c <.L44>:
  else
    return 0xFE;
    6e6c:	7c 40 fe 00 	mov.b	#254,	r12	;#0x00fe

00006e70 <.L10>:
}
    6e70:	21 53       	incd	r1		;
    6e72:	30 41       	ret			

00006e74 <UCAxMCTLW>:
 *            input clock frequency and the requested baud rate.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxMCTLW(uint32_t baud, uint32_t freq) {
    6e74:	0a 15       	pushm	#1,	r10	;16-bit words

00006e76 <.LCFI3>:
    6e76:	31 80 0c 00 	sub	#12,	r1	;#0x000c

00006e7a <.LCFI4>:
    6e7a:	81 4c 04 00 	mov	r12,	4(r1)	;
    6e7e:	81 4d 06 00 	mov	r13,	6(r1)	;
    6e82:	81 4e 00 00 	mov	r14,	0(r1)	;
    6e86:	81 4f 02 00 	mov	r15,	2(r1)	;

00006e8a <.Loc.191.3>:

  uint16_t n = freq / baud;
    6e8a:	1e 41 04 00 	mov	4(r1),	r14	;
    6e8e:	1f 41 06 00 	mov	6(r1),	r15	;
    6e92:	2c 41       	mov	@r1,	r12	;
    6e94:	1d 41 02 00 	mov	2(r1),	r13	;
    6e98:	b0 12 c4 7e 	call	#32452		;#0x7ec4
    6e9c:	81 4c 0a 00 	mov	r12,	10(r1)	; 0x000a

00006ea0 <.Loc.193.3>:
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
    6ea0:	1e 41 0a 00 	mov	10(r1),	r14	;0x0000a
    6ea4:	0c 4e       	mov	r14,	r12	;
    6ea6:	0d 43       	clr	r13		;
    6ea8:	1e 41 04 00 	mov	4(r1),	r14	;
    6eac:	1f 41 06 00 	mov	6(r1),	r15	;
    6eb0:	b0 12 fa 7f 	call	#32762		;#0x7ffa
    6eb4:	0e 4c       	mov	r12,	r14	;
    6eb6:	0f 4d       	mov	r13,	r15	;
    6eb8:	2c 41       	mov	@r1,	r12	;

00006eba <L0>:
    6eba:	1d 41 02 00 	mov	2(r1),	r13	;
    6ebe:	0c 8e       	sub	r14,	r12	;
    6ec0:	0d 7f       	subc	r15,	r13	;
    6ec2:	3e 40 10 27 	mov	#10000,	r14	;#0x2710
    6ec6:	4f 43       	clr.b	r15		;
    6ec8:	b0 12 fa 7f 	call	#32762		;#0x7ffa
    6ecc:	1e 41 04 00 	mov	4(r1),	r14	;
    6ed0:	1f 41 06 00 	mov	6(r1),	r15	;
    6ed4:	b0 12 c4 7e 	call	#32452		;#0x7ec4
    6ed8:	81 4c 08 00 	mov	r12,	8(r1)	;

00006edc <.Loc.194.3>:
  if (n > 16) {
    6edc:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    6ee0:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    6ee4:	19 2c       	jc	$+52     	;abs 0x6f18

00006ee6 <.Loc.195.3>:
    while (n > 16) {
    6ee6:	03 3c       	jmp	$+8      	;abs 0x6eee

00006ee8 <.L48>:
      n -= 16;
    6ee8:	b1 50 f0 ff 	add	#65520,	10(r1)	;#0xfff0, 0x000a
    6eec:	0a 00 

00006eee <.L47>:

  uint16_t n = freq / baud;
  /*uint16_t frac = (freq * 10000 / baud) - ((freq / baud) * 10000);*/
  uint16_t frac = (freq - (n * baud)) * 10000 / baud;
  if (n > 16) {
    while (n > 16) {
    6eee:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    6ef2:	1c 91 0a 00 	cmp	10(r1),	r12	;0x0000a
    6ef6:	f8 2b       	jnc	$-14     	;abs 0x6ee8

00006ef8 <.Loc.198.3>:
      n -= 16;
    }
    return (UCBRS(frac) << 8) | (n << 4) | UCOS16;
    6ef8:	1c 41 08 00 	mov	8(r1),	r12	;
    6efc:	b0 12 86 6c 	call	#27782		;#0x6c86
    6f00:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6f04:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;
    6f08:	0a 4c       	mov	r12,	r10	;
    6f0a:	1c 41 0a 00 	mov	10(r1),	r12	;0x0000a
    6f0e:	b0 12 e8 7e 	call	#32488		;#0x7ee8
    6f12:	0c da       	bis	r10,	r12	;
    6f14:	1c d3       	bis	#1,	r12	;r3 As==01
    6f16:	08 3c       	jmp	$+18     	;abs 0x6f28

00006f18 <.L46>:
  }
  return UCBRS(frac) << 8;
    6f18:	1c 41 08 00 	mov	8(r1),	r12	;
    6f1c:	b0 12 86 6c 	call	#27782		;#0x6c86
    6f20:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    6f24:	47 18 0c 5c 	rpt #8 { rlax.w	r12		;

00006f28 <.L49>:
}
    6f28:	31 50 0c 00 	add	#12,	r1	;#0x000c
    6f2c:	0a 17       	popm	#1,	r10	;16-bit words
    6f2e:	30 41       	ret			

00006f30 <UCAxBRW>:
 *            rates.
 *
 * @param[in] baud    Requested baud rate
 * @param[in] freq    Frequency of the clock driving the USCI module
 */
static uint16_t UCAxBRW(uint32_t baud, uint32_t freq) {
    6f30:	31 80 0a 00 	sub	#10,	r1	;#0x000a

00006f34 <L0>:
    6f34:	81 4c 04 00 	mov	r12,	4(r1)	;
    6f38:	81 4d 06 00 	mov	r13,	6(r1)	;
    6f3c:	81 4e 00 00 	mov	r14,	0(r1)	;
    6f40:	81 4f 02 00 	mov	r15,	2(r1)	;

00006f44 <.Loc.212.3>:
  uint16_t n = freq / baud;
    6f44:	1e 41 04 00 	mov	4(r1),	r14	;
    6f48:	1f 41 06 00 	mov	6(r1),	r15	;
    6f4c:	2c 41       	mov	@r1,	r12	;
    6f4e:	1d 41 02 00 	mov	2(r1),	r13	;
    6f52:	b0 12 c4 7e 	call	#32452		;#0x7ec4
    6f56:	81 4c 08 00 	mov	r12,	8(r1)	;

00006f5a <.Loc.213.3>:
  if (n > 16) {
    6f5a:	7c 40 10 00 	mov.b	#16,	r12	;#0x0010
    6f5e:	1c 91 08 00 	cmp	8(r1),	r12	;
    6f62:	05 2c       	jc	$+12     	;abs 0x6f6e

00006f64 <.Loc.214.3>:
    return n >> 4;
    6f64:	1c 41 08 00 	mov	8(r1),	r12	;
    6f68:	b0 12 72 7f 	call	#32626		;#0x7f72
    6f6c:	02 3c       	jmp	$+6      	;abs 0x6f72

00006f6e <.L51>:
  }
  return n;
    6f6e:	1c 41 08 00 	mov	8(r1),	r12	;

00006f72 <.L52>:
}
    6f72:	31 50 0a 00 	add	#10,	r1	;#0x000a
    6f76:	30 41       	ret			

00006f78 <usart0_init>:

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void usart0_init(const SerialConfig * config) {
    6f78:	21 83       	decd	r1		;

00006f7a <L0>:
    6f7a:	81 4c 00 00 	mov	r12,	0(r1)	;

00006f7e <.Loc.221.3>:
  UCA0BRW   = UCAxBRW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    6f7e:	2c 41       	mov	@r1,	r12	;
    6f80:	1d 4c 02 00 	mov	2(r12),	r13	;
    6f84:	2c 4c       	mov	@r12,	r12	;
    6f86:	3e 40 00 12 	mov	#4608,	r14	;#0x1200
    6f8a:	7f 40 7a 00 	mov.b	#122,	r15	;#0x007a
    6f8e:	b0 12 30 6f 	call	#28464		;#0x6f30
    6f92:	82 4c c6 05 	mov	r12,	&0x05c6	;

00006f96 <.Loc.222.3>:
  UCA0MCTLW = UCAxMCTLW(config->sc_bitrate, MSP430X_USART0_CLK_FREQ);
    6f96:	2c 41       	mov	@r1,	r12	;
    6f98:	1d 4c 02 00 	mov	2(r12),	r13	;
    6f9c:	2c 4c       	mov	@r12,	r12	;
    6f9e:	3e 40 00 12 	mov	#4608,	r14	;#0x1200
    6fa2:	7f 40 7a 00 	mov.b	#122,	r15	;#0x007a
    6fa6:	b0 12 74 6e 	call	#28276		;#0x6e74
    6faa:	82 4c c8 05 	mov	r12,	&0x05c8	;

00006fae <.Loc.223.3>:
  UCA0STATW = 0;
    6fae:	c2 43 ca 05 	mov.b	#0,	&0x05ca	;r3 As==00

00006fb2 <.Loc.224.3>:
  UCA0ABCTL = 0;
    6fb2:	c2 43 d0 05 	mov.b	#0,	&0x05d0	;r3 As==00

00006fb6 <.Loc.225.3>:
  UCA0IRCTL = 0;
    6fb6:	82 43 d2 05 	mov	#0,	&0x05d2	;r3 As==00

00006fba <.Loc.226.3>:
  UCA0CTLW0 = (MSP430X_USART0_PARITY << 14) | (MSP430X_USART0_ORDER << 13) |
    6fba:	b2 40 80 00 	mov	#128,	&0x05c0	;#0x0080
    6fbe:	c0 05 

00006fc0 <.Loc.229.3>:
              (MSP430X_USART0_SIZE << 12) | (MSP430X_USART0_STOP << 11) |
              (MSP430X_USART0_UCSSEL);
  UCA0IE = UCRXIE;
    6fc0:	92 43 da 05 	mov	#1,	&0x05da	;r3 As==01

00006fc4 <.Loc.230.3>:
}
    6fc4:	03 43       	nop			
    6fc6:	21 53       	incd	r1		;
    6fc8:	30 41       	ret			

00006fca <notify0>:
  UCA3IE = UCRXIE;
}
#endif

#if (MSP430X_SERIAL_USE_USART0 == TRUE) || defined(__DOXYGEN__)
static void notify0(io_queue_t * qp) {
    6fca:	21 83       	decd	r1		;

00006fcc <.LCFI7>:
    6fcc:	81 4c 00 00 	mov	r12,	0(r1)	;

00006fd0 <.Loc.279.3>:

  (void)qp;
  UCA0IE |= UCTXIE;
    6fd0:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    6fd4:	2c d3       	bis	#2,	r12	;r3 As==10
    6fd6:	82 4c da 05 	mov	r12,	&0x05da	;

00006fda <.Loc.280.3>:
}
    6fda:	03 43       	nop			
    6fdc:	21 53       	incd	r1		;
    6fde:	30 41       	ret			

00006fe0 <set_error>:
 * @brief     Error handling routine.
 *
 * @param[in] sra     USCI status register containing errors
 * @param[in] sdp     pointer to a @p SerialDriver object
 */
static void set_error(uint16_t sra, SerialDriver * sdp) {
    6fe0:	31 82       	sub	#8,	r1	;r2 As==11

00006fe2 <.LCFI8>:
    6fe2:	81 4c 02 00 	mov	r12,	2(r1)	;
    6fe6:	81 4d 00 00 	mov	r13,	0(r1)	;

00006fea <.Loc.314.3>:
  eventflags_t sts = 0;
    6fea:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00
    6fee:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

00006ff2 <.Loc.316.3>:

  if (sra & UCOE)
    6ff2:	1c 41 02 00 	mov	2(r1),	r12	;
    6ff6:	7c f0 20 00 	and.b	#32,	r12	;#0x0020
    6ffa:	0c 93       	cmp	#0,	r12	;r3 As==00
    6ffc:	05 24       	jz	$+12     	;abs 0x7008

00006ffe <.Loc.317.3>:
    sts |= SD_OVERRUN_ERROR;
    6ffe:	b1 d0 80 00 	bis	#128,	4(r1)	;#0x0080
    7002:	04 00 
    7004:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007008 <.L56>:
  if (sra & UCPE)
    7008:	1c 41 02 00 	mov	2(r1),	r12	;
    700c:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7010:	0c 93       	cmp	#0,	r12	;r3 As==00
    7012:	05 24       	jz	$+12     	;abs 0x701e

00007014 <.Loc.319.3>:
    sts |= SD_PARITY_ERROR;
    7014:	b1 d0 20 00 	bis	#32,	4(r1)	;#0x0020
    7018:	04 00 
    701a:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

0000701e <.L57>:
  if (sra & UCFE)
    701e:	1c 41 02 00 	mov	2(r1),	r12	;
    7022:	7c f0 40 00 	and.b	#64,	r12	;#0x0040
    7026:	0c 93       	cmp	#0,	r12	;r3 As==00
    7028:	05 24       	jz	$+12     	;abs 0x7034

0000702a <.Loc.321.3>:
    sts |= SD_FRAMING_ERROR;
    702a:	b1 d0 40 00 	bis	#64,	4(r1)	;#0x0040
    702e:	04 00 
    7030:	81 d3 06 00 	bis	#0,	6(r1)	;r3 As==00

00007034 <.L58>:
  osalSysLockFromISR();
    7034:	b0 12 18 6c 	call	#27672		;#0x6c18

00007038 <.Loc.323.3>:
  chnAddFlagsI(sdp, sts);
    7038:	2c 41       	mov	@r1,	r12	;
    703a:	2c 53       	incd	r12		;
    703c:	1d 41 04 00 	mov	4(r1),	r13	;
    7040:	1e 41 06 00 	mov	6(r1),	r14	;
    7044:	b0 12 30 6c 	call	#27696		;#0x6c30

00007048 <.Loc.324.3>:
  osalSysUnlockFromISR();
    7048:	b0 12 24 6c 	call	#27684		;#0x6c24

0000704c <.Loc.325.3>:
}
    704c:	03 43       	nop			
    704e:	31 52       	add	#8,	r1	;r2 As==11
    7050:	30 41       	ret			

00007052 <ISR_USCI_A0_VECTOR>:
/**
 * @brief   USART0 interrupt handler.
 *
 * @isr
 */
PORT_IRQ_HANDLER(USCI_A0_VECTOR) {
    7052:	bf 15       	pushm	#12,	r15	;16-bit words

00007054 <.LCFI9>:
    7054:	21 83       	decd	r1		;

00007056 <.LCFI10>:
  msg_t b;

  OSAL_IRQ_PROLOGUE();
    7056:	b0 12 94 5b 	call	#23444		;#0x5b94

0000705a <.Loc.342.3>:

  switch (__even_in_range(UCA0IV, USCI_UART_UCTXCPTIFG)) {
    705a:	1c 42 de 05 	mov	&0x05de,r12	;0x05de
    705e:	2c 92       	cmp	#4,	r12	;r2 As==10
    7060:	1e 24       	jz	$+62     	;abs 0x709e
    7062:	3c 92       	cmp	#8,	r12	;r2 As==11
    7064:	40 24       	jz	$+130    	;abs 0x70e6
    7066:	2c 93       	cmp	#2,	r12	;r3 As==10
    7068:	01 24       	jz	$+4      	;abs 0x706c
    706a:	60 3c       	jmp	$+194    	;abs 0x712c

0000706c <.L63>:
  case USCI_UART_UCRXIFG: /* RX interrupt */

    /* Detect errors */
    if (UCA0STATW & UCRXERR)
    706c:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    7070:	6c f2       	and.b	#4,	r12	;r2 As==10
    7072:	0c 93       	cmp	#0,	r12	;r3 As==00
    7074:	06 24       	jz	$+14     	;abs 0x7082

00007076 <.Loc.347.3>:
      set_error(UCA0STATW, &SD0);
    7076:	5c 42 ca 05 	mov.b	&0x05ca,r12	;0x05ca
    707a:	3d 40 ac 51 	mov	#20908,	r13	;#0x51ac
    707e:	b0 12 e0 6f 	call	#28640		;#0x6fe0

00007082 <.L64>:

    /* Data available */
    osalSysLockFromISR();
    7082:	b0 12 18 6c 	call	#27672		;#0x6c18

00007086 <.Loc.351.3>:
    sdIncomingDataI(&SD0, UCA0RXBUF);
    7086:	1c 42 cc 05 	mov	&0x05cc,r12	;0x05cc
    708a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    708e:	4d 4c       	mov.b	r12,	r13	;
    7090:	3c 40 ac 51 	mov	#20908,	r12	;#0x51ac
    7094:	b0 12 9c 69 	call	#27036		;#0x699c

00007098 <.Loc.352.3>:
    osalSysUnlockFromISR();
    7098:	b0 12 24 6c 	call	#27684		;#0x6c24

0000709c <.Loc.353.3>:
    break;
    709c:	48 3c       	jmp	$+146    	;abs 0x712e

0000709e <.L61>:

  case USCI_UART_UCTXIFG: /* TX interrupt */

    /* Transmission buffer empty */
    osalSysLockFromISR();
    709e:	b0 12 18 6c 	call	#27672		;#0x6c18

000070a2 <.Loc.359.3>:
    b = sdRequestDataI(&SD0);
    70a2:	3c 40 ac 51 	mov	#20908,	r12	;#0x51ac
    70a6:	b0 12 ee 69 	call	#27118		;#0x69ee
    70aa:	81 4c 00 00 	mov	r12,	0(r1)	;

000070ae <.Loc.360.3>:
    if (b < Q_OK) {
    70ae:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    70b2:	13 34       	jge	$+40     	;abs 0x70da

000070b4 <.Loc.361.3>:
      chnAddFlagsI(&SD0, CHN_OUTPUT_EMPTY);
    70b4:	7d 42       	mov.b	#8,	r13	;r2 As==11
    70b6:	4e 43       	clr.b	r14		;
    70b8:	3c 40 ae 51 	mov	#20910,	r12	;#0x51ae
    70bc:	b0 12 30 6c 	call	#27696		;#0x6c30

000070c0 <.Loc.362.3>:
      UCA0IE = (UCA0IE & ~UCTXIE) | UCTXCPTIE;
    70c0:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    70c4:	3c f0 f5 ff 	and	#65525,	r12	;#0xfff5
    70c8:	3c d2       	bis	#8,	r12	;r2 As==11
    70ca:	82 4c da 05 	mov	r12,	&0x05da	;

000070ce <.Loc.363.3>:
      UCA0IFG |= UCTXIFG; /* If we don't write to TXBUF, IFG won't get set */
    70ce:	1c 42 dc 05 	mov	&0x05dc,r12	;0x05dc
    70d2:	2c d3       	bis	#2,	r12	;r3 As==10
    70d4:	82 4c dc 05 	mov	r12,	&0x05dc	;
    70d8:	03 3c       	jmp	$+8      	;abs 0x70e0

000070da <.L66>:
    }
    else
      UCA0TXBUF = b;
    70da:	2c 41       	mov	@r1,	r12	;
    70dc:	82 4c ce 05 	mov	r12,	&0x05ce	;

000070e0 <.L67>:
    osalSysUnlockFromISR();
    70e0:	b0 12 24 6c 	call	#27684		;#0x6c24

000070e4 <.Loc.368.3>:
    break;
    70e4:	24 3c       	jmp	$+74     	;abs 0x712e

000070e6 <.L62>:

  case USCI_UART_UCTXCPTIFG: /* TX complete interrupt */

    /* Physical transmission end */
    osalSysLockFromISR();
    70e6:	b0 12 18 6c 	call	#27672		;#0x6c18

000070ea <.Loc.374.3>:
    if (oqIsEmptyI(&SD0.oqueue))
    70ea:	1d 42 d0 51 	mov	&0x51d0,r13	;0x51d0
    70ee:	1c 42 d2 51 	mov	&0x51d2,r12	;0x51d2
    70f2:	0d 9c       	cmp	r12,	r13	;
    70f4:	06 20       	jnz	$+14     	;abs 0x7102

000070f6 <.Loc.374.3>:
    70f6:	1c 42 ca 51 	mov	&0x51ca,r12	;0x51ca
    70fa:	0c 93       	cmp	#0,	r12	;r3 As==00
    70fc:	02 24       	jz	$+6      	;abs 0x7102

000070fe <.Loc.374.3>:
    70fe:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7100:	01 3c       	jmp	$+4      	;abs 0x7104

00007102 <.L68>:
    7102:	4c 43       	clr.b	r12		;

00007104 <.L69>:
    7104:	5c f3       	and.b	#1,	r12	;r3 As==01
    7106:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    710a:	0c 93       	cmp	#0,	r12	;r3 As==00
    710c:	07 24       	jz	$+16     	;abs 0x711c

0000710e <.Loc.375.3>:
      chnAddFlagsI(&SD0, CHN_TRANSMISSION_END);
    710e:	7d 40 10 00 	mov.b	#16,	r13	;#0x0010
    7112:	4e 43       	clr.b	r14		;
    7114:	3c 40 ae 51 	mov	#20910,	r12	;#0x51ae
    7118:	b0 12 30 6c 	call	#27696		;#0x6c30

0000711c <.L70>:
    UCA0IE &= ~UCTXCPTIE;
    711c:	1c 42 da 05 	mov	&0x05da,r12	;0x05da
    7120:	3c c2       	bic	#8,	r12	;r2 As==11
    7122:	82 4c da 05 	mov	r12,	&0x05da	;

00007126 <.Loc.377.3>:
    osalSysUnlockFromISR();
    7126:	b0 12 24 6c 	call	#27684		;#0x6c24

0000712a <.Loc.378.3>:
    break;
    712a:	01 3c       	jmp	$+4      	;abs 0x712e

0000712c <.L60>:

  default: /* other interrupts */
    while (1)
    712c:	ff 3f       	jmp	$+0      	;abs 0x712c

0000712e <.L65>:
      ;
    break;
  }

  OSAL_IRQ_EPILOGUE();
    712e:	b0 12 c2 5b 	call	#23490		;#0x5bc2
    7132:	b0 12 0c 5b 	call	#23308		;#0x5b0c
    7136:	b0 12 ca 5d 	call	#24010		;#0x5dca
    713a:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    713e:	0c 93       	cmp	#0,	r12	;r3 As==00
    7140:	02 24       	jz	$+6      	;abs 0x7146

00007142 <.Loc.386.3>:
    7142:	b0 12 e6 5d 	call	#24038		;#0x5de6

00007146 <.L71>:
    7146:	b0 12 2c 5b 	call	#23340		;#0x5b2c

0000714a <.Loc.387.3>:
}
    714a:	03 43       	nop			
    714c:	21 53       	incd	r1		;
    714e:	b4 17       	popm	#12,	r15	;16-bit words
    7150:	00 13       	reti			

00007152 <sd_lld_init>:
 * @notapi
 */
void sd_lld_init(void) {

#if MSP430X_SERIAL_USE_USART0 == TRUE
  sdObjectInit(&SD0, NULL, notify0);
    7152:	3e 40 ca 6f 	mov	#28618,	r14	;#0x6fca
    7156:	4d 43       	clr.b	r13		;
    7158:	3c 40 ac 51 	mov	#20908,	r12	;#0x51ac
    715c:	b0 12 fe 68 	call	#26878		;#0x68fe

00007160 <L0>:
#endif

#if MSP430X_SERIAL_USE_USART3 == TRUE
  sdObjectInit(&SD3, NULL, notify3);
#endif
}
    7160:	03 43       	nop			
    7162:	30 41       	ret			

00007164 <sd_lld_start>:
 *                      If this parameter is set to @p NULL then a default
 *                      configuration is used.
 *
 * @notapi
 */
void sd_lld_start(SerialDriver * sdp, const SerialConfig * config) {
    7164:	21 82       	sub	#4,	r1	;r2 As==10

00007166 <.LCFI11>:
    7166:	81 4c 02 00 	mov	r12,	2(r1)	;
    716a:	81 4d 00 00 	mov	r13,	0(r1)	;

0000716e <.Loc.604.3>:

  if (config == NULL) {
    716e:	81 93 00 00 	cmp	#0,	0(r1)	;r3 As==00
    7172:	03 20       	jnz	$+8      	;abs 0x717a

00007174 <.Loc.605.3>:
    config = &default_config;
    7174:	b1 40 4a 50 	mov	#20554,	0(r1)	;#0x504a
    7178:	00 00 

0000717a <.L74>:
  }

  if (sdp->state == SD_STOP) {
    717a:	1c 41 02 00 	mov	2(r1),	r12	;
    717e:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    7182:	5c 93       	cmp.b	#1,	r12	;r3 As==01
    7184:	07 20       	jnz	$+16     	;abs 0x7194

00007186 <.Loc.610.3>:
#if MSP430X_SERIAL_USE_USART0 == TRUE
    if (&SD0 == sdp) {
    7186:	b1 90 ac 51 	cmp	#20908,	2(r1)	;#0x51ac
    718a:	02 00 
    718c:	03 20       	jnz	$+8      	;abs 0x7194

0000718e <.Loc.611.3>:
      usart0_init(config);
    718e:	2c 41       	mov	@r1,	r12	;
    7190:	b0 12 78 6f 	call	#28536		;#0x6f78

00007194 <.L76>:
    if (&SD3 == sdp) {
      usart3_init(config);
    }
#endif
  }
}
    7194:	03 43       	nop			
    7196:	21 52       	add	#4,	r1	;r2 As==10
    7198:	30 41       	ret			

0000719a <_pal_lld_init>:
 *
 * @param[in] config    the MSP430X ports configuration
 *
 * @notapi
 */
void _pal_lld_init(const PALConfig *config) {
    719a:	21 83       	decd	r1		;

0000719c <.LCFI0>:
    719c:	81 4c 00 00 	mov	r12,	0(r1)	;

000071a0 <.Loc.64.1>:

#if defined(PA_BASE) || defined(__DOXYGEN__)
  PAOUT = config->porta.out;
    71a0:	2c 41       	mov	@r1,	r12	;
    71a2:	2c 4c       	mov	@r12,	r12	;
    71a4:	82 4c 02 02 	mov	r12,	&0x0202	;

000071a8 <.Loc.65.1>:
  PADIR = config->porta.dir;
    71a8:	2c 41       	mov	@r1,	r12	;
    71aa:	1c 4c 02 00 	mov	2(r12),	r12	;
    71ae:	82 4c 04 02 	mov	r12,	&0x0204	;

000071b2 <.Loc.66.1>:
  PAREN = config->porta.ren;
    71b2:	2c 41       	mov	@r1,	r12	;
    71b4:	1c 4c 04 00 	mov	4(r12),	r12	;
    71b8:	82 4c 06 02 	mov	r12,	&0x0206	;

000071bc <.Loc.67.1>:
  PASEL0 = config->porta.sel0;
    71bc:	2c 41       	mov	@r1,	r12	;
    71be:	1c 4c 06 00 	mov	6(r12),	r12	;
    71c2:	82 4c 0a 02 	mov	r12,	&0x020a	;

000071c6 <.Loc.68.1>:
  PASEL1 = config->porta.sel1;
    71c6:	2c 41       	mov	@r1,	r12	;
    71c8:	1c 4c 08 00 	mov	8(r12),	r12	;
    71cc:	82 4c 0c 02 	mov	r12,	&0x020c	;

000071d0 <.Loc.69.1>:
  PAIES = config->porta.ies;
    71d0:	2c 41       	mov	@r1,	r12	;
    71d2:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    71d6:	82 4c 18 02 	mov	r12,	&0x0218	;

000071da <.Loc.70.1>:
  PAIE = config->porta.ie;
    71da:	2c 41       	mov	@r1,	r12	;
    71dc:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    71e0:	82 4c 1a 02 	mov	r12,	&0x021a	;

000071e4 <.Loc.71.1>:
  PAIFG = 0;
    71e4:	82 43 1c 02 	mov	#0,	&0x021c	;r3 As==00

000071e8 <.Loc.74.1>:
#endif
#if defined(PB_BASE) || defined(__DOXYGEN__)
  PBOUT = config->portb.out;
    71e8:	2c 41       	mov	@r1,	r12	;
    71ea:	1c 4c 0e 00 	mov	14(r12),r12	;0x0000e
    71ee:	82 4c 22 02 	mov	r12,	&0x0222	;

000071f2 <.Loc.75.1>:
  PBDIR = config->portb.dir;
    71f2:	2c 41       	mov	@r1,	r12	;
    71f4:	1c 4c 10 00 	mov	16(r12),r12	;0x00010
    71f8:	82 4c 24 02 	mov	r12,	&0x0224	;

000071fc <.Loc.76.1>:
  PBREN = config->portb.ren;
    71fc:	2c 41       	mov	@r1,	r12	;
    71fe:	1c 4c 12 00 	mov	18(r12),r12	;0x00012
    7202:	82 4c 26 02 	mov	r12,	&0x0226	;

00007206 <.Loc.77.1>:
  PBSEL0 = config->portb.sel0;
    7206:	2c 41       	mov	@r1,	r12	;
    7208:	1c 4c 14 00 	mov	20(r12),r12	;0x00014
    720c:	82 4c 2a 02 	mov	r12,	&0x022a	;

00007210 <.Loc.78.1>:
  PBSEL1 = config->portb.sel1;
    7210:	2c 41       	mov	@r1,	r12	;
    7212:	1c 4c 16 00 	mov	22(r12),r12	;0x00016
    7216:	82 4c 2c 02 	mov	r12,	&0x022c	;

0000721a <.Loc.79.1>:
  PBIES = config->portb.ies;
    721a:	2c 41       	mov	@r1,	r12	;
    721c:	1c 4c 18 00 	mov	24(r12),r12	;0x00018
    7220:	82 4c 38 02 	mov	r12,	&0x0238	;

00007224 <.Loc.80.1>:
  PBIE = config->portb.ie;
    7224:	2c 41       	mov	@r1,	r12	;
    7226:	1c 4c 1a 00 	mov	26(r12),r12	;0x0001a
    722a:	82 4c 3a 02 	mov	r12,	&0x023a	;

0000722e <.Loc.81.1>:
  PBIFG = 0;
    722e:	82 43 3c 02 	mov	#0,	&0x023c	;r3 As==00

00007232 <.Loc.131.1>:
  PFIES = config->portf.ies;
  PFIE = config->portf.ie;
  PFIFG = 0;
#endif
#endif
  PJOUT = config->portj.out;
    7232:	2c 41       	mov	@r1,	r12	;
    7234:	1c 4c 1c 00 	mov	28(r12),r12	;0x0001c
    7238:	82 4c 22 03 	mov	r12,	&0x0322	;

0000723c <.Loc.132.1>:
  PJDIR = config->portj.dir;
    723c:	2c 41       	mov	@r1,	r12	;
    723e:	1c 4c 1e 00 	mov	30(r12),r12	;0x0001e
    7242:	82 4c 24 03 	mov	r12,	&0x0324	;

00007246 <.Loc.133.1>:
  PJREN = config->portj.ren;
    7246:	2c 41       	mov	@r1,	r12	;
    7248:	1c 4c 20 00 	mov	32(r12),r12	;0x00020
    724c:	82 4c 26 03 	mov	r12,	&0x0326	;

00007250 <.Loc.134.1>:
  PJSEL0 = config->portj.sel0;
    7250:	2c 41       	mov	@r1,	r12	;
    7252:	1c 4c 22 00 	mov	34(r12),r12	;0x00022
    7256:	82 4c 2a 03 	mov	r12,	&0x032a	;

0000725a <.Loc.135.1>:
  PJSEL1 = config->portj.sel1;
    725a:	2c 41       	mov	@r1,	r12	;
    725c:	1c 4c 24 00 	mov	36(r12),r12	;0x00024
    7260:	82 4c 2c 03 	mov	r12,	&0x032c	;

00007264 <.Loc.137.1>:
  
  PM5CTL0 &= ~LOCKLPM5;
    7264:	1c 42 30 01 	mov	&0x0130,r12	;0x0130
    7268:	1c c3       	bic	#1,	r12	;r3 As==01
    726a:	82 4c 30 01 	mov	r12,	&0x0130	;

0000726e <.Loc.138.1>:
}
    726e:	03 43       	nop			
    7270:	21 53       	incd	r1		;
    7272:	30 41       	ret			

00007274 <_pal_lld_setgroupmode>:
 *
 * @notapi
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
    7274:	31 80 06 00 	sub	#6,	r1	;

00007278 <.LCFI1>:
    7278:	81 4c 04 00 	mov	r12,	4(r1)	;
    727c:	81 4d 02 00 	mov	r13,	2(r1)	;
    7280:	81 4e 00 00 	mov	r14,	0(r1)	;

00007284 <.Loc.156.1>:
  
  switch (mode) {
    7284:	2c 41       	mov	@r1,	r12	;
    7286:	2c 92       	cmp	#4,	r12	;r2 As==10
    7288:	b5 24       	jz	$+364    	;abs 0x73f4
    728a:	6d 42       	mov.b	#4,	r13	;r2 As==10
    728c:	0d 9c       	cmp	r12,	r13	;
    728e:	0a 28       	jnc	$+22     	;abs 0x72a4
    7290:	1c 93       	cmp	#1,	r12	;r3 As==01
    7292:	5f 24       	jz	$+192    	;abs 0x7352
    7294:	1c 93       	cmp	#1,	r12	;r3 As==01
    7296:	16 28       	jnc	$+46     	;abs 0x72c4
    7298:	2c 93       	cmp	#2,	r12	;r3 As==10
    729a:	14 24       	jz	$+42     	;abs 0x72c4
    729c:	3c 90 03 00 	cmp	#3,	r12	;
    72a0:	58 24       	jz	$+178    	;abs 0x7352

000072a2 <.Loc.225.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    72a2:	bd 3d       	jmp	$+892    	;abs 0x761e

000072a4 <.L5>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    72a4:	3c 92       	cmp	#8,	r12	;r2 As==11
    72a6:	32 25       	jz	$+614    	;abs 0x750c
    72a8:	7d 42       	mov.b	#8,	r13	;r2 As==11
    72aa:	0d 9c       	cmp	r12,	r13	;
    72ac:	04 28       	jnc	$+10     	;abs 0x72b6
    72ae:	3c 90 06 00 	cmp	#6,	r12	;
    72b2:	f2 24       	jz	$+486    	;abs 0x7498

000072b4 <.Loc.225.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    72b4:	b4 3d       	jmp	$+874    	;abs 0x761e

000072b6 <.L9>:
 */
void _pal_lld_setgroupmode(ioportid_t port,
                           ioportmask_t mask,
                           iomode_t mode) {
  
  switch (mode) {
    72b6:	3c 90 09 00 	cmp	#9,	r12	;
    72ba:	56 25       	jz	$+686    	;abs 0x7568
    72bc:	3c 90 0a 00 	cmp	#10,	r12	;#0x000a
    72c0:	81 25       	jz	$+772    	;abs 0x75c4

000072c2 <.Loc.225.1>:
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
  }
}
    72c2:	ad 3d       	jmp	$+860    	;abs 0x761e

000072c4 <.L7>:
                           iomode_t mode) {
  
  switch (mode) {
    case PAL_MODE_RESET:
    case PAL_MODE_INPUT:
      port->dir &= ~mask;
    72c4:	1c 41 04 00 	mov	4(r1),	r12	;
    72c8:	1d 4c 04 00 	mov	4(r12),	r13	;
    72cc:	1c 41 02 00 	mov	2(r1),	r12	;
    72d0:	3c e3       	inv	r12		;
    72d2:	0d fc       	and	r12,	r13	;
    72d4:	1c 41 04 00 	mov	4(r1),	r12	;
    72d8:	8c 4d 04 00 	mov	r13,	4(r12)	;

000072dc <.Loc.160.1>:
      port->ren &= ~mask;
    72dc:	1c 41 04 00 	mov	4(r1),	r12	;
    72e0:	1d 4c 08 00 	mov	8(r12),	r13	;
    72e4:	1c 41 02 00 	mov	2(r1),	r12	;
    72e8:	3c e3       	inv	r12		;
    72ea:	0d fc       	and	r12,	r13	;
    72ec:	1c 41 04 00 	mov	4(r1),	r12	;
    72f0:	8c 4d 08 00 	mov	r13,	8(r12)	;

000072f4 <.Loc.161.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    72f4:	1c 41 04 00 	mov	4(r1),	r12	;
    72f8:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    72fc:	1c f1 02 00 	and	2(r1),	r12	;
    7300:	0c 93       	cmp	#0,	r12	;r3 As==00
    7302:	0e 24       	jz	$+30     	;abs 0x7320

00007304 <.Loc.161.1>:
    7304:	1c 41 04 00 	mov	4(r1),	r12	;
    7308:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    730c:	1c f1 02 00 	and	2(r1),	r12	;
    7310:	0c 93       	cmp	#0,	r12	;r3 As==00
    7312:	06 24       	jz	$+14     	;abs 0x7320

00007314 <.Loc.162.1>:
        port->selc = mask;
    7314:	1c 41 04 00 	mov	4(r1),	r12	;
    7318:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    731c:	16 00 

0000731e <.Loc.167.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    731e:	7f 3d       	jmp	$+768    	;abs 0x761e

00007320 <.L13>:
      port->dir &= ~mask;
      port->ren &= ~mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    7320:	1c 41 04 00 	mov	4(r1),	r12	;
    7324:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    7328:	1c 41 02 00 	mov	2(r1),	r12	;
    732c:	3c e3       	inv	r12		;
    732e:	0d fc       	and	r12,	r13	;
    7330:	1c 41 04 00 	mov	4(r1),	r12	;
    7334:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007338 <.Loc.165.1>:
        port->sel1 &= ~mask;
    7338:	1c 41 04 00 	mov	4(r1),	r12	;
    733c:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    7340:	1c 41 02 00 	mov	2(r1),	r12	;
    7344:	3c e3       	inv	r12		;
    7346:	0d fc       	and	r12,	r13	;
    7348:	1c 41 04 00 	mov	4(r1),	r12	;
    734c:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007350 <.Loc.167.1>:
      }
      break;
    7350:	66 3d       	jmp	$+718    	;abs 0x761e

00007352 <.L6>:
    case PAL_MODE_UNCONNECTED:
    case PAL_MODE_INPUT_PULLUP:
      port->dir &= ~mask;
    7352:	1c 41 04 00 	mov	4(r1),	r12	;
    7356:	1d 4c 04 00 	mov	4(r12),	r13	;
    735a:	1c 41 02 00 	mov	2(r1),	r12	;
    735e:	3c e3       	inv	r12		;
    7360:	0d fc       	and	r12,	r13	;
    7362:	1c 41 04 00 	mov	4(r1),	r12	;
    7366:	8c 4d 04 00 	mov	r13,	4(r12)	;

0000736a <.Loc.171.1>:
      port->ren |= mask;
    736a:	1c 41 04 00 	mov	4(r1),	r12	;
    736e:	1c 4c 08 00 	mov	8(r12),	r12	;
    7372:	0d 4c       	mov	r12,	r13	;
    7374:	1d d1 02 00 	bis	2(r1),	r13	;
    7378:	1c 41 04 00 	mov	4(r1),	r12	;
    737c:	8c 4d 08 00 	mov	r13,	8(r12)	;

00007380 <.Loc.172.1>:
      port->out |= mask;
    7380:	1c 41 04 00 	mov	4(r1),	r12	;
    7384:	1c 4c 02 00 	mov	2(r12),	r12	;
    7388:	0d 4c       	mov	r12,	r13	;
    738a:	1d d1 02 00 	bis	2(r1),	r13	;
    738e:	1c 41 04 00 	mov	4(r1),	r12	;
    7392:	8c 4d 02 00 	mov	r13,	2(r12)	;

00007396 <.Loc.173.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    7396:	1c 41 04 00 	mov	4(r1),	r12	;
    739a:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    739e:	1c f1 02 00 	and	2(r1),	r12	;
    73a2:	0c 93       	cmp	#0,	r12	;r3 As==00
    73a4:	0e 24       	jz	$+30     	;abs 0x73c2

000073a6 <.Loc.173.1>:
    73a6:	1c 41 04 00 	mov	4(r1),	r12	;
    73aa:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    73ae:	1c f1 02 00 	and	2(r1),	r12	;
    73b2:	0c 93       	cmp	#0,	r12	;r3 As==00
    73b4:	06 24       	jz	$+14     	;abs 0x73c2

000073b6 <.Loc.174.1>:
        port->selc = mask;
    73b6:	1c 41 04 00 	mov	4(r1),	r12	;
    73ba:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    73be:	16 00 

000073c0 <.Loc.179.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    73c0:	2e 3d       	jmp	$+606    	;abs 0x761e

000073c2 <.L15>:
      port->ren |= mask;
      port->out |= mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    73c2:	1c 41 04 00 	mov	4(r1),	r12	;
    73c6:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    73ca:	1c 41 02 00 	mov	2(r1),	r12	;
    73ce:	3c e3       	inv	r12		;
    73d0:	0d fc       	and	r12,	r13	;
    73d2:	1c 41 04 00 	mov	4(r1),	r12	;
    73d6:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000073da <.Loc.177.1>:
        port->sel1 &= ~mask;
    73da:	1c 41 04 00 	mov	4(r1),	r12	;
    73de:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    73e2:	1c 41 02 00 	mov	2(r1),	r12	;
    73e6:	3c e3       	inv	r12		;
    73e8:	0d fc       	and	r12,	r13	;
    73ea:	1c 41 04 00 	mov	4(r1),	r12	;
    73ee:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

000073f2 <.Loc.179.1>:
      }
      break;
    73f2:	15 3d       	jmp	$+556    	;abs 0x761e

000073f4 <.L4>:
    case PAL_MODE_INPUT_PULLDOWN:
      port->dir &= ~mask;
    73f4:	1c 41 04 00 	mov	4(r1),	r12	;
    73f8:	1d 4c 04 00 	mov	4(r12),	r13	;
    73fc:	1c 41 02 00 	mov	2(r1),	r12	;
    7400:	3c e3       	inv	r12		;
    7402:	0d fc       	and	r12,	r13	;
    7404:	1c 41 04 00 	mov	4(r1),	r12	;
    7408:	8c 4d 04 00 	mov	r13,	4(r12)	;

0000740c <.Loc.182.1>:
      port->ren |= mask;
    740c:	1c 41 04 00 	mov	4(r1),	r12	;
    7410:	1c 4c 08 00 	mov	8(r12),	r12	;
    7414:	0d 4c       	mov	r12,	r13	;
    7416:	1d d1 02 00 	bis	2(r1),	r13	;
    741a:	1c 41 04 00 	mov	4(r1),	r12	;
    741e:	8c 4d 08 00 	mov	r13,	8(r12)	;

00007422 <.Loc.183.1>:
      port->out &= ~mask;
    7422:	1c 41 04 00 	mov	4(r1),	r12	;
    7426:	1d 4c 02 00 	mov	2(r12),	r13	;
    742a:	1c 41 02 00 	mov	2(r1),	r12	;
    742e:	3c e3       	inv	r12		;
    7430:	0d fc       	and	r12,	r13	;
    7432:	1c 41 04 00 	mov	4(r1),	r12	;
    7436:	8c 4d 02 00 	mov	r13,	2(r12)	;

0000743a <.Loc.184.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    743a:	1c 41 04 00 	mov	4(r1),	r12	;
    743e:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7442:	1c f1 02 00 	and	2(r1),	r12	;
    7446:	0c 93       	cmp	#0,	r12	;r3 As==00
    7448:	0e 24       	jz	$+30     	;abs 0x7466

0000744a <.Loc.184.1>:
    744a:	1c 41 04 00 	mov	4(r1),	r12	;
    744e:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7452:	1c f1 02 00 	and	2(r1),	r12	;
    7456:	0c 93       	cmp	#0,	r12	;r3 As==00
    7458:	06 24       	jz	$+14     	;abs 0x7466

0000745a <.Loc.185.1>:
        port->selc = mask;
    745a:	1c 41 04 00 	mov	4(r1),	r12	;
    745e:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7462:	16 00 

00007464 <.Loc.190.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    7464:	dc 3c       	jmp	$+442    	;abs 0x761e

00007466 <.L17>:
      port->ren |= mask;
      port->out &= ~mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    7466:	1c 41 04 00 	mov	4(r1),	r12	;
    746a:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    746e:	1c 41 02 00 	mov	2(r1),	r12	;
    7472:	3c e3       	inv	r12		;
    7474:	0d fc       	and	r12,	r13	;
    7476:	1c 41 04 00 	mov	4(r1),	r12	;
    747a:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

0000747e <.Loc.188.1>:
        port->sel1 &= ~mask;
    747e:	1c 41 04 00 	mov	4(r1),	r12	;
    7482:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    7486:	1c 41 02 00 	mov	2(r1),	r12	;
    748a:	3c e3       	inv	r12		;
    748c:	0d fc       	and	r12,	r13	;
    748e:	1c 41 04 00 	mov	4(r1),	r12	;
    7492:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007496 <.Loc.190.1>:
      }
      break;
    7496:	c3 3c       	jmp	$+392    	;abs 0x761e

00007498 <.L10>:
    case PAL_MODE_OUTPUT_PUSHPULL:
      port->dir |= mask;
    7498:	1c 41 04 00 	mov	4(r1),	r12	;
    749c:	1c 4c 04 00 	mov	4(r12),	r12	;
    74a0:	0d 4c       	mov	r12,	r13	;
    74a2:	1d d1 02 00 	bis	2(r1),	r13	;
    74a6:	1c 41 04 00 	mov	4(r1),	r12	;
    74aa:	8c 4d 04 00 	mov	r13,	4(r12)	;

000074ae <.Loc.193.1>:
      if ((port->sel0 & mask) && (port->sel1 & mask))
    74ae:	1c 41 04 00 	mov	4(r1),	r12	;
    74b2:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    74b6:	1c f1 02 00 	and	2(r1),	r12	;
    74ba:	0c 93       	cmp	#0,	r12	;r3 As==00
    74bc:	0e 24       	jz	$+30     	;abs 0x74da

000074be <.Loc.193.1>:
    74be:	1c 41 04 00 	mov	4(r1),	r12	;
    74c2:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    74c6:	1c f1 02 00 	and	2(r1),	r12	;
    74ca:	0c 93       	cmp	#0,	r12	;r3 As==00
    74cc:	06 24       	jz	$+14     	;abs 0x74da

000074ce <.Loc.194.1>:
        port->selc = mask;
    74ce:	1c 41 04 00 	mov	4(r1),	r12	;
    74d2:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    74d6:	16 00 

000074d8 <.Loc.199.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 &= ~mask;
      }
      break;
    74d8:	a2 3c       	jmp	$+326    	;abs 0x761e

000074da <.L19>:
    case PAL_MODE_OUTPUT_PUSHPULL:
      port->dir |= mask;
      if ((port->sel0 & mask) && (port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    74da:	1c 41 04 00 	mov	4(r1),	r12	;
    74de:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    74e2:	1c 41 02 00 	mov	2(r1),	r12	;
    74e6:	3c e3       	inv	r12		;
    74e8:	0d fc       	and	r12,	r13	;
    74ea:	1c 41 04 00 	mov	4(r1),	r12	;
    74ee:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000074f2 <.Loc.197.1>:
        port->sel1 &= ~mask;
    74f2:	1c 41 04 00 	mov	4(r1),	r12	;
    74f6:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    74fa:	1c 41 02 00 	mov	2(r1),	r12	;
    74fe:	3c e3       	inv	r12		;
    7500:	0d fc       	and	r12,	r13	;
    7502:	1c 41 04 00 	mov	4(r1),	r12	;
    7506:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

0000750a <.Loc.199.1>:
      }
      break;
    750a:	89 3c       	jmp	$+276    	;abs 0x761e

0000750c <.L8>:
    case PAL_MSP430X_ALTERNATE_1:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
    750c:	1c 41 04 00 	mov	4(r1),	r12	;
    7510:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7514:	1c f1 02 00 	and	2(r1),	r12	;
    7518:	0c 93       	cmp	#0,	r12	;r3 As==00
    751a:	0e 20       	jnz	$+30     	;abs 0x7538

0000751c <.Loc.201.1>:
    751c:	1c 41 04 00 	mov	4(r1),	r12	;
    7520:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7524:	1c f1 02 00 	and	2(r1),	r12	;
    7528:	0c 93       	cmp	#0,	r12	;r3 As==00
    752a:	06 24       	jz	$+14     	;abs 0x7538

0000752c <.Loc.202.1>:
        port->selc = mask;
    752c:	1c 41 04 00 	mov	4(r1),	r12	;
    7530:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7534:	16 00 

00007536 <.Loc.207.1>:
      else {
        port->sel0 |= mask;
        port->sel1 &= ~mask;
      }
      break;
    7536:	73 3c       	jmp	$+232    	;abs 0x761e

00007538 <.L21>:
      break;
    case PAL_MSP430X_ALTERNATE_1:
      if (!(port->sel0 & mask) && (port->sel1 & mask)) 
        port->selc = mask;
      else {
        port->sel0 |= mask;
    7538:	1c 41 04 00 	mov	4(r1),	r12	;
    753c:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7540:	0d 4c       	mov	r12,	r13	;
    7542:	1d d1 02 00 	bis	2(r1),	r13	;
    7546:	1c 41 04 00 	mov	4(r1),	r12	;
    754a:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

0000754e <.Loc.205.1>:
        port->sel1 &= ~mask;
    754e:	1c 41 04 00 	mov	4(r1),	r12	;
    7552:	1d 4c 0c 00 	mov	12(r12),r13	;0x0000c
    7556:	1c 41 02 00 	mov	2(r1),	r12	;
    755a:	3c e3       	inv	r12		;
    755c:	0d fc       	and	r12,	r13	;
    755e:	1c 41 04 00 	mov	4(r1),	r12	;
    7562:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

00007566 <.Loc.207.1>:
      }
      break;
    7566:	5b 3c       	jmp	$+184    	;abs 0x761e

00007568 <.L11>:
    case PAL_MSP430X_ALTERNATE_2:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
    7568:	1c 41 04 00 	mov	4(r1),	r12	;
    756c:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    7570:	1c f1 02 00 	and	2(r1),	r12	;
    7574:	0c 93       	cmp	#0,	r12	;r3 As==00
    7576:	0e 24       	jz	$+30     	;abs 0x7594

00007578 <.Loc.209.1>:
    7578:	1c 41 04 00 	mov	4(r1),	r12	;
    757c:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    7580:	1c f1 02 00 	and	2(r1),	r12	;
    7584:	0c 93       	cmp	#0,	r12	;r3 As==00
    7586:	06 20       	jnz	$+14     	;abs 0x7594

00007588 <.Loc.210.1>:
        port->selc = mask;
    7588:	1c 41 04 00 	mov	4(r1),	r12	;
    758c:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    7590:	16 00 

00007592 <.Loc.215.1>:
      else {
        port->sel0 &= ~mask;
        port->sel1 |= mask;
      }
      break;
    7592:	45 3c       	jmp	$+140    	;abs 0x761e

00007594 <.L23>:
      break;
    case PAL_MSP430X_ALTERNATE_2:
      if ((port->sel0 & mask) && !(port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 &= ~mask;
    7594:	1c 41 04 00 	mov	4(r1),	r12	;
    7598:	1d 4c 0a 00 	mov	10(r12),r13	;0x0000a
    759c:	1c 41 02 00 	mov	2(r1),	r12	;
    75a0:	3c e3       	inv	r12		;
    75a2:	0d fc       	and	r12,	r13	;
    75a4:	1c 41 04 00 	mov	4(r1),	r12	;
    75a8:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

000075ac <.Loc.213.1>:
        port->sel1 |= mask;
    75ac:	1c 41 04 00 	mov	4(r1),	r12	;
    75b0:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    75b4:	0d 4c       	mov	r12,	r13	;
    75b6:	1d d1 02 00 	bis	2(r1),	r13	;
    75ba:	1c 41 04 00 	mov	4(r1),	r12	;
    75be:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

000075c2 <.Loc.215.1>:
      }
      break;
    75c2:	2d 3c       	jmp	$+92     	;abs 0x761e

000075c4 <.L12>:
    case PAL_MSP430X_ALTERNATE_3:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
    75c4:	1c 41 04 00 	mov	4(r1),	r12	;
    75c8:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    75cc:	1c f1 02 00 	and	2(r1),	r12	;
    75d0:	0c 93       	cmp	#0,	r12	;r3 As==00
    75d2:	0e 20       	jnz	$+30     	;abs 0x75f0

000075d4 <.Loc.217.1>:
    75d4:	1c 41 04 00 	mov	4(r1),	r12	;
    75d8:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    75dc:	1c f1 02 00 	and	2(r1),	r12	;
    75e0:	0c 93       	cmp	#0,	r12	;r3 As==00
    75e2:	06 20       	jnz	$+14     	;abs 0x75f0

000075e4 <.Loc.218.1>:
        port->selc = mask;
    75e4:	1c 41 04 00 	mov	4(r1),	r12	;
    75e8:	9c 41 02 00 	mov	2(r1),	22(r12)	; 0x0016
    75ec:	16 00 

000075ee <.Loc.223.1>:
      else {
        port->sel0 |= mask;
        port->sel1 |= mask;
      }
      break;
    75ee:	16 3c       	jmp	$+46     	;abs 0x761c

000075f0 <.L25>:
      break;
    case PAL_MSP430X_ALTERNATE_3:
      if (!(port->sel0 & mask) && !(port->sel1 & mask))
        port->selc = mask;
      else {
        port->sel0 |= mask;
    75f0:	1c 41 04 00 	mov	4(r1),	r12	;
    75f4:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a
    75f8:	0d 4c       	mov	r12,	r13	;
    75fa:	1d d1 02 00 	bis	2(r1),	r13	;
    75fe:	1c 41 04 00 	mov	4(r1),	r12	;
    7602:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

00007606 <.Loc.221.1>:
        port->sel1 |= mask;
    7606:	1c 41 04 00 	mov	4(r1),	r12	;
    760a:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    760e:	0d 4c       	mov	r12,	r13	;
    7610:	1d d1 02 00 	bis	2(r1),	r13	;
    7614:	1c 41 04 00 	mov	4(r1),	r12	;
    7618:	8c 4d 0c 00 	mov	r13,	12(r12)	; 0x000c

0000761c <.L27>:
      }
      break;
    761c:	03 43       	nop			

0000761e <.L28>:
  }
}
    761e:	03 43       	nop			
    7620:	31 50 06 00 	add	#6,	r1	;
    7624:	30 41       	ret			

00007626 <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    7626:	03 43       	nop			
    7628:	30 41       	ret			

0000762a <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    762a:	03 43       	nop			
    762c:	30 41       	ret			

0000762e <dma_trigger_set>:
 * @param[in] index   The index of the DMA channel whose trigger is set.
 * @param[in] trigger The trigger to use.
 * @note  This is all to get around weird MSP behavior when writing to memory-
 *        mapped registers using bytewise instructions.
 */
static void dma_trigger_set(uint8_t index, uint8_t trigger) {
    762e:	0a 15       	pushm	#1,	r10	;16-bit words

00007630 <.LCFI0>:
    7630:	21 82       	sub	#4,	r1	;r2 As==10

00007632 <.LCFI1>:
    7632:	c1 4c 01 00 	mov.b	r12,	1(r1)	;
    7636:	c1 4d 00 00 	mov.b	r13,	0(r1)	;

0000763a <.Loc.64.2>:
  uint16_t * ctl = ((uint16_t *)((uintptr_t)(&DMACTL0)) + (index / 2));
    763a:	5c 41 01 00 	mov.b	1(r1),	r12	;
    763e:	12 c3       	clrc			
    7640:	0c 10       	rrc	r12		;
    7642:	3c f0 ff 00 	and	#255,	r12	;#0x00ff

00007646 <L0>:
    7646:	0c 5c       	rla	r12		;
    7648:	0d 4c       	mov	r12,	r13	;
    764a:	3d 50 00 05 	add	#1280,	r13	;#0x0500
    764e:	81 4d 02 00 	mov	r13,	2(r1)	;

00007652 <.Loc.65.2>:
  *ctl &= 0xFF00 >> (8 * (index % 2));
    7652:	1c 41 02 00 	mov	2(r1),	r12	;
    7656:	2a 4c       	mov	@r12,	r10	;
    7658:	5c 41 01 00 	mov.b	1(r1),	r12	;
    765c:	5c f3       	and.b	#1,	r12	;r3 As==01
    765e:	0d 4c       	mov	r12,	r13	;
    7660:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    7664:	3c 40 00 ff 	mov	#65280,	r12	;#0xff00
    7668:	b0 12 8a 7f 	call	#32650		;#0x7f8a
    766c:	0d 4a       	mov	r10,	r13	;
    766e:	0d fc       	and	r12,	r13	;
    7670:	1c 41 02 00 	mov	2(r1),	r12	;
    7674:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007678 <.Loc.66.2>:
  *ctl |= trigger << (8 * (index % 2));
    7678:	1c 41 02 00 	mov	2(r1),	r12	;
    767c:	2a 4c       	mov	@r12,	r10	;
    767e:	6c 41       	mov.b	@r1,	r12	;
    7680:	5d 41 01 00 	mov.b	1(r1),	r13	;
    7684:	5d f3       	and.b	#1,	r13	;r3 As==01
    7686:	42 18 0d 5d 	rpt #3 { rlax.w	r13		;
    768a:	b0 12 f6 7e 	call	#32502		;#0x7ef6
    768e:	0d 4a       	mov	r10,	r13	;
    7690:	0d dc       	bis	r12,	r13	;
    7692:	1c 41 02 00 	mov	2(r1),	r12	;
    7696:	8c 4d 00 00 	mov	r13,	0(r12)	;

0000769a <.Loc.67.2>:
}
    769a:	03 43       	nop			
    769c:	21 52       	add	#4,	r1	;r2 As==10
    769e:	0a 17       	popm	#1,	r10	;16-bit words
    76a0:	30 41       	ret			

000076a2 <init_request>:
static void init_request(const msp430x_dma_req_t * request, uint8_t index) {
    76a2:	31 80 06 00 	sub	#6,	r1	;

000076a6 <.LCFI2>:
    76a6:	81 4c 02 00 	mov	r12,	2(r1)	;
    76aa:	c1 4d 01 00 	mov.b	r13,	1(r1)	;

000076ae <.Loc.70.2>:

  dma_trigger_set(index, request->trigger);
    76ae:	1c 41 02 00 	mov	2(r1),	r12	;
    76b2:	1c 4c 0c 00 	mov	12(r12),r12	;0x0000c
    76b6:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    76ba:	4d 4c       	mov.b	r12,	r13	;
    76bc:	5c 41 01 00 	mov.b	1(r1),	r12	;
    76c0:	b0 12 2e 76 	call	#30254		;#0x762e

000076c4 <.Loc.71.2>:
  callbacks[index]          = request->callback;
    76c4:	5c 41 01 00 	mov.b	1(r1),	r12	;
    76c8:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    76cc:	3c 50 f8 51 	add	#20984,	r12	;#0x51f8
    76d0:	1d 41 02 00 	mov	2(r1),	r13	;
    76d4:	9c 4d 0e 00 	mov	14(r13),0(r12)	;0x0000e
    76d8:	00 00 
    76da:	9c 4d 10 00 	mov	16(r13),2(r12)	;0x00010
    76de:	02 00 

000076e0 <.Loc.72.2>:
  msp430x_dma_ch_reg_t * ch = &dma_channels[index];
    76e0:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    76e4:	5c 41 01 00 	mov.b	1(r1),	r12	;
    76e8:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    76ec:	0e 4d       	mov	r13,	r14	;
    76ee:	0e 5c       	add	r12,	r14	;
    76f0:	81 4e 04 00 	mov	r14,	4(r1)	;

000076f4 <.Loc.73.2>:
  ch->sa                    = (uintptr_t)request->source_addr;
    76f4:	1c 41 02 00 	mov	2(r1),	r12	;
    76f8:	2c 4c       	mov	@r12,	r12	;
    76fa:	0d 43       	clr	r13		;
    76fc:	1e 41 04 00 	mov	4(r1),	r14	;
    7700:	8e 4c 02 00 	mov	r12,	2(r14)	;
    7704:	8e 4d 04 00 	mov	r13,	4(r14)	;

00007708 <.Loc.74.2>:
  ch->da                    = (uintptr_t)request->dest_addr;
    7708:	1c 41 02 00 	mov	2(r1),	r12	;
    770c:	1c 4c 02 00 	mov	2(r12),	r12	;
    7710:	0d 43       	clr	r13		;
    7712:	1e 41 04 00 	mov	4(r1),	r14	;
    7716:	8e 4c 06 00 	mov	r12,	6(r14)	;
    771a:	8e 4d 08 00 	mov	r13,	8(r14)	;

0000771e <.Loc.75.2>:
  ch->sz                    = request->size;
    771e:	1c 41 02 00 	mov	2(r1),	r12	;
    7722:	1d 4c 04 00 	mov	4(r12),	r13	;
    7726:	1c 41 04 00 	mov	4(r1),	r12	;
    772a:	8c 4d 0a 00 	mov	r13,	10(r12)	; 0x000a

0000772e <.Loc.76.2>:
  ch->ctl = DMAREQ | DMAIE | DMAEN | request->data_mode | request->addr_mode |
    772e:	1c 41 02 00 	mov	2(r1),	r12	;
    7732:	1d 4c 08 00 	mov	8(r12),	r13	;
    7736:	1c 41 02 00 	mov	2(r1),	r12	;
    773a:	1c 4c 06 00 	mov	6(r12),	r12	;
    773e:	0d dc       	bis	r12,	r13	;

00007740 <.Loc.77.2>:
            request->transfer_mode;
    7740:	1c 41 02 00 	mov	2(r1),	r12	;
    7744:	1c 4c 0a 00 	mov	10(r12),r12	;0x0000a

00007748 <.Loc.76.2>:
  callbacks[index]          = request->callback;
  msp430x_dma_ch_reg_t * ch = &dma_channels[index];
  ch->sa                    = (uintptr_t)request->source_addr;
  ch->da                    = (uintptr_t)request->dest_addr;
  ch->sz                    = request->size;
  ch->ctl = DMAREQ | DMAIE | DMAEN | request->data_mode | request->addr_mode |
    7748:	0c dd       	bis	r13,	r12	;
    774a:	0d 4c       	mov	r12,	r13	;
    774c:	3d d0 15 00 	bis	#21,	r13	;#0x0015
    7750:	1c 41 04 00 	mov	4(r1),	r12	;
    7754:	8c 4d 00 00 	mov	r13,	0(r12)	;

00007758 <.Loc.78.2>:
            request->transfer_mode;
}
    7758:	03 43       	nop			
    775a:	31 50 06 00 	add	#6,	r1	;
    775e:	30 41       	ret			

00007760 <ISR_DMA_VECTOR>:

/*===========================================================================*/
/* Driver interrupt handlers.                                                */
/*===========================================================================*/

PORT_IRQ_HANDLER(DMA_VECTOR) {
    7760:	bf 15       	pushm	#12,	r15	;16-bit words

00007762 <.LCFI3>:
    7762:	21 82       	sub	#4,	r1	;r2 As==10

00007764 <.LCFI4>:
  uint8_t index;
  OSAL_IRQ_PROLOGUE();
    7764:	b0 12 94 5b 	call	#23444		;#0x5b94

00007768 <.Loc.88.2>:

  index = (DMAIV >> 1) - 1;
    7768:	1c 42 0e 05 	mov	&0x050e,r12	;0x050e
    776c:	12 c3       	clrc			
    776e:	0c 10       	rrc	r12		;
    7770:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7774:	4d 4c       	mov.b	r12,	r13	;
    7776:	7d 53       	add.b	#-1,	r13	;r3 As==11
    7778:	c1 4d 03 00 	mov.b	r13,	3(r1)	;

0000777c <.Loc.90.2>:

  if (index < MSP430X_DMA_CHANNELS) {
    777c:	6c 43       	mov.b	#2,	r12	;r3 As==10
    777e:	5c 91 03 00 	cmp.b	3(r1),	r12	;
    7782:	1f 28       	jnc	$+64     	;abs 0x77c2

00007784 <.LBB2>:
#if CH_CFG_USE_SEMAPHORES
    chSysLockFromISR();
    7784:	b0 12 26 76 	call	#30246		;#0x7626
    7788:	b0 12 4e 5b 	call	#23374		;#0x5b4e

0000778c <.Loc.93.2>:
    chSemSignalI(&dma_lock);
    778c:	3c 40 04 52 	mov	#20996,	r12	;#0x5204
    7790:	b0 12 5a 5f 	call	#24410		;#0x5f5a

00007794 <.Loc.94.2>:
    chSysUnlockFromISR();
    7794:	b0 12 70 5b 	call	#23408		;#0x5b70
    7798:	b0 12 2a 76 	call	#30250		;#0x762a

0000779c <.Loc.97.2>:
#endif

    msp430x_dma_cb_t * cb = &callbacks[index];
    779c:	5c 41 03 00 	mov.b	3(r1),	r12	;
    77a0:	41 18 0c 5c 	rpt #2 { rlax.w	r12		;
    77a4:	0d 4c       	mov	r12,	r13	;
    77a6:	3d 50 f8 51 	add	#20984,	r13	;#0x51f8
    77aa:	81 4d 00 00 	mov	r13,	0(r1)	;

000077ae <.Loc.100.2>:

    /* WARNING: CALLBACKS ARE CALLED IN AN ISR CONTEXT! */
    if (cb->callback != NULL) {
    77ae:	2c 41       	mov	@r1,	r12	;
    77b0:	2c 4c       	mov	@r12,	r12	;
    77b2:	0c 93       	cmp	#0,	r12	;r3 As==00
    77b4:	06 24       	jz	$+14     	;abs 0x77c2

000077b6 <.Loc.101.2>:
      cb->callback(cb->args);
    77b6:	2c 41       	mov	@r1,	r12	;
    77b8:	2d 4c       	mov	@r12,	r13	;
    77ba:	2c 41       	mov	@r1,	r12	;
    77bc:	1c 4c 02 00 	mov	2(r12),	r12	;
    77c0:	8d 12       	call	r13		;

000077c2 <.L8>:
    }
  }

  OSAL_IRQ_EPILOGUE();
    77c2:	b0 12 c2 5b 	call	#23490		;#0x5bc2
    77c6:	b0 12 0c 5b 	call	#23308		;#0x5b0c
    77ca:	b0 12 ca 5d 	call	#24010		;#0x5dca
    77ce:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    77d2:	0c 93       	cmp	#0,	r12	;r3 As==00
    77d4:	02 24       	jz	$+6      	;abs 0x77da

000077d6 <.Loc.105.2>:
    77d6:	b0 12 e6 5d 	call	#24038		;#0x5de6

000077da <.L9>:
    77da:	b0 12 2c 5b 	call	#23340		;#0x5b2c

000077de <.Loc.106.2>:
}
    77de:	03 43       	nop			
    77e0:	21 52       	add	#4,	r1	;r2 As==10
    77e2:	b4 17       	popm	#12,	r15	;16-bit words
    77e4:	00 13       	reti			

000077e6 <dmaInit>:
 *
 * @init
 */
void dmaInit(void) {
#if CH_CFG_USE_SEMAPHORES
  chSemObjectInit(&dma_lock, MSP430X_DMA_CHANNELS);
    77e6:	b2 40 03 00 	mov	#3,	&0x5204	;
    77ea:	04 52 

000077ec <.Loc.121.2>:
#endif
}
    77ec:	03 43       	nop			
    77ee:	30 41       	ret			

000077f0 <dmaRequest>:
 *          for one-off or infrequent uses. If all channels are busy, and
 *          semaphores are enabled, the calling thread will sleep until a
 *          channel is available or the request times out. If semaphores are
 *          disabled, the calling thread will busy-wait instead of sleeping.
 */
bool dmaRequest(msp430x_dma_req_t * request, systime_t timeout) {
    77f0:	31 82       	sub	#8,	r1	;r2 As==11

000077f2 <.LCFI5>:
    77f2:	81 4c 02 00 	mov	r12,	2(r1)	;
    77f6:	81 4d 00 00 	mov	r13,	0(r1)	;

000077fa <.Loc.134.2>:
/* Check if a DMA channel is available */
#if CH_CFG_USE_SEMAPHORES
  msg_t semresult = chSemWaitTimeoutS(&dma_lock, timeout);
    77fa:	2d 41       	mov	@r1,	r13	;
    77fc:	3c 40 04 52 	mov	#20996,	r12	;#0x5204
    7800:	b0 12 f6 5e 	call	#24310		;#0x5ef6
    7804:	81 4c 04 00 	mov	r12,	4(r1)	;

00007808 <.Loc.135.2>:
  if (semresult != MSG_OK)
    7808:	81 93 04 00 	cmp	#0,	4(r1)	;r3 As==00
    780c:	02 24       	jz	$+6      	;abs 0x7812

0000780e <.Loc.136.2>:
    return true;
    780e:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7810:	23 3c       	jmp	$+72     	;abs 0x7858

00007812 <.L12>:
  systime_t start = chVTGetSystemTimeX();

  do {
#endif
    /* Grab the correct DMA channel to use */
    int i = 0;
    7812:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00

00007816 <.Loc.146.2>:
    for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    7816:	81 43 06 00 	mov	#0,	6(r1)	;r3 As==00
    781a:	0e 3c       	jmp	$+30     	;abs 0x7838

0000781c <.L17>:
      if (!(dma_channels[i].ctl & DMAEN)) {
    781c:	3d 40 10 05 	mov	#1296,	r13	;#0x0510
    7820:	1c 41 06 00 	mov	6(r1),	r12	;
    7824:	43 18 0c 5c 	rpt #4 { rlax.w	r12		;
    7828:	0c 5d       	add	r13,	r12	;
    782a:	2c 4c       	mov	@r12,	r12	;
    782c:	7c f0 10 00 	and.b	#16,	r12	;#0x0010
    7830:	0c 93       	cmp	#0,	r12	;r3 As==00
    7832:	07 24       	jz	$+16     	;abs 0x7842

00007834 <.Loc.146.2>:

  do {
#endif
    /* Grab the correct DMA channel to use */
    int i = 0;
    for (i = 0; i < MSP430X_DMA_CHANNELS; i++) {
    7834:	91 53 06 00 	inc	6(r1)		;

00007838 <.L14>:
    7838:	6c 43       	mov.b	#2,	r12	;r3 As==10
    783a:	1c 91 06 00 	cmp	6(r1),	r12	;
    783e:	ee 37       	jge	$-34     	;abs 0x781c
    7840:	01 3c       	jmp	$+4      	;abs 0x7844

00007842 <.L18>:
      if (!(dma_channels[i].ctl & DMAEN)) {
        break;
    7842:	03 43       	nop			

00007844 <.L16>:
      return true;
    }
#endif

    /* Make the request */
    init_request(request, i);
    7844:	1c 41 06 00 	mov	6(r1),	r12	;
    7848:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    784c:	4d 4c       	mov.b	r12,	r13	;
    784e:	1c 41 02 00 	mov	2(r1),	r12	;
    7852:	b0 12 a2 76 	call	#30370		;#0x76a2

00007856 <.Loc.165.2>:

    return false;
    7856:	4c 43       	clr.b	r12		;

00007858 <.L13>:
  }
    7858:	31 52       	add	#8,	r1	;r2 As==11
    785a:	30 41       	ret			

0000785c <port_lock_from_isr>:
 * @brief   Kernel-lock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_lock_from_isr(void) {

}
    785c:	03 43       	nop			
    785e:	30 41       	ret			

00007860 <port_unlock_from_isr>:
 * @brief   Kernel-unlock action from an interrupt handler.
 * @note    This function is empty in this port.
 */
static inline void port_unlock_from_isr(void) {

}
    7860:	03 43       	nop			

00007862 <L0>:
    7862:	30 41       	ret			

00007864 <osalSysLockFromISR>:
 *
 * @special
 */
static inline void osalSysLockFromISR(void) {

  chSysLockFromISR();
    7864:	b0 12 5c 78 	call	#30812		;#0x785c
    7868:	b0 12 4e 5b 	call	#23374		;#0x5b4e

0000786c <.Loc.527.2>:
}
    786c:	03 43       	nop			
    786e:	30 41       	ret			

00007870 <osalSysUnlockFromISR>:
 *
 * @special
 */
static inline void osalSysUnlockFromISR(void) {

  chSysUnlockFromISR();
    7870:	b0 12 70 5b 	call	#23408		;#0x5b70
    7874:	b0 12 60 78 	call	#30816		;#0x7860

00007878 <.Loc.538.2>:
}
    7878:	03 43       	nop			
    787a:	30 41       	ret			

0000787c <osalThreadResumeI>:
 * @param[in] trp       a pointer to a thread reference object
 * @param[in] msg       the message code
 *
 * @iclass
 */
static inline void osalThreadResumeI(thread_reference_t *trp, msg_t msg) {
    787c:	21 82       	sub	#4,	r1	;r2 As==10

0000787e <.LCFI0>:
    787e:	81 4c 02 00 	mov	r12,	2(r1)	;
    7882:	81 4d 00 00 	mov	r13,	0(r1)	;

00007886 <.Loc.739.2>:

  chThdResumeI(trp, msg);
    7886:	2d 41       	mov	@r1,	r13	;
    7888:	1c 41 02 00 	mov	2(r1),	r12	;
    788c:	b0 12 9a 5e 	call	#24218		;#0x5e9a

00007890 <.Loc.740.2>:
}
    7890:	03 43       	nop			
    7892:	21 52       	add	#4,	r1	;r2 As==10
    7894:	30 41       	ret			

00007896 <init_transfer>:

/*===========================================================================*/
/* Driver local functions.                                                   */
/*===========================================================================*/

static void init_transfer(SPIDriver * spip) {
    7896:	21 83       	decd	r1		;

00007898 <.LCFI1>:
    7898:	81 4c 00 00 	mov	r12,	0(r1)	;

0000789c <.Loc.120.3>:
  }
  else {
    dmaTransfer(&(spip->dmatx), &(spip->tx_req));
  }
#else
  dmaRequest(&(spip->rx_req), TIME_INFINITE);
    789c:	2c 41       	mov	@r1,	r12	;
    789e:	3c 50 1c 00 	add	#28,	r12	;#0x001c
    78a2:	4d 43       	clr.b	r13		;
    78a4:	b0 12 f0 77 	call	#30704		;#0x77f0

000078a8 <.Loc.121.3>:
  dmaRequest(&(spip->tx_req), TIME_INFINITE);
    78a8:	2c 41       	mov	@r1,	r12	;
    78aa:	3c 50 0a 00 	add	#10,	r12	;#0x000a
    78ae:	4d 43       	clr.b	r13		;
    78b0:	b0 12 f0 77 	call	#30704		;#0x77f0

000078b4 <.Loc.124.3>:
#endif

  *(spip->ifg) |= UCTXIFG;
    78b4:	2c 41       	mov	@r1,	r12	;
    78b6:	1c 4c 08 00 	mov	8(r12),	r12	;
    78ba:	2d 41       	mov	@r1,	r13	;
    78bc:	1d 4d 08 00 	mov	8(r13),	r13	;
    78c0:	2d 4d       	mov	@r13,	r13	;
    78c2:	2d d3       	bis	#2,	r13	;r3 As==10
    78c4:	8c 4d 00 00 	mov	r13,	0(r12)	;

000078c8 <.Loc.125.3>:
}
    78c8:	03 43       	nop			
    78ca:	21 53       	incd	r1		;
    78cc:	30 41       	ret			

000078ce <spi_lld_end_of_transfer>:
 * @brief   Shared end-of-transfer callback.
 *
 * @param[in] spip    pointer to the @p SPIDriver object
 * @note    This function is called in ISR context by the DMA code.
 */
static void spi_lld_end_of_transfer(void * spip) {
    78ce:	21 83       	decd	r1		;

000078d0 <.LCFI2>:
    78d0:	81 4c 00 00 	mov	r12,	0(r1)	;

000078d4 <.Loc.136.3>:

  /* So that future transfers will actually work */
  *(((SPIDriver *)spip)->ifg) &= ~(UCTXIFG);
    78d4:	2c 41       	mov	@r1,	r12	;
    78d6:	1c 4c 08 00 	mov	8(r12),	r12	;
    78da:	2d 41       	mov	@r1,	r13	;
    78dc:	1d 4d 08 00 	mov	8(r13),	r13	;
    78e0:	2d 4d       	mov	@r13,	r13	;
    78e2:	2d c3       	bic	#2,	r13	;r3 As==10
    78e4:	8c 4d 00 00 	mov	r13,	0(r12)	;

000078e8 <.Loc.140.3>:
  /* NOTE to future me - this macro sets the driver state and calls the
   * configured callback end_cb, if applicable. That callback doesn't seem to
   * be modifiable without reconfiguring the whole driver. */
  _spi_isr_code((SPIDriver *)spip);
    78e8:	2c 41       	mov	@r1,	r12	;
    78ea:	1c 4c 02 00 	mov	2(r12),	r12	;
    78ee:	2c 4c       	mov	@r12,	r12	;
    78f0:	0c 93       	cmp	#0,	r12	;r3 As==00
    78f2:	11 24       	jz	$+36     	;abs 0x7916

000078f4 <.Loc.140.3>:
    78f4:	2c 41       	mov	@r1,	r12	;
    78f6:	ec 42 00 00 	mov.b	#4,	0(r12)	;r2 As==10
    78fa:	2c 41       	mov	@r1,	r12	;
    78fc:	1c 4c 02 00 	mov	2(r12),	r12	;
    7900:	2d 4c       	mov	@r12,	r13	;
    7902:	2c 41       	mov	@r1,	r12	;
    7904:	8d 12       	call	r13		;
    7906:	2c 41       	mov	@r1,	r12	;
    7908:	6c 4c       	mov.b	@r12,	r12	;
    790a:	6c 92       	cmp.b	#4,	r12	;r2 As==10
    790c:	07 20       	jnz	$+16     	;abs 0x791c

0000790e <.Loc.140.3>:
    790e:	2c 41       	mov	@r1,	r12	;
    7910:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10
    7914:	03 3c       	jmp	$+8      	;abs 0x791c

00007916 <.L8>:
    7916:	2c 41       	mov	@r1,	r12	;
    7918:	ec 43 00 00 	mov.b	#2,	0(r12)	;r3 As==10

0000791c <.L10>:
    791c:	b0 12 64 78 	call	#30820		;#0x7864
    7920:	2c 41       	mov	@r1,	r12	;
    7922:	2c 52       	add	#4,	r12	;r2 As==10
    7924:	4d 43       	clr.b	r13		;
    7926:	b0 12 7c 78 	call	#30844		;#0x787c
    792a:	b0 12 70 78 	call	#30832		;#0x7870

0000792e <.Loc.141.3>:
}
    792e:	03 43       	nop			
    7930:	21 53       	incd	r1		;
    7932:	30 41       	ret			

00007934 <spi_lld_init>:
 * still works - the transfer isn't complete until SZ bytes are transferred */
#endif

#if MSP430X_SPI_USE_SPIA1 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDA1);
    7934:	3c 40 06 52 	Address 0x0000000000007936 is out of bounds.
mov	#65535,	r12	;#0xffff

00007936 <L0>:
    7936:	06 52       	add	r2,	r6	;
    7938:	b0 12 64 6a 	call	#27236		;#0x6a64

0000793c <.Loc.182.3>:
  SPIDA1.regs                     = (msp430x_spi_reg_t *)(&UCA1CTLW0);
    793c:	b2 40 e0 05 	mov	#1504,	&0x520c	;#0x05e0
    7940:	0c 52 

00007942 <.Loc.183.3>:
  SPIDA1.ifg                      = (volatile uint16_t *)&UCA1IFG;
    7942:	b2 40 fc 05 	mov	#1532,	&0x520e	;#0x05fc
    7946:	0e 52 

00007948 <.Loc.184.3>:
  SPIDA1.tx_req.trigger           = DMA_TRIGGER_MNEM(UCA1TXIFG);
    7948:	b2 40 11 00 	mov	#17,	&0x521c	;#0x0011
    794c:	1c 52 

0000794e <.Loc.185.3>:
  SPIDA1.rx_req.trigger           = DMA_TRIGGER_MNEM(UCA1RXIFG);
    794e:	b2 40 10 00 	mov	#16,	&0x522e	;#0x0010
    7952:	2e 52 

00007954 <.Loc.186.3>:
  SPIDA1.tx_req.dest_addr         = &(SPIDA1.regs->txbuf);
    7954:	1c 42 0c 52 	mov	&0x520c,r12	;0x520c
    7958:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    795c:	82 4c 12 52 	mov	r12,	&0x5212	;

00007960 <.Loc.187.3>:
  SPIDA1.rx_req.source_addr       = &(SPIDA1.regs->rxbuf);
    7960:	1c 42 0c 52 	mov	&0x520c,r12	;0x520c
    7964:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    7968:	82 4c 22 52 	mov	r12,	&0x5222	;

0000796c <.Loc.188.3>:
  SPIDA1.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    796c:	b2 40 c0 00 	mov	#192,	&0x5218	;#0x00c0
    7970:	18 52 

00007972 <.Loc.189.3>:
  SPIDA1.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    7972:	b2 40 c0 00 	mov	#192,	&0x522a	;#0x00c0
    7976:	2a 52 

00007978 <.Loc.190.3>:
  SPIDA1.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    7978:	82 43 1a 52 	mov	#0,	&0x521a	;r3 As==00

0000797c <.Loc.191.3>:
  SPIDA1.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    797c:	82 43 2c 52 	mov	#0,	&0x522c	;r3 As==00

00007980 <.Loc.192.3>:
  SPIDA1.tx_req.callback.callback = NULL;
    7980:	82 43 1e 52 	mov	#0,	&0x521e	;r3 As==00

00007984 <.Loc.193.3>:
  SPIDA1.tx_req.callback.args     = NULL;
    7984:	82 43 20 52 	mov	#0,	&0x5220	;r3 As==00

00007988 <.Loc.194.3>:
  SPIDA1.rx_req.callback.callback = spi_lld_end_of_transfer;
    7988:	b2 40 ce 78 	mov	#30926,	&0x5230	;#0x78ce
    798c:	30 52 

0000798e <.Loc.195.3>:
  SPIDA1.rx_req.callback.args     = &SPIDA1;
    798e:	b2 40 06 52 	mov	#20998,	&0x5232	;#0x5206
    7992:	32 52 

00007994 <.Loc.238.3>:
  SPIDA3.rx_req.callback.args     = &SPIDA3;
#endif

#if MSP430X_SPI_USE_SPIB0 == TRUE
  /* Driver initialization.*/
  spiObjectInit(&SPIDB0);
    7994:	3c 40 34 52 	mov	#21044,	r12	;#0x5234
    7998:	b0 12 64 6a 	call	#27236		;#0x6a64

0000799c <.Loc.239.3>:
  SPIDB0.regs                     = (msp430x_spi_reg_t *)(&UCB0CTLW0);
    799c:	b2 40 40 06 	mov	#1600,	&0x523a	;#0x0640
    79a0:	3a 52 

000079a2 <.Loc.240.3>:
  SPIDB0.ifg                      = (volatile uint16_t *)&UCB0IFG;
    79a2:	b2 40 6c 06 	mov	#1644,	&0x523c	;#0x066c
    79a6:	3c 52 

000079a8 <.Loc.241.3>:
  SPIDB0.tx_req.trigger           = DMA_TRIGGER_MNEM(UCB0TXIFG0);
    79a8:	b2 40 13 00 	mov	#19,	&0x524a	;#0x0013
    79ac:	4a 52 

000079ae <.Loc.242.3>:
  SPIDB0.rx_req.trigger           = DMA_TRIGGER_MNEM(UCB0RXIFG0);
    79ae:	b2 40 12 00 	mov	#18,	&0x525c	;#0x0012
    79b2:	5c 52 

000079b4 <.Loc.243.3>:
  SPIDB0.tx_req.dest_addr         = &(SPIDB0.regs->txbuf);
    79b4:	1c 42 3a 52 	mov	&0x523a,r12	;0x523a
    79b8:	3c 50 0e 00 	add	#14,	r12	;#0x000e
    79bc:	82 4c 40 52 	mov	r12,	&0x5240	;

000079c0 <.Loc.244.3>:
  SPIDB0.rx_req.source_addr       = &(SPIDB0.regs->rxbuf);
    79c0:	1c 42 3a 52 	mov	&0x523a,r12	;0x523a
    79c4:	3c 50 0c 00 	add	#12,	r12	;#0x000c
    79c8:	82 4c 50 52 	mov	r12,	&0x5250	;

000079cc <.Loc.245.3>:
  SPIDB0.tx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    79cc:	b2 40 c0 00 	mov	#192,	&0x5246	;#0x00c0
    79d0:	46 52 

000079d2 <.Loc.246.3>:
  SPIDB0.rx_req.data_mode         = MSP430X_DMA_SRCBYTE | MSP430X_DMA_DSTBYTE;
    79d2:	b2 40 c0 00 	mov	#192,	&0x5258	;#0x00c0
    79d6:	58 52 

000079d8 <.Loc.247.3>:
  SPIDB0.tx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    79d8:	82 43 48 52 	mov	#0,	&0x5248	;r3 As==00

000079dc <.Loc.248.3>:
  SPIDB0.rx_req.transfer_mode     = MSP430X_DMA_SINGLE;
    79dc:	82 43 5a 52 	mov	#0,	&0x525a	;r3 As==00

000079e0 <.Loc.249.3>:
  SPIDB0.tx_req.callback.callback = NULL;
    79e0:	82 43 4c 52 	mov	#0,	&0x524c	;r3 As==00

000079e4 <.Loc.250.3>:
  SPIDB0.tx_req.callback.args     = NULL;
    79e4:	82 43 4e 52 	mov	#0,	&0x524e	;r3 As==00

000079e8 <.Loc.251.3>:
  SPIDB0.rx_req.callback.callback = spi_lld_end_of_transfer;
    79e8:	b2 40 ce 78 	mov	#30926,	&0x525e	;#0x78ce
    79ec:	5e 52 

000079ee <.Loc.252.3>:
  SPIDB0.rx_req.callback.args     = &SPIDB0;
    79ee:	b2 40 34 52 	mov	#21044,	&0x5260	;#0x5234
    79f2:	60 52 

000079f4 <.Loc.311.3>:
  SPIDB3.tx_req.callback.callback = NULL;
  SPIDB3.tx_req.callback.args     = NULL;
  SPIDB3.rx_req.callback.callback = spi_lld_end_of_transfer;
  SPIDB3.rx_req.callback.args     = &SPIDB3;
#endif
}
    79f4:	03 43       	nop			
    79f6:	30 41       	ret			

000079f8 <spi_lld_start>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_start(SPIDriver * spip) {
    79f8:	31 80 06 00 	sub	#6,	r1	;

000079fc <.LCFI3>:
    79fc:	81 4c 00 00 	mov	r12,	0(r1)	;

00007a00 <.Loc.337.3>:
      b = dmaAcquire(&(spip->dmarx), spip->config->dmarx_index);
      osalDbgAssert(!b, "stream already allocated");
    }
#endif /* MSP430X_SPI_EXCLUSIVE_DMA */
  }
  uint16_t brw = 0;
    7a00:	81 43 04 00 	mov	#0,	4(r1)	;r3 As==00

00007a04 <.Loc.338.3>:
  uint8_t ssel = 0;
    7a04:	c1 43 03 00 	mov.b	#0,	3(r1)	;r3 As==00

00007a08 <.Loc.346.3>:
    brw  = MSP430X_SPIA0_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIA0_UCSSEL;
  }
#endif
#if MSP430X_SPI_USE_SPIA1
  if (spip == &SPIDA1) {
    7a08:	b1 90 06 52 	cmp	#20998,	0(r1)	;#0x5206
    7a0c:	00 00 
    7a0e:	14 20       	jnz	$+42     	;abs 0x7a38

00007a10 <.Loc.347.3>:
    brw  = MSP430X_SPIA1_CLK_FREQ / spip->config->bit_rate;
    7a10:	2c 41       	mov	@r1,	r12	;
    7a12:	1c 4c 02 00 	mov	2(r12),	r12	;
    7a16:	1d 4c 06 00 	mov	6(r12),	r13	;
    7a1a:	1c 4c 04 00 	mov	4(r12),	r12	;
    7a1e:	0e 4c       	mov	r12,	r14	;
    7a20:	0f 4d       	mov	r13,	r15	;
    7a22:	3c 40 00 12 	mov	#4608,	r12	;#0x1200
    7a26:	7d 40 7a 00 	mov.b	#122,	r13	;#0x007a
    7a2a:	b0 12 c4 7e 	call	#32452		;#0x7ec4
    7a2e:	81 4c 04 00 	mov	r12,	4(r1)	;

00007a32 <.Loc.348.3>:
    ssel = MSP430X_SPIA1_UCSSEL;
    7a32:	f1 40 80 ff 	mov.b	#65408,	3(r1)	;#0xff80
    7a36:	03 00 

00007a38 <.L13>:
    brw  = MSP430X_SPIA3_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIA3_UCSSEL;
  }
#endif
#if MSP430X_SPI_USE_SPIB0
  if (spip == &SPIDB0) {
    7a38:	b1 90 34 52 	cmp	#21044,	0(r1)	;#0x5234
    7a3c:	00 00 
    7a3e:	14 20       	jnz	$+42     	;abs 0x7a68

00007a40 <.Loc.365.3>:
    brw  = MSP430X_SPIB0_CLK_FREQ / spip->config->bit_rate;
    7a40:	2c 41       	mov	@r1,	r12	;
    7a42:	1c 4c 02 00 	mov	2(r12),	r12	;
    7a46:	1d 4c 06 00 	mov	6(r12),	r13	;
    7a4a:	1c 4c 04 00 	mov	4(r12),	r12	;
    7a4e:	0e 4c       	mov	r12,	r14	;
    7a50:	0f 4d       	mov	r13,	r15	;
    7a52:	3c 40 00 12 	mov	#4608,	r12	;#0x1200
    7a56:	7d 40 7a 00 	mov.b	#122,	r13	;#0x007a
    7a5a:	b0 12 c4 7e 	call	#32452		;#0x7ec4
    7a5e:	81 4c 04 00 	mov	r12,	4(r1)	;

00007a62 <.Loc.366.3>:
    ssel = MSP430X_SPIB0_UCSSEL;
    7a62:	f1 40 80 ff 	mov.b	#65408,	3(r1)	;#0xff80
    7a66:	03 00 

00007a68 <.L14>:
    brw  = MSP430X_SPIB3_CLK_FREQ / spip->config->bit_rate;
    ssel = MSP430X_SPIB3_UCSSEL;
  }
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
    7a68:	2c 41       	mov	@r1,	r12	;
    7a6a:	1c 4c 06 00 	mov	6(r12),	r12	;
    7a6e:	9c 43 00 00 	mov	#1,	0(r12)	;r3 As==01

00007a72 <.Loc.389.3>:
  spip->regs->brw   = brw;
    7a72:	2c 41       	mov	@r1,	r12	;
    7a74:	1c 4c 06 00 	mov	6(r12),	r12	;
    7a78:	9c 41 04 00 	mov	4(r1),	6(r12)	;
    7a7c:	06 00 

00007a7e <.Loc.390.3>:
  spip->regs->ctlw0 =
    7a7e:	2c 41       	mov	@r1,	r12	;
    7a80:	1d 4c 06 00 	mov	6(r12),	r13	;

00007a84 <.Loc.391.3>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    7a84:	2c 41       	mov	@r1,	r12	;
    7a86:	1c 4c 02 00 	mov	2(r12),	r12	;
    7a8a:	5c 4c 0a 00 	mov.b	10(r12),r12	;0x0000a
    7a8e:	6c e3       	xor.b	#2,	r12	;r3 As==10
    7a90:	3c f0 ff 00 	and	#255,	r12	;#0x00ff
    7a94:	0e 4c       	mov	r12,	r14	;
    7a96:	4d 18 0e 5e 	rpt #14 { rlax.w	r14		;
    7a9a:	2c 41       	mov	@r1,	r12	;
    7a9c:	1c 4c 02 00 	mov	2(r12),	r12	;
    7aa0:	5c 4c 08 00 	mov.b	8(r12),	r12	;
    7aa4:	4c 18 0c 5c 	rpt #13 { rlax.w	r12		;
    7aa8:	0e dc       	bis	r12,	r14	;

00007aaa <.Loc.392.3>:
      (spip->config->data_size << 12) | (UCMST) |
    7aaa:	2c 41       	mov	@r1,	r12	;
    7aac:	1c 4c 02 00 	mov	2(r12),	r12	;
    7ab0:	5c 4c 09 00 	mov.b	9(r12),	r12	;
    7ab4:	4b 18 0c 5c 	rpt #12 { rlax.w	r12		;

00007ab8 <.Loc.391.3>:
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
    7ab8:	0c de       	bis	r14,	r12	;

00007aba <.Loc.392.3>:
      (spip->config->data_size << 12) | (UCMST) |
    7aba:	0e 4c       	mov	r12,	r14	;
    7abc:	3e d0 00 08 	bis	#2048,	r14	;#0x0800

00007ac0 <.Loc.393.3>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    7ac0:	2c 41       	mov	@r1,	r12	;
    7ac2:	1c 4c 02 00 	mov	2(r12),	r12	;
    7ac6:	1c 4c 02 00 	mov	2(r12),	r12	;
    7aca:	0c 93       	cmp	#0,	r12	;r3 As==00
    7acc:	02 24       	jz	$+6      	;abs 0x7ad2

00007ace <.Loc.393.3>:
    7ace:	4c 43       	clr.b	r12		;
    7ad0:	02 3c       	jmp	$+6      	;abs 0x7ad6

00007ad2 <.L15>:
    7ad2:	3c 40 00 04 	mov	#1024,	r12	;#0x0400

00007ad6 <.L16>:
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
      (spip->config->data_size << 12) | (UCMST) |
    7ad6:	0c de       	bis	r14,	r12	;

00007ad8 <.Loc.393.3>:
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
    7ad8:	0e 4c       	mov	r12,	r14	;
    7ada:	3e d0 00 01 	bis	#256,	r14	;#0x0100
    7ade:	5c 41 03 00 	mov.b	3(r1),	r12	;
    7ae2:	0c de       	bis	r14,	r12	;
    7ae4:	2c d3       	bis	#2,	r12	;r3 As==10

00007ae6 <.Loc.390.3>:
  }
#endif
  /* Configures the peripheral.*/
  spip->regs->ctlw0 = UCSWRST;
  spip->regs->brw   = brw;
  spip->regs->ctlw0 =
    7ae6:	8d 4c 00 00 	mov	r12,	0(r13)	;

00007aea <.Loc.394.3>:
      ((spip->config->spi_mode ^ 0x02) << 14) | (spip->config->bit_order << 13) |
      (spip->config->data_size << 12) | (UCMST) |
      ((spip->config->ss_line ? 0 : 2) << 9) | (UCSYNC) | (ssel) | (UCSTEM);
  *(spip->ifg) = 0;
    7aea:	2c 41       	mov	@r1,	r12	;
    7aec:	1c 4c 08 00 	mov	8(r12),	r12	;
    7af0:	8c 43 00 00 	mov	#0,	0(r12)	;r3 As==00

00007af4 <.Loc.395.3>:
  spi_lld_unselect(spip);
    7af4:	2c 41       	mov	@r1,	r12	;
    7af6:	b0 12 62 7b 	call	#31586		;#0x7b62

00007afa <.Loc.396.3>:
}
    7afa:	03 43       	nop			
    7afc:	31 50 06 00 	add	#6,	r1	;
    7b00:	30 41       	ret			

00007b02 <spi_lld_select>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_select(SPIDriver * spip) {
    7b02:	1a 15       	pushm	#2,	r10	;16-bit words

00007b04 <L0>:
    7b04:	21 83       	decd	r1		;

00007b06 <.LCFI6>:
    7b06:	81 4c 00 00 	mov	r12,	0(r1)	;

00007b0a <.Loc.426.3>:

  if (spip->config->ss_line) {
    7b0a:	2c 41       	mov	@r1,	r12	;
    7b0c:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b10:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b14:	0c 93       	cmp	#0,	r12	;r3 As==00
    7b16:	21 24       	jz	$+68     	;abs 0x7b5a

00007b18 <.Loc.427.3>:
    palClearLine(spip->config->ss_line);
    7b18:	2c 41       	mov	@r1,	r12	;
    7b1a:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b1e:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b22:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    7b26:	0a 4c       	mov	r12,	r10	;
    7b28:	2c 41       	mov	@r1,	r12	;
    7b2a:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b2e:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b32:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    7b36:	19 4c 02 00 	mov	2(r12),	r9	;
    7b3a:	2c 41       	mov	@r1,	r12	;
    7b3c:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b40:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b44:	0d 4c       	mov	r12,	r13	;
    7b46:	5d 03       	rrum	#1,	r13	;
    7b48:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    7b4c:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7b4e:	b0 12 f6 7e 	call	#32502		;#0x7ef6
    7b52:	3c e3       	inv	r12		;
    7b54:	0c f9       	and	r9,	r12	;
    7b56:	8a 4c 02 00 	mov	r12,	2(r10)	;

00007b5a <.L22>:
  }
}
    7b5a:	03 43       	nop			
    7b5c:	21 53       	incd	r1		;
    7b5e:	19 17       	popm	#2,	r10	;16-bit words
    7b60:	30 41       	ret			

00007b62 <spi_lld_unselect>:
 *
 * @param[in] spip      pointer to the @p SPIDriver object
 *
 * @notapi
 */
void spi_lld_unselect(SPIDriver * spip) {
    7b62:	1a 15       	pushm	#2,	r10	;16-bit words

00007b64 <.LCFI7>:
    7b64:	21 83       	decd	r1		;

00007b66 <.LCFI8>:
    7b66:	81 4c 00 00 	mov	r12,	0(r1)	;

00007b6a <.Loc.441.3>:

  if (spip->config->ss_line) {
    7b6a:	2c 41       	mov	@r1,	r12	;
    7b6c:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b70:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b74:	0c 93       	cmp	#0,	r12	;r3 As==00
    7b76:	20 24       	jz	$+66     	;abs 0x7bb8

00007b78 <.Loc.442.3>:
    palSetLine(spip->config->ss_line);
    7b78:	2c 41       	mov	@r1,	r12	;
    7b7a:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b7e:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b82:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    7b86:	0a 4c       	mov	r12,	r10	;
    7b88:	2c 41       	mov	@r1,	r12	;
    7b8a:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b8e:	1c 4c 02 00 	mov	2(r12),	r12	;
    7b92:	3c f0 ff 0f 	and	#4095,	r12	;#0x0fff
    7b96:	19 4c 02 00 	mov	2(r12),	r9	;
    7b9a:	2c 41       	mov	@r1,	r12	;
    7b9c:	1c 4c 02 00 	mov	2(r12),	r12	;
    7ba0:	1c 4c 02 00 	mov	2(r12),	r12	;
    7ba4:	0d 4c       	mov	r12,	r13	;
    7ba6:	5d 03       	rrum	#1,	r13	;
    7ba8:	4a 18 0d 11 	rpt #11 { rrax.w	r13		;
    7bac:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7bae:	b0 12 f6 7e 	call	#32502		;#0x7ef6
    7bb2:	0c d9       	bis	r9,	r12	;
    7bb4:	8a 4c 02 00 	mov	r12,	2(r10)	;

00007bb8 <.L25>:
  }
}
    7bb8:	03 43       	nop			
    7bba:	21 53       	incd	r1		;
    7bbc:	19 17       	popm	#2,	r10	;16-bit words
    7bbe:	30 41       	ret			

00007bc0 <spi_lld_send>:
 * @param[in] n         number of words to send
 * @param[in] txbuf     the pointer to the transmit buffer
 *
 * @notapi
 */
void spi_lld_send(SPIDriver * spip, size_t n, const void * txbuf) {
    7bc0:	31 80 06 00 	sub	#6,	r1	;

00007bc4 <.LCFI11>:
    7bc4:	81 4c 04 00 	mov	r12,	4(r1)	;
    7bc8:	81 4d 02 00 	mov	r13,	2(r1)	;
    7bcc:	81 4e 00 00 	mov	r14,	0(r1)	;

00007bd0 <.Loc.516.3>:

  spip->tx_req.source_addr = txbuf;
    7bd0:	1c 41 04 00 	mov	4(r1),	r12	;
    7bd4:	ac 41 0a 00 	mov	@r1,	10(r12)	; 0x000a

00007bd8 <.Loc.517.3>:
  spip->tx_req.size        = n;
    7bd8:	1c 41 04 00 	mov	4(r1),	r12	;
    7bdc:	9c 41 02 00 	mov	2(r1),	14(r12)	; 0x000e
    7be0:	0e 00 

00007be2 <.Loc.518.3>:
  spip->tx_req.addr_mode   = MSP430X_DMA_SRCINCR;
    7be2:	1c 41 04 00 	mov	4(r1),	r12	;
    7be6:	bc 40 00 03 	mov	#768,	16(r12)	;#0x0300, 0x0010
    7bea:	10 00 

00007bec <.Loc.520.3>:

  spip->rx_req.dest_addr = &dummyrx;
    7bec:	1c 41 04 00 	mov	4(r1),	r12	;
    7bf0:	bc 40 62 52 	mov	#21090,	30(r12)	;#0x5262, 0x001e
    7bf4:	1e 00 

00007bf6 <.Loc.521.3>:
  spip->rx_req.size      = n;
    7bf6:	1c 41 04 00 	mov	4(r1),	r12	;
    7bfa:	9c 41 02 00 	mov	2(r1),	32(r12)	; 0x0020
    7bfe:	20 00 

00007c00 <.Loc.522.3>:
  spip->rx_req.addr_mode = 0;
    7c00:	1c 41 04 00 	mov	4(r1),	r12	;
    7c04:	8c 43 22 00 	mov	#0,	34(r12)	;r3 As==00, 0x0022

00007c08 <.Loc.524.3>:

  init_transfer(spip);
    7c08:	1c 41 04 00 	mov	4(r1),	r12	;
    7c0c:	b0 12 96 78 	call	#30870		;#0x7896

00007c10 <.Loc.525.3>:
}
    7c10:	03 43       	nop			
    7c12:	31 50 06 00 	add	#6,	r1	;
    7c16:	30 41       	ret			

00007c18 <spi_lld_receive>:
 * @param[in] n         number of words to receive
 * @param[out] rxbuf    the pointer to the receive buffer
 *
 * @notapi
 */
void spi_lld_receive(SPIDriver * spip, size_t n, void * rxbuf) {
    7c18:	31 80 06 00 	sub	#6,	r1	;

00007c1c <.LCFI12>:
    7c1c:	81 4c 04 00 	mov	r12,	4(r1)	;
    7c20:	81 4d 02 00 	mov	r13,	2(r1)	;
    7c24:	81 4e 00 00 	mov	r14,	0(r1)	;

00007c28 <.Loc.542.3>:

  spip->tx_req.source_addr = &dummytx;
    7c28:	1c 41 04 00 	mov	4(r1),	r12	;
    7c2c:	bc 40 4e 50 	mov	#20558,	10(r12)	;#0x504e, 0x000a
    7c30:	0a 00 

00007c32 <.Loc.543.3>:
  spip->tx_req.size        = n;
    7c32:	1c 41 04 00 	mov	4(r1),	r12	;
    7c36:	9c 41 02 00 	mov	2(r1),	14(r12)	; 0x000e
    7c3a:	0e 00 

00007c3c <.Loc.544.3>:
  spip->tx_req.addr_mode   = 0;
    7c3c:	1c 41 04 00 	mov	4(r1),	r12	;
    7c40:	8c 43 10 00 	mov	#0,	16(r12)	;r3 As==00, 0x0010

00007c44 <.Loc.546.3>:

  spip->rx_req.dest_addr = rxbuf;
    7c44:	1c 41 04 00 	mov	4(r1),	r12	;
    7c48:	ac 41 1e 00 	mov	@r1,	30(r12)	; 0x001e

00007c4c <.Loc.547.3>:
  spip->rx_req.size      = n;
    7c4c:	1c 41 04 00 	mov	4(r1),	r12	;
    7c50:	9c 41 02 00 	mov	2(r1),	32(r12)	; 0x0020
    7c54:	20 00 

00007c56 <.Loc.548.3>:
  spip->rx_req.addr_mode = MSP430X_DMA_DSTINCR;
    7c56:	1c 41 04 00 	mov	4(r1),	r12	;
    7c5a:	bc 40 00 0c 	mov	#3072,	34(r12)	;#0x0c00, 0x0022
    7c5e:	22 00 

00007c60 <.Loc.550.3>:

  init_transfer(spip);
    7c60:	1c 41 04 00 	mov	4(r1),	r12	;
    7c64:	b0 12 96 78 	call	#30870		;#0x7896

00007c68 <.Loc.551.3>:
}
    7c68:	03 43       	nop			
    7c6a:	31 50 06 00 	add	#6,	r1	;
    7c6e:	30 41       	ret			

00007c70 <boardInit>:
void boardInit(void) {

  /*
   * External interrupts setup, all disabled initially.
   */
  _disable_interrupts();
    7c70:	32 c2       	dint			

00007c72 <.Loc.46.1>:

}
    7c72:	03 43       	nop			
    7c74:	30 41       	ret			

00007c76 <Vector1>:
#include <msp430.h>

__attribute__((interrupt(1)))
void Vector1(void) {

  while (1) {
    7c76:	ff 3f       	jmp	$+0      	;abs 0x7c76

00007c78 <Vector2>:
    7c78:	ff 3f       	jmp	$+0      	;abs 0x7c78

00007c7a <Vector3>:
  }
}
__attribute__((interrupt(2)))
void Vector2(void) {

  while (1) {
    7c7a:	ff 3f       	jmp	$+0      	;abs 0x7c7a

00007c7c <Vector4>:
  }
}
__attribute__((interrupt(3)))
void Vector3(void) {

  while (1) {
    7c7c:	ff 3f       	jmp	$+0      	;abs 0x7c7c

00007c7e <Vector5>:
  }
}
__attribute__((interrupt(4)))
void Vector4(void) {

  while (1) {
    7c7e:	ff 3f       	jmp	$+0      	;abs 0x7c7e

00007c80 <Vector6>:
  }
}
__attribute__((interrupt(5)))
void Vector5(void) {

  while (1) {
    7c80:	ff 3f       	jmp	$+0      	;abs 0x7c80

00007c82 <Vector7>:
  }
}
__attribute__((interrupt(6)))
void Vector6(void) {

  while (1) {
    7c82:	ff 3f       	jmp	$+0      	;abs 0x7c82

00007c84 <Vector8>:
  }
}
__attribute__((interrupt(7)))
void Vector7(void) {

  while (1) {
    7c84:	ff 3f       	jmp	$+0      	;abs 0x7c84

00007c86 <Vector9>:
  }
}
__attribute__((interrupt(8)))
void Vector8(void) {

  while (1) {
    7c86:	ff 3f       	jmp	$+0      	;abs 0x7c86

00007c88 <Vector10>:
  }
}
__attribute__((interrupt(9)))
void Vector9(void) {

  while (1) {
    7c88:	ff 3f       	jmp	$+0      	;abs 0x7c88

00007c8a <Vector11>:
  }
}
__attribute__((interrupt(10)))
void Vector10(void) {

  while (1) {
    7c8a:	ff 3f       	jmp	$+0      	;abs 0x7c8a

00007c8c <Vector12>:
  }
}
__attribute__((interrupt(11)))
void Vector11(void) {

  while (1) {
    7c8c:	ff 3f       	jmp	$+0      	;abs 0x7c8c

00007c8e <Vector13>:
  }
}
__attribute__((interrupt(12)))
void Vector12(void) {

  while (1) {
    7c8e:	ff 3f       	jmp	$+0      	;abs 0x7c8e

00007c90 <Vector14>:
  }
}
__attribute__((interrupt(13)))
void Vector13(void) {

  while (1) {
    7c90:	ff 3f       	jmp	$+0      	;abs 0x7c90

00007c92 <Vector15>:
  }
}
__attribute__((interrupt(14)))
void Vector14(void) {

  while (1) {
    7c92:	ff 3f       	jmp	$+0      	;abs 0x7c92

00007c94 <Vector16>:
  }
}
__attribute__((interrupt(15)))
void Vector15(void) {

  while (1) {
    7c94:	ff 3f       	jmp	$+0      	;abs 0x7c94

00007c96 <Vector17>:
  }
}
__attribute__((interrupt(16)))
void Vector16(void) {

  while (1) {
    7c96:	ff 3f       	jmp	$+0      	;abs 0x7c96

00007c98 <Vector18>:
  }
}
__attribute__((interrupt(17)))
void Vector17(void) {

  while (1) {
    7c98:	ff 3f       	jmp	$+0      	;abs 0x7c98

00007c9a <Vector19>:
  }
}
__attribute__((interrupt(18)))
void Vector18(void) {

  while (1) {
    7c9a:	ff 3f       	jmp	$+0      	;abs 0x7c9a

00007c9c <Vector20>:
  }
}
__attribute__((interrupt(19)))
void Vector19(void) {

  while (1) {
    7c9c:	ff 3f       	jmp	$+0      	;abs 0x7c9c

00007c9e <Vector21>:
  }
}
__attribute__((interrupt(20)))
void Vector20(void) {

  while (1) {
    7c9e:	ff 3f       	jmp	$+0      	;abs 0x7c9e

00007ca0 <Vector22>:
  }
}
__attribute__((interrupt(21)))
void Vector21(void) {

  while (1) {
    7ca0:	ff 3f       	jmp	$+0      	;abs 0x7ca0

00007ca2 <Vector23>:
  }
}
__attribute__((interrupt(22)))
void Vector22(void) {

  while (1) {
    7ca2:	ff 3f       	jmp	$+0      	;abs 0x7ca2

00007ca4 <Vector24>:
  }
}
__attribute__((interrupt(23)))
void Vector23(void) {

  while (1) {
    7ca4:	ff 3f       	jmp	$+0      	;abs 0x7ca4

00007ca6 <Vector25>:
  }
}
__attribute__((interrupt(24)))
void Vector24(void) {

  while (1) {
    7ca6:	ff 3f       	jmp	$+0      	;abs 0x7ca6

00007ca8 <Vector26>:
  }
}
__attribute__((interrupt(25)))
void Vector25(void) {

  while (1) {
    7ca8:	ff 3f       	jmp	$+0      	;abs 0x7ca8

00007caa <Vector27>:
  }
}
__attribute__((interrupt(26)))
void Vector26(void) {

  while (1) {
    7caa:	ff 3f       	jmp	$+0      	;abs 0x7caa

00007cac <Vector28>:
  }
}
__attribute__((interrupt(27)))
void Vector27(void) {

  while (1) {
    7cac:	ff 3f       	jmp	$+0      	;abs 0x7cac

00007cae <Vector29>:
  }
}
__attribute__((interrupt(28)))
void Vector28(void) {

  while (1) {
    7cae:	ff 3f       	jmp	$+0      	;abs 0x7cae

00007cb0 <Vector30>:
  }
}
__attribute__((interrupt(29)))
void Vector29(void) {

  while (1) {
    7cb0:	ff 3f       	jmp	$+0      	;abs 0x7cb0

00007cb2 <Vector31>:
  }
}
__attribute__((interrupt(30)))
void Vector30(void) {

  while (1) {
    7cb2:	ff 3f       	jmp	$+0      	;abs 0x7cb2

00007cb4 <Vector32>:
  }
}
__attribute__((interrupt(31)))
void Vector31(void) {

  while (1) {
    7cb4:	ff 3f       	jmp	$+0      	;abs 0x7cb4

00007cb6 <Vector33>:
  }
}
__attribute__((interrupt(32)))
void Vector32(void) {

  while (1) {
    7cb6:	ff 3f       	jmp	$+0      	;abs 0x7cb6

00007cb8 <Vector34>:
  }
}
__attribute__((interrupt(33)))
void Vector33(void) {

  while (1) {
    7cb8:	ff 3f       	jmp	$+0      	;abs 0x7cb8

00007cba <Vector35>:
  }
}
__attribute__((interrupt(34)))
void Vector34(void) {

  while (1) {
    7cba:	ff 3f       	jmp	$+0      	;abs 0x7cba

00007cbc <Vector36>:
  }
}
__attribute__((interrupt(35)))
void Vector35(void) {

  while (1) {
    7cbc:	ff 3f       	jmp	$+0      	;abs 0x7cbc

00007cbe <Vector37>:
  }
}
__attribute__((interrupt(36)))
void Vector36(void) {

  while (1) {
    7cbe:	ff 3f       	jmp	$+0      	;abs 0x7cbe

00007cc0 <Vector38>:
  }
}
__attribute__((interrupt(37)))
void Vector37(void) {

  while (1) {
    7cc0:	ff 3f       	jmp	$+0      	;abs 0x7cc0

00007cc2 <Vector39>:
  }
}
__attribute__((interrupt(38)))
void Vector38(void) {

  while (1) {
    7cc2:	ff 3f       	jmp	$+0      	;abs 0x7cc2

00007cc4 <Vector40>:
  }
}
__attribute__((interrupt(39)))
void Vector39(void) {

  while (1) {
    7cc4:	ff 3f       	jmp	$+0      	;abs 0x7cc4

00007cc6 <Vector41>:
  }
}
__attribute__((interrupt(40)))
void Vector40(void) {

  while (1) {
    7cc6:	ff 3f       	jmp	$+0      	;abs 0x7cc6

00007cc8 <Vector42>:
  }
}
__attribute__((interrupt(41)))
void Vector41(void) {

  while (1) {
    7cc8:	ff 3f       	jmp	$+0      	;abs 0x7cc8

00007cca <Vector44>:
  }
}
__attribute__((interrupt(42)))
void Vector42(void) {

  while (1) {
    7cca:	ff 3f       	jmp	$+0      	;abs 0x7cca

00007ccc <Vector45>:
  }
}
__attribute__((interrupt(44)))
void Vector44(void) {

  while (1) {
    7ccc:	ff 3f       	jmp	$+0      	;abs 0x7ccc

00007cce <Vector46>:
  }
}
__attribute__((interrupt(45)))
void Vector45(void) {

  while (1) {
    7cce:	ff 3f       	jmp	$+0      	;abs 0x7cce

00007cd0 <Vector47>:
  }
}
__attribute__((interrupt(46)))
void Vector46(void) {

  while (1) {
    7cd0:	ff 3f       	jmp	$+0      	;abs 0x7cd0

00007cd2 <Vector48>:
  }
}
__attribute__((interrupt(47)))
void Vector47(void) {

  while (1) {
    7cd2:	ff 3f       	jmp	$+0      	;abs 0x7cd2

00007cd4 <Vector50>:
  }
}
__attribute__((interrupt(48)))
void Vector48(void) {

  while (1) {
    7cd4:	ff 3f       	jmp	$+0      	;abs 0x7cd4

00007cd6 <Vector51>:
  }
}
__attribute__((interrupt(50)))
void Vector50(void) {

  while (1) {
    7cd6:	ff 3f       	jmp	$+0      	;abs 0x7cd6

00007cd8 <Vector53>:
  }
}
__attribute__((interrupt(51)))
void Vector51(void) {

  while (1) {
    7cd8:	ff 3f       	jmp	$+0      	;abs 0x7cd8

00007cda <Vector54>:
  }
}
__attribute__((interrupt(53)))
void Vector53(void) {

  while (1) {
    7cda:	ff 3f       	jmp	$+0      	;abs 0x7cda

00007cdc <Vector55>:
  }
}
__attribute__((interrupt(54)))
void Vector54(void) {

  while (1) {
    7cdc:	ff 3f       	jmp	$+0      	;abs 0x7cdc

00007cde <sx1278_read_register>:
  }
}
__attribute__((interrupt(55)))
void Vector55(void) {

  while (1) {
    7cde:	21 83       	decd	r1		;

00007ce0 <L0>:
  
  
  return buf;
}

static uint8_t sx1278_read_register(uint8_t reg) {
    7ce0:	c1 4c 01 00 	mov.b	r12,	1(r1)	;

00007ce4 <.Loc.53.1>:
  static uint8_t buf;
  
  osalDbgAssert(!(reg & 0x7F), "register address out of bounds");
  
  buf = reg;
    7ce4:	d2 41 01 00 	mov.b	1(r1),	&0x5a94	;
    7ce8:	94 5a 

00007cea <.Loc.55.1>:
  
  SPIDA1_config.ss_line = LINE_SX1278_SS_B;
    7cea:	b2 40 20 32 	mov	#12832,	&0x5172	;#0x3220
    7cee:	72 51 

00007cf0 <.Loc.56.1>:
  spiStart(&SPIDA1, &SPIDA1_config);
    7cf0:	3d 40 70 51 	mov	#20848,	r13	;#0x5170
    7cf4:	3c 40 06 52 	mov	#20998,	r12	;#0x5206
    7cf8:	b0 12 82 6a 	call	#27266		;#0x6a82

00007cfc <.Loc.58.1>:
  
  spiSelect(&SPIDA1);
    7cfc:	3c 40 06 52 	mov	#20998,	r12	;#0x5206
    7d00:	b0 12 b2 6a 	call	#27314		;#0x6ab2

00007d04 <.Loc.59.1>:
  spiSend(&SPIDA1, 1, &buf);
    7d04:	3e 40 94 5a 	mov	#23188,	r14	;#0x5a94
    7d08:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7d0a:	3c 40 06 52 	mov	#20998,	r12	;#0x5206
    7d0e:	b0 12 e6 6a 	call	#27366		;#0x6ae6

00007d12 <.Loc.60.1>:
  spiReceive(&SPIDA1, 1, &buf);
    7d12:	3e 40 94 5a 	mov	#23188,	r14	;#0x5a94
    7d16:	5d 43       	mov.b	#1,	r13	;r3 As==01
    7d18:	3c 40 06 52 	mov	#20998,	r12	;#0x5206
    7d1c:	b0 12 28 6b 	call	#27432		;#0x6b28

00007d20 <.Loc.61.1>:
  spiUnselect(&SPIDA1);
    7d20:	3c 40 06 52 	mov	#20998,	r12	;#0x5206
    7d24:	b0 12 cc 6a 	call	#27340		;#0x6acc

00007d28 <.Loc.63.1>:
  
  return buf;
    7d28:	5c 42 94 5a 	mov.b	&0x5a94,r12	;0x5a94

00007d2c <.Loc.64.1>:
}
    7d2c:	21 53       	incd	r1		;
    7d2e:	30 41       	ret			

00007d30 <sx1278_reset>:
  palSetLineMode(LINE_SX1212_RESET, PAL_MODE_INPUT_PULLDOWN);
  chThdSleepMilliseconds(5);
}

static void sx1278_reset(void) {
  palSetLineMode(LINE_SX1278_RESET_B, PAL_MODE_OUTPUT_PUSHPULL);
    7d30:	7e 40 06 00 	mov.b	#6,	r14	;
    7d34:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    7d38:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    7d3c:	b0 12 74 72 	call	#29300		;#0x7274

00007d40 <.Loc.77.1>:
  palClearLine(LINE_SX1278_RESET_B);
    7d40:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    7d44:	3d 40 20 02 	mov	#544,	r13	;#0x0220
    7d48:	1d 4d 02 00 	mov	2(r13),	r13	;
    7d4c:	3d f0 bf ff 	and	#65471,	r13	;#0xffbf
    7d50:	8c 4d 02 00 	mov	r13,	2(r12)	;

00007d54 <.Loc.78.1>:
  chThdSleepMilliseconds(1);
    7d54:	5c 43       	mov.b	#1,	r12	;r3 As==01
    7d56:	b0 12 d2 5e 	call	#24274		;#0x5ed2

00007d5a <.Loc.79.1>:
  palSetLine(LINE_SX1278_RESET_B);
    7d5a:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    7d5e:	3d 40 20 02 	mov	#544,	r13	;#0x0220
    7d62:	1d 4d 02 00 	mov	2(r13),	r13	;
    7d66:	3d d0 40 00 	bis	#64,	r13	;#0x0040
    7d6a:	8c 4d 02 00 	mov	r13,	2(r12)	;

00007d6e <.Loc.80.1>:
  palSetLineMode(LINE_SX1278_RESET_B, PAL_MODE_INPUT_PULLUP);
    7d6e:	7e 40 03 00 	mov.b	#3,	r14	;
    7d72:	7d 40 40 00 	mov.b	#64,	r13	;#0x0040
    7d76:	3c 40 20 02 	mov	#544,	r12	;#0x0220
    7d7a:	b0 12 74 72 	call	#29300		;#0x7274

00007d7e <.Loc.81.1>:
  chThdSleepMilliseconds(5);
    7d7e:	7c 40 05 00 	mov.b	#5,	r12	;
    7d82:	b0 12 d2 5e 	call	#24274		;#0x5ed2

00007d86 <.Loc.82.1>:
}
    7d86:	03 43       	nop			
    7d88:	30 41       	ret			

00007d8a <Thread2>:

/*
 * Thread 2.
 */
THD_WORKING_AREA(waThread2, 2048);
THD_FUNCTION(Thread2, arg) {
    7d8a:	1a 15       	pushm	#2,	r10	;16-bit words

00007d8c <.LCFI2>:
    7d8c:	21 82       	sub	#4,	r1	;r2 As==10

00007d8e <.LCFI3>:
    7d8e:	81 4c 00 00 	mov	r12,	0(r1)	;

00007d92 <.Loc.95.1>:
  (void)arg;

  /*
   * Activate the serial driver 0 using the driver default configuration.
   */
  sdStart(&SD0, NULL);
    7d92:	4d 43       	clr.b	r13		;
    7d94:	3c 40 ac 51 	mov	#20908,	r12	;#0x51ac
    7d98:	b0 12 72 69 	call	#26994		;#0x6972

00007d9c <.Loc.97.1>:

  chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));
    7d9c:	1c 42 ac 51 	mov	&0x51ac,r12	;0x51ac
    7da0:	2a 4c       	mov	@r12,	r10	;
    7da2:	19 42 68 51 	mov	&0x5168,r9	;0x5168
    7da6:	1c 42 68 51 	mov	&0x5168,r12	;0x5168
    7daa:	b0 12 1a 80 	call	#32794		;#0x801a
    7dae:	0e 4c       	mov	r12,	r14	;
    7db0:	0d 49       	mov	r9,	r13	;
    7db2:	3c 40 ac 51 	mov	#20908,	r12	;#0x51ac
    7db6:	8a 12       	call	r10		;

00007db8 <.Loc.99.1>:
  
  sx1278_reset();
    7db8:	b0 12 30 7d 	call	#32048		;#0x7d30

00007dbc <.L10>:
  
  while (1) {
    uint8_t buf;
    
    chThdSleepMilliseconds(2000);
    7dbc:	3c 40 d0 07 	mov	#2000,	r12	;#0x07d0
    7dc0:	b0 12 d2 5e 	call	#24274		;#0x5ed2

00007dc4 <.Loc.107.1>:
    
    /* Test 2 - Read an SX1278 register */
    chnWrite(&SD0, (const uint8_t *)test_2_msg, strlen(test_2_msg));
    7dc4:	1c 42 ac 51 	mov	&0x51ac,r12	;0x51ac
    7dc8:	2a 4c       	mov	@r12,	r10	;
    7dca:	19 42 6a 51 	mov	&0x516a,r9	;0x516a
    7dce:	1c 42 6a 51 	mov	&0x516a,r12	;0x516a
    7dd2:	b0 12 1a 80 	call	#32794		;#0x801a
    7dd6:	0e 4c       	mov	r12,	r14	;
    7dd8:	0d 49       	mov	r9,	r13	;
    7dda:	3c 40 ac 51 	mov	#20908,	r12	;#0x51ac
    7dde:	8a 12       	call	r10		;

00007de0 <.Loc.108.1>:
    buf = sx1278_read_register(0x42); /* Silicon version register */
    7de0:	7c 40 42 00 	mov.b	#66,	r12	;#0x0042
    7de4:	b0 12 de 7c 	call	#31966		;#0x7cde
    7de8:	c1 4c 03 00 	mov.b	r12,	3(r1)	;

00007dec <.Loc.109.1>:
    if (buf == 0x12) { /* From datasheet */
    7dec:	f1 90 12 00 	cmp.b	#18,	3(r1)	;#0x0012
    7df0:	03 00 
    7df2:	0f 20       	jnz	$+32     	;abs 0x7e12

00007df4 <.Loc.110.1>:
      chnWrite(&SD0, (const uint8_t *)succeed_string, strlen(succeed_string));
    7df4:	1c 42 ac 51 	mov	&0x51ac,r12	;0x51ac
    7df8:	2a 4c       	mov	@r12,	r10	;
    7dfa:	19 42 6c 51 	mov	&0x516c,r9	;0x516c
    7dfe:	1c 42 6c 51 	mov	&0x516c,r12	;0x516c
    7e02:	b0 12 1a 80 	call	#32794		;#0x801a
    7e06:	0e 4c       	mov	r12,	r14	;
    7e08:	0d 49       	mov	r9,	r13	;
    7e0a:	3c 40 ac 51 	mov	#20908,	r12	;#0x51ac
    7e0e:	8a 12       	call	r10		;
    7e10:	d5 3f       	jmp	$-84     	;abs 0x7dbc

00007e12 <.L8>:
    }
    else {
      chnWrite(&SD0, (const uint8_t *)fail_string, strlen(fail_string));
    7e12:	1c 42 ac 51 	mov	&0x51ac,r12	;0x51ac
    7e16:	2a 4c       	mov	@r12,	r10	;
    7e18:	19 42 6e 51 	mov	&0x516e,r9	;0x516e
    7e1c:	1c 42 6e 51 	mov	&0x516e,r12	;0x516e
    7e20:	b0 12 1a 80 	call	#32794		;#0x801a
    7e24:	0e 4c       	mov	r12,	r14	;
    7e26:	0d 49       	mov	r9,	r13	;
    7e28:	3c 40 ac 51 	mov	#20908,	r12	;#0x51ac
    7e2c:	8a 12       	call	r10		;

00007e2e <.LBE2>:

  chnWrite(&SD0, (const uint8_t *)start_msg, strlen(start_msg));
  
  sx1278_reset();
  
  while (1) {
    7e2e:	c6 3f       	jmp	$-114    	;abs 0x7dbc

00007e30 <main>:
    7e30:	b2 40 80 5a 	Address 0x0000000000007e34 is out of bounds.
mov	#23168,	&0xffff	;#0x5a80
    7e34:	5c 01 

00007e34 <L0>:
   * - HAL initialization, this also initializes the configured device drivers
   *   and performs the board-specific initializations.
   * - Kernel initialization, the main() function becomes a thread and the
   *   RTOS is active.
   */
  WDTCTL = WDTPW | WDTHOLD;
    7e34:	5c 01       	rram	#1,	r12	;

00007e36 <.Loc.141.1>:
  

  halInit();
    7e36:	b0 12 ea 60 	call	#24810		;#0x60ea

00007e3a <.Loc.142.1>:
  chSysInit();
    7e3a:	b0 12 2e 5c 	call	#23598		;#0x5c2e

00007e3e <.Loc.143.1>:
  dmaInit();
    7e3e:	b0 12 e6 77 	call	#30694		;#0x77e6

00007e42 <.L12>:
  
  /* This is now the idle thread loop, you may perform here a low priority
     task but you must never try to sleep or wait in this loop. Note that
     this tasks runs at the lowest priority level so any instruction added
     here will be executed after all other tasks have been started.*/
  while (true) {
    7e42:	ff 3f       	jmp	$+0      	;abs 0x7e42

00007e44 <udivmodsi4>:
    7e44:	5a 15       	pushm	#6,	r10	;16-bit words

00007e46 <L0>:
    7e46:	0a 4c       	mov	r12,	r10	;
    7e48:	0b 4d       	mov	r13,	r11	;

00007e4a <.LVL1>:
    7e4a:	7d 40 21 00 	mov.b	#33,	r13	;#0x0021

00007e4e <.Loc.35.1>:
    7e4e:	58 43       	mov.b	#1,	r8	;r3 As==01
    7e50:	49 43       	clr.b	r9		;

00007e52 <.Loc.38.1>:
    7e52:	07 4b       	mov	r11,	r7	;

00007e54 <.L2>:
    7e54:	0f 9b       	cmp	r11,	r15	;
    7e56:	11 28       	jnc	$+36     	;abs 0x7e7a
    7e58:	07 9f       	cmp	r15,	r7	;
    7e5a:	02 20       	jnz	$+6      	;abs 0x7e60
    7e5c:	0e 9a       	cmp	r10,	r14	;
    7e5e:	0d 28       	jnc	$+28     	;abs 0x7e7a

00007e60 <.L20>:
    7e60:	4c 43       	clr.b	r12		;

00007e62 <.LVL3>:
    7e62:	0d 4c       	mov	r12,	r13	;

00007e64 <.L5>:
    7e64:	07 48       	mov	r8,	r7	;
    7e66:	07 d9       	bis	r9,	r7	;
    7e68:	07 93       	cmp	#0,	r7	;r3 As==00
    7e6a:	19 20       	jnz	$+52     	;abs 0x7e9e

00007e6c <.L6>:
    7e6c:	81 93 0e 00 	cmp	#0,	14(r1)	;r3 As==00, 0x000e
    7e70:	02 24       	jz	$+6      	;abs 0x7e76
    7e72:	0c 4a       	mov	r10,	r12	;
    7e74:	0d 4b       	mov	r11,	r13	;

00007e76 <.L1>:
    7e76:	55 17       	popm	#6,	r10	;16-bit words
    7e78:	30 41       	ret			

00007e7a <.L3>:
    7e7a:	3d 53       	add	#-1,	r13	;r3 As==11

00007e7c <.Loc.38.1>:
    7e7c:	0d 93       	cmp	#0,	r13	;r3 As==00
    7e7e:	20 24       	jz	$+66     	;abs 0x7ec0

00007e80 <.Loc.38.1>:
    7e80:	0f 93       	cmp	#0,	r15	;r3 As==00
    7e82:	ee 3b       	jl	$-34     	;abs 0x7e60

00007e84 <.Loc.40.1>:
    7e84:	05 4e       	mov	r14,	r5	;
    7e86:	06 4f       	mov	r15,	r6	;
    7e88:	05 5e       	add	r14,	r5	;
    7e8a:	06 6f       	addc	r15,	r6	;
    7e8c:	0e 45       	mov	r5,	r14	;

00007e8e <.LVL7>:
    7e8e:	0f 46       	mov	r6,	r15	;

00007e90 <.LVL8>:
    7e90:	05 48       	mov	r8,	r5	;
    7e92:	06 49       	mov	r9,	r6	;
    7e94:	05 58       	add	r8,	r5	;
    7e96:	06 69       	addc	r9,	r6	;
    7e98:	08 45       	mov	r5,	r8	;

00007e9a <.LVL9>:
    7e9a:	09 46       	mov	r6,	r9	;

00007e9c <.LVL10>:
    7e9c:	db 3f       	jmp	$-72     	;abs 0x7e54

00007e9e <.L12>:
    7e9e:	0b 9f       	cmp	r15,	r11	;
    7ea0:	08 28       	jnc	$+18     	;abs 0x7eb2
    7ea2:	0f 9b       	cmp	r11,	r15	;
    7ea4:	02 20       	jnz	$+6      	;abs 0x7eaa
    7ea6:	0a 9e       	cmp	r14,	r10	;
    7ea8:	04 28       	jnc	$+10     	;abs 0x7eb2

00007eaa <.L16>:
    7eaa:	0a 8e       	sub	r14,	r10	;
    7eac:	0b 7f       	subc	r15,	r11	;

00007eae <.Loc.48.1>:
    7eae:	0c d8       	bis	r8,	r12	;

00007eb0 <.LVL13>:
    7eb0:	0d d9       	bis	r9,	r13	;

00007eb2 <.L10>:
    7eb2:	12 c3       	clrc			
    7eb4:	09 10       	rrc	r9		;
    7eb6:	08 10       	rrc	r8		;

00007eb8 <.Loc.51.1>:
    7eb8:	12 c3       	clrc			
    7eba:	0f 10       	rrc	r15		;
    7ebc:	0e 10       	rrc	r14		;
    7ebe:	d2 3f       	jmp	$-90     	;abs 0x7e64

00007ec0 <.L14>:
    7ec0:	0c 4d       	mov	r13,	r12	;

00007ec2 <.LVL18>:
    7ec2:	d4 3f       	jmp	$-86     	;abs 0x7e6c

00007ec4 <__mspabi_divlu>:
    7ec4:	21 83       	decd	r1		;

00007ec6 <.LCFI5>:
    7ec6:	81 43 00 00 	mov	#0,	0(r1)	;r3 As==00

00007eca <L0>:
    7eca:	b0 12 44 7e 	call	#32324		;#0x7e44

00007ece <.LVL46>:
    7ece:	21 53       	incd	r1		;
    7ed0:	30 41       	ret			

00007ed2 <__mspabi_slli_15>:
    7ed2:	0c 5c       	rla	r12		;

00007ed4 <__mspabi_slli_14>:
    7ed4:	0c 5c       	rla	r12		;

00007ed6 <__mspabi_slli_13>:
    7ed6:	0c 5c       	rla	r12		;

00007ed8 <__mspabi_slli_12>:
    7ed8:	0c 5c       	rla	r12		;

00007eda <__mspabi_slli_11>:
    7eda:	0c 5c       	rla	r12		;

00007edc <__mspabi_slli_10>:
    7edc:	0c 5c       	rla	r12		;

00007ede <__mspabi_slli_9>:
    7ede:	0c 5c       	rla	r12		;

00007ee0 <__mspabi_slli_8>:
    7ee0:	0c 5c       	rla	r12		;

00007ee2 <__mspabi_slli_7>:
    7ee2:	0c 5c       	rla	r12		;

00007ee4 <__mspabi_slli_6>:
    7ee4:	0c 5c       	rla	r12		;

00007ee6 <__mspabi_slli_5>:
    7ee6:	0c 5c       	rla	r12		;

00007ee8 <__mspabi_slli_4>:
    7ee8:	0c 5c       	rla	r12		;

00007eea <__mspabi_slli_3>:
    7eea:	0c 5c       	rla	r12		;

00007eec <__mspabi_slli_2>:
    7eec:	0c 5c       	rla	r12		;

00007eee <__mspabi_slli_1>:
    7eee:	0c 5c       	rla	r12		;
    7ef0:	30 41       	ret			

00007ef2 <.L11>:
    7ef2:	3d 53       	add	#-1,	r13	;r3 As==11
    7ef4:	0c 5c       	rla	r12		;

00007ef6 <__mspabi_slli>:
    7ef6:	0d 93       	cmp	#0,	r13	;r3 As==00
    7ef8:	fc 23       	jnz	$-6      	;abs 0x7ef2
    7efa:	30 41       	ret			

00007efc <__mspabi_slll_15>:
    7efc:	0c 5c       	rla	r12		;
    7efe:	0d 6d       	rlc	r13		;

00007f00 <__mspabi_slll_14>:
    7f00:	0c 5c       	rla	r12		;
    7f02:	0d 6d       	rlc	r13		;

00007f04 <__mspabi_slll_13>:
    7f04:	0c 5c       	rla	r12		;
    7f06:	0d 6d       	rlc	r13		;

00007f08 <__mspabi_slll_12>:
    7f08:	0c 5c       	rla	r12		;
    7f0a:	0d 6d       	rlc	r13		;

00007f0c <__mspabi_slll_11>:
    7f0c:	0c 5c       	rla	r12		;
    7f0e:	0d 6d       	rlc	r13		;

00007f10 <__mspabi_slll_10>:
    7f10:	0c 5c       	rla	r12		;
    7f12:	0d 6d       	rlc	r13		;

00007f14 <__mspabi_slll_9>:
    7f14:	0c 5c       	rla	r12		;
    7f16:	0d 6d       	rlc	r13		;

00007f18 <__mspabi_slll_8>:
    7f18:	0c 5c       	rla	r12		;
    7f1a:	0d 6d       	rlc	r13		;

00007f1c <__mspabi_slll_7>:
    7f1c:	0c 5c       	rla	r12		;
    7f1e:	0d 6d       	rlc	r13		;

00007f20 <__mspabi_slll_6>:
    7f20:	0c 5c       	rla	r12		;
    7f22:	0d 6d       	rlc	r13		;

00007f24 <__mspabi_slll_5>:
    7f24:	0c 5c       	rla	r12		;
    7f26:	0d 6d       	rlc	r13		;

00007f28 <__mspabi_slll_4>:
    7f28:	0c 5c       	rla	r12		;
    7f2a:	0d 6d       	rlc	r13		;

00007f2c <__mspabi_slll_3>:
    7f2c:	0c 5c       	rla	r12		;
    7f2e:	0d 6d       	rlc	r13		;

00007f30 <__mspabi_slll_2>:
    7f30:	0c 5c       	rla	r12		;
    7f32:	0d 6d       	rlc	r13		;

00007f34 <__mspabi_slll_1>:
    7f34:	0c 5c       	rla	r12		;
    7f36:	0d 6d       	rlc	r13		;
    7f38:	30 41       	ret			

00007f3a <.L12>:
    7f3a:	3e 53       	add	#-1,	r14	;r3 As==11
    7f3c:	0c 5c       	rla	r12		;
    7f3e:	0d 6d       	rlc	r13		;

00007f40 <__mspabi_slll>:
    7f40:	0e 93       	cmp	#0,	r14	;r3 As==00
    7f42:	fb 23       	jnz	$-8      	;abs 0x7f3a
    7f44:	30 41       	ret			

00007f46 <__mspabi_srli_15>:
    7f46:	12 c3       	clrc			
    7f48:	0c 10       	rrc	r12		;

00007f4a <__mspabi_srli_14>:
    7f4a:	12 c3       	clrc			
    7f4c:	0c 10       	rrc	r12		;

00007f4e <__mspabi_srli_13>:
    7f4e:	12 c3       	clrc			
    7f50:	0c 10       	rrc	r12		;

00007f52 <__mspabi_srli_12>:
    7f52:	12 c3       	clrc			
    7f54:	0c 10       	rrc	r12		;

00007f56 <__mspabi_srli_11>:
    7f56:	12 c3       	clrc			
    7f58:	0c 10       	rrc	r12		;

00007f5a <__mspabi_srli_10>:
    7f5a:	12 c3       	clrc			
    7f5c:	0c 10       	rrc	r12		;

00007f5e <__mspabi_srli_9>:
    7f5e:	12 c3       	clrc			
    7f60:	0c 10       	rrc	r12		;

00007f62 <__mspabi_srli_8>:
    7f62:	12 c3       	clrc			
    7f64:	0c 10       	rrc	r12		;

00007f66 <__mspabi_srli_7>:
    7f66:	12 c3       	clrc			
    7f68:	0c 10       	rrc	r12		;

00007f6a <__mspabi_srli_6>:
    7f6a:	12 c3       	clrc			
    7f6c:	0c 10       	rrc	r12		;

00007f6e <__mspabi_srli_5>:
    7f6e:	12 c3       	clrc			
    7f70:	0c 10       	rrc	r12		;

00007f72 <__mspabi_srli_4>:
    7f72:	12 c3       	clrc			
    7f74:	0c 10       	rrc	r12		;

00007f76 <__mspabi_srli_3>:
    7f76:	12 c3       	clrc			
    7f78:	0c 10       	rrc	r12		;

00007f7a <__mspabi_srli_2>:
    7f7a:	12 c3       	clrc			
    7f7c:	0c 10       	rrc	r12		;

00007f7e <__mspabi_srli_1>:
    7f7e:	12 c3       	clrc			
    7f80:	0c 10       	rrc	r12		;
    7f82:	30 41       	ret			

00007f84 <.L11>:
    7f84:	3d 53       	add	#-1,	r13	;r3 As==11
    7f86:	12 c3       	clrc			
    7f88:	0c 10       	rrc	r12		;

00007f8a <__mspabi_srli>:
    7f8a:	0d 93       	cmp	#0,	r13	;r3 As==00
    7f8c:	fb 23       	jnz	$-8      	;abs 0x7f84
    7f8e:	30 41       	ret			

00007f90 <__mspabi_srll_15>:
    7f90:	12 c3       	clrc			
    7f92:	0d 10       	rrc	r13		;
    7f94:	0c 10       	rrc	r12		;

00007f96 <__mspabi_srll_14>:
    7f96:	12 c3       	clrc			
    7f98:	0d 10       	rrc	r13		;
    7f9a:	0c 10       	rrc	r12		;

00007f9c <__mspabi_srll_13>:
    7f9c:	12 c3       	clrc			
    7f9e:	0d 10       	rrc	r13		;
    7fa0:	0c 10       	rrc	r12		;

00007fa2 <__mspabi_srll_12>:
    7fa2:	12 c3       	clrc			
    7fa4:	0d 10       	rrc	r13		;
    7fa6:	0c 10       	rrc	r12		;

00007fa8 <__mspabi_srll_11>:
    7fa8:	12 c3       	clrc			
    7faa:	0d 10       	rrc	r13		;
    7fac:	0c 10       	rrc	r12		;

00007fae <__mspabi_srll_10>:
    7fae:	12 c3       	clrc			
    7fb0:	0d 10       	rrc	r13		;
    7fb2:	0c 10       	rrc	r12		;

00007fb4 <__mspabi_srll_9>:
    7fb4:	12 c3       	clrc			
    7fb6:	0d 10       	rrc	r13		;
    7fb8:	0c 10       	rrc	r12		;

00007fba <__mspabi_srll_8>:
    7fba:	12 c3       	clrc			
    7fbc:	0d 10       	rrc	r13		;
    7fbe:	0c 10       	rrc	r12		;

00007fc0 <__mspabi_srll_7>:
    7fc0:	12 c3       	clrc			
    7fc2:	0d 10       	rrc	r13		;
    7fc4:	0c 10       	rrc	r12		;

00007fc6 <__mspabi_srll_6>:
    7fc6:	12 c3       	clrc			
    7fc8:	0d 10       	rrc	r13		;
    7fca:	0c 10       	rrc	r12		;

00007fcc <__mspabi_srll_5>:
    7fcc:	12 c3       	clrc			
    7fce:	0d 10       	rrc	r13		;
    7fd0:	0c 10       	rrc	r12		;

00007fd2 <__mspabi_srll_4>:
    7fd2:	12 c3       	clrc			
    7fd4:	0d 10       	rrc	r13		;
    7fd6:	0c 10       	rrc	r12		;

00007fd8 <__mspabi_srll_3>:
    7fd8:	12 c3       	clrc			
    7fda:	0d 10       	rrc	r13		;
    7fdc:	0c 10       	rrc	r12		;

00007fde <__mspabi_srll_2>:
    7fde:	12 c3       	clrc			
    7fe0:	0d 10       	rrc	r13		;
    7fe2:	0c 10       	rrc	r12		;

00007fe4 <__mspabi_srll_1>:
    7fe4:	12 c3       	clrc			
    7fe6:	0d 10       	rrc	r13		;
    7fe8:	0c 10       	rrc	r12		;
    7fea:	30 41       	ret			

00007fec <.L12>:
    7fec:	3e 53       	add	#-1,	r14	;r3 As==11
    7fee:	12 c3       	clrc			
    7ff0:	0d 10       	rrc	r13		;
    7ff2:	0c 10       	rrc	r12		;

00007ff4 <__mspabi_srll>:
    7ff4:	0e 93       	cmp	#0,	r14	;r3 As==00
    7ff6:	fa 23       	jnz	$-10     	;abs 0x7fec
    7ff8:	30 41       	ret			

00007ffa <__mspabi_mpyl>:
    7ffa:	02 12       	push	r2		;
    7ffc:	32 c2       	dint			
    7ffe:	03 43       	nop			
    8000:	82 4c d0 04 	mov	r12,	&0x04d0	;
    8004:	82 4d d2 04 	mov	r13,	&0x04d2	;
    8008:	82 4e e0 04 	mov	r14,	&0x04e0	;
    800c:	82 4f e2 04 	mov	r15,	&0x04e2	;
    8010:	1c 42 e4 04 	mov	&0x04e4,r12	;0x04e4
    8014:	1d 42 e6 04 	mov	&0x04e6,r13	;0x04e6
    8018:	00 13       	reti			

0000801a <strlen>:
    801a:	0d 4c       	mov	r12,	r13	;

0000801c <.L2>:
    801c:	cd 93 00 00 	cmp.b	#0,	0(r13)	;r3 As==00
    8020:	02 24       	jz	$+6      	;abs 0x8026

00008022 <.Loc.86.1>:
    8022:	1d 53       	inc	r13		;
    8024:	fb 3f       	jmp	$-8      	;abs 0x801c

00008026 <.L5>:
    8026:	0d 8c       	sub	r12,	r13	;

00008028 <.LVL4>:
    8028:	0c 4d       	mov	r13,	r12	;

0000802a <.LVL5>:
    802a:	30 41       	ret			

0000802c <memmove>:
    802c:	0b 4c       	mov	r12,	r11	;

0000802e <L0>:
    802e:	0b 5e       	add	r14,	r11	;

00008030 <.Loc.69.1>:
    8030:	0d 9c       	cmp	r12,	r13	;
    8032:	02 28       	jnc	$+6      	;abs 0x8038

00008034 <.L4>:
    8034:	0e 4c       	mov	r12,	r14	;

00008036 <.LVL2>:
    8036:	0f 3c       	jmp	$+32     	;abs 0x8056

00008038 <.L2>:
    8038:	0f 4d       	mov	r13,	r15	;
    803a:	0f 5e       	add	r14,	r15	;
    803c:	0c 9f       	cmp	r15,	r12	;
    803e:	fa 2f       	jc	$-10     	;abs 0x8034

00008040 <.LVL4>:
    8040:	0d 4f       	mov	r15,	r13	;

00008042 <.LVL5>:
    8042:	0e 8f       	sub	r15,	r14	;

00008044 <.L5>:
    8044:	0f 4d       	mov	r13,	r15	;
    8046:	0f 5e       	add	r14,	r15	;
    8048:	0f 93       	cmp	#0,	r15	;r3 As==00
    804a:	0c 24       	jz	$+26     	;abs 0x8064

0000804c <.Loc.76.1>:
    804c:	3b 53       	add	#-1,	r11	;r3 As==11
    804e:	3d 53       	add	#-1,	r13	;r3 As==11

00008050 <.LVL8>:
    8050:	eb 4d 00 00 	mov.b	@r13,	0(r11)	;
    8054:	f7 3f       	jmp	$-16     	;abs 0x8044

00008056 <.L3>:
    8056:	0b 9e       	cmp	r14,	r11	;
    8058:	05 24       	jz	$+12     	;abs 0x8064

0000805a <.LVL10>:
    805a:	ee 4d 00 00 	mov.b	@r13,	0(r14)	;
    805e:	1e 53       	inc	r14		;

00008060 <.LVL11>:
    8060:	1d 53       	inc	r13		;
    8062:	f9 3f       	jmp	$-12     	;abs 0x8056

00008064 <.L9>:
    8064:	30 41       	ret			

00008066 <memset>:
    8066:	0f 4c       	mov	r12,	r15	;
    8068:	0e 5c       	add	r12,	r14	;

0000806a <.L2>:
    806a:	0f 9e       	cmp	r14,	r15	;

0000806c <L0>:
    806c:	04 24       	jz	$+10     	;abs 0x8076

0000806e <.LVL3>:
    806e:	cf 4d 00 00 	mov.b	r13,	0(r15)	;
    8072:	1f 53       	inc	r15		;

00008074 <.LVL4>:
    8074:	fa 3f       	jmp	$-10     	;abs 0x806a

00008076 <.L5>:
    8076:	30 41       	ret			
